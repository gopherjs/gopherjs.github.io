0ÇX<
crypto/desÇpackage des
import binary "encoding/binary"
import cipher "crypto/cipher"
import strconv "strconv"
const @"".BlockSize = 0x8
type @"".KeySizeError int
func (? @"".KeySizeError) @"".Error() (? string)
func (? *@"".KeySizeError) @"".Error() (? string)
func @"".NewCipher(@"".key []byte) (? @"crypto/cipher".Block, ? error)
func @"".NewTripleDESCipher(@"".key []byte) (? @"crypto/cipher".Block, ? error)
type @"".desCipher struct { @"".subkeys [16]uint64 }
func (? *@"".desCipher) @"".BlockSize() (? int)
func (? *@"".desCipher) @"".Decrypt(@"".dst []byte, @"".src []byte) ()
func (? *@"".desCipher) @"".Encrypt(@"".dst []byte, @"".src []byte) ()
func (? *@"".desCipher) @"".generateSubkeys(@"".keyBytes []byte) ()
type @"".tripleDESCipher struct { @"".cipher1 @"".desCipher; @"".cipher2 @"".desCipher; @"".cipher3 @"".desCipher }
func (? *@"".tripleDESCipher) @"".BlockSize() (? int)
func (? *@"".tripleDESCipher) @"".Decrypt(@"".dst []byte, @"".src []byte) ()
func (? *@"".tripleDESCipher) @"".Encrypt(@"".dst []byte, @"".src []byte) ()
type @"crypto/cipher".Block interface { @"crypto/cipher".BlockSize() (? int); @"crypto/cipher".Decrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte) (); @"crypto/cipher".Encrypt(@"crypto/cipher".dst []byte, @"crypto/cipher".src []byte) () }
$$
0Åâruntimecrypto/subtleerrorssync/atomicsynciocrypto/ciphermathunicode/utf8strconvreflectencoding/binary
crypto/des0H0encoding/binarybinary0crypto/ciphercipher0strconvstrconvÇ9	var KeySizeError;
	KeySizeError = go$newType(4, "Int", "des.KeySizeError", "KeySizeError", "crypto/des", null);
	go$pkg.KeySizeError = KeySizeError;
	var desCipher;
	desCipher = go$newType(0, "Struct", "des.desCipher", "desCipher", "crypto/des", function(subkeys_) {
		this.go$val = this;
		this.subkeys = subkeys_ !== undefined ? subkeys_ : go$makeNativeArray("Uint64", 16, function() { return new Go$Uint64(0, 0); });
	});
	go$pkg.desCipher = desCipher;
	var tripleDESCipher;
	tripleDESCipher = go$newType(0, "Struct", "des.tripleDESCipher", "tripleDESCipher", "crypto/des", function(cipher1_, cipher2_, cipher3_) {
		this.go$val = this;
		this.cipher1 = cipher1_ !== undefined ? cipher1_ : new desCipher.Ptr();
		this.cipher2 = cipher2_ !== undefined ? cipher2_ : new desCipher.Ptr();
		this.cipher3 = cipher3_ !== undefined ? cipher3_ : new desCipher.Ptr();
	});
	go$pkg.tripleDESCipher = tripleDESCipher;
	KeySizeError.methods = [["Error", "", [], [Go$String], false]];
	(go$ptrType(KeySizeError)).methods = [["Error", "", [], [Go$String], false]];
	desCipher.init([["subkeys", "crypto/des", (go$arrayType(Go$Uint64, 16)), ""]]);
	(go$ptrType(desCipher)).methods = [["BlockSize", "", [], [Go$Int], false], ["Decrypt", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["Encrypt", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["generateSubkeys", "crypto/des", [(go$sliceType(Go$Uint8))], [], false]];
	tripleDESCipher.init([["cipher1", "crypto/des", desCipher, ""], ["cipher2", "crypto/des", desCipher, ""], ["cipher3", "crypto/des", desCipher, ""]]);
	(go$ptrType(tripleDESCipher)).methods = [["BlockSize", "", [], [Go$Int], false], ["Decrypt", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["Encrypt", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false]];
ÇÄ	var feistelBox = go$makeNativeArray("Array", 8, function() { return go$makeNativeArray("Uint32", 64, function() { return 0; }); });
	var initialPermutation = go$makeNativeArray("Uint8", 64, function() { return 0; });
	var finalPermutation = go$makeNativeArray("Uint8", 64, function() { return 0; });
	var expansionFunction = go$makeNativeArray("Uint8", 48, function() { return 0; });
	var permutationFunction = go$makeNativeArray("Uint8", 32, function() { return 0; });
	var permutedChoice1 = go$makeNativeArray("Uint8", 56, function() { return 0; });
	var permutedChoice2 = go$makeNativeArray("Uint8", 48, function() { return 0; });
	var sBoxes = go$makeNativeArray("Array", 8, function() { return go$makeNativeArray("Array", 4, function() { return go$makeNativeArray("Uint8", 16, function() { return 0; }); }); });
	var ksRotations = go$makeNativeArray("Uint8", 16, function() { return 0; });
0ÇGÖ0Çä
cryptBlockÇz	var cryptBlock = function(subkeys, dst, src, decrypt) {
		var b, _tuple, left, right, subkey, i, _slice, _index, _slice$1, _index$1, _tuple$1, x, x$1, preOutput;
		b = binary.BigEndian.Uint64(src);
		b = permuteInitialBlock(b);
		_tuple = [(go$shiftRightUint64(b, 32).low >>> 0), (b.low >>> 0)], left = _tuple[0], right = _tuple[1];
		subkey = new Go$Uint64(0, 0);
		i = 0;
		while (i < 16) {
			if (decrypt) {
				subkey = (_slice = subkeys, _index = (15 - i >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			} else {
				subkey = (_slice$1 = subkeys, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			}
			_tuple$1 = [right, (left ^ feistel(right, subkey)) >>> 0], left = _tuple$1[0], right = _tuple$1[1];
			i = i + 1 >> 0;
		}
		preOutput = (x = go$shiftLeft64(new Go$Uint64(0, right), 32), x$1 = new Go$Uint64(0, left), new Go$Uint64(x.high | x$1.high, (x.low | x$1.low) >>> 0));
		binary.BigEndian.PutUint64(dst, permuteFinalBlock(preOutput));
	};
0nencryptBlock^	var encryptBlock = function(subkeys, dst, src) {
		cryptBlock(subkeys, dst, src, false);
	};
0mdecryptBlock]	var decryptBlock = function(subkeys, dst, src) {
		cryptBlock(subkeys, dst, src, true);
	};
0ÇfeistelÇ˜	var feistel = function(right, key) {
		var result, x, sBoxLocations, sBoxResult, i, sBoxLocation, row, column;
		result = 0;
		sBoxLocations = (x = expandBlock(right), new Go$Uint64(key.high ^ x.high, (key.low ^ x.low) >>> 0));
		sBoxResult = 0;
		i = 0;
		while (i < 8) {
			sBoxLocation = ((go$shiftRightUint64(sBoxLocations, 42).low << 24 >>> 24) & 63) >>> 0;
			sBoxLocations = go$shiftLeft64(sBoxLocations, 6);
			row = ((((sBoxLocation & 1) >>> 0)) | (((((sBoxLocation & 32) >>> 0)) >>> 4 << 24 >>> 24))) >>> 0;
			column = (((sBoxLocation >>> 1 << 24 >>> 24)) & 15) >>> 0;
			sBoxResult = (sBoxResult ^ (feistelBox[i][((16 * row << 24 >>> 24) + column << 24 >>> 24)])) >>> 0;
			i = i + 1 << 24 >>> 24;
		}
		result = sBoxResult;
		return result;
	};
0ÇµpermuteBlockÇ£	var permuteBlock = function(src, permutation) {
		var block, _ref, _i, _slice, _index, n, position, x, bit, x$1;
		block = new Go$Uint64(0, 0);
		_ref = permutation;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			n = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			position = _i;
			bit = (x = go$shiftRightUint64(src, n), new Go$Uint64(x.high & 0, (x.low & 1) >>> 0));
			block = (x$1 = go$shiftLeft64(bit, ((((permutation.length - 1 >> 0)) - position >> 0) >>> 0)), new Go$Uint64(block.high | x$1.high, (block.low | x$1.low) >>> 0));
		}
		return block;
	};
0ÇÔexpandBlockÇﬁ	var expandBlock = function(src) {
		var block, i, x, x$1;
		block = new Go$Uint64(0, 0);
		src = (((src << 5 >>> 0)) | ((src >>> 27 >>> 0))) >>> 0;
		i = 0;
		while (i < 8) {
			block = go$shiftLeft64(block, 6);
			block = (x = (x$1 = new Go$Uint64(0, src), new Go$Uint64(x$1.high & 0, (x$1.low & 63) >>> 0)), new Go$Uint64(block.high | x.high, (block.low | x.low) >>> 0));
			src = (((src << 4 >>> 0)) | ((src >>> 28 >>> 0))) >>> 0;
			i = i + 1 >> 0;
		}
		return block;
	};
0Ç
DpermuteInitialBlockÇ
+	var permuteInitialBlock = function(block) {
		var b1, b2, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25;
		b1 = go$shiftRightUint64(block, 48);
		b2 = go$shiftLeft64(block, 48);
		block = (x = (x$1 = (x$2 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$3 = go$shiftLeft64(b1, 48), new Go$Uint64(x$2.high ^ x$3.high, (x$2.low ^ x$3.low) >>> 0)), x$4 = go$shiftRightUint64(b2, 48), new Go$Uint64(x$1.high ^ x$4.high, (x$1.low ^ x$4.low) >>> 0)), new Go$Uint64(block.high ^ x.high, (block.low ^ x.low) >>> 0));
		b1 = (x$5 = go$shiftRightUint64(block, 32), new Go$Uint64(x$5.high & 0, (x$5.low & 16711935) >>> 0));
		b2 = new Go$Uint64(block.high & 0, (block.low & 4278255360) >>> 0);
		block = (x$6 = (x$7 = (x$8 = (x$9 = go$shiftLeft64(b1, 32), new Go$Uint64(x$9.high ^ b2.high, (x$9.low ^ b2.low) >>> 0)), x$10 = go$shiftLeft64(b1, 8), new Go$Uint64(x$8.high ^ x$10.high, (x$8.low ^ x$10.low) >>> 0)), x$11 = go$shiftLeft64(b2, 24), new Go$Uint64(x$7.high ^ x$11.high, (x$7.low ^ x$11.low) >>> 0)), new Go$Uint64(block.high ^ x$6.high, (block.low ^ x$6.low) >>> 0));
		b1 = new Go$Uint64(block.high & 252641280, (block.low & 252641280) >>> 0);
		b2 = new Go$Uint64(block.high & 61680, (block.low & 61680) >>> 0);
		block = (x$12 = (x$13 = (x$14 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$15 = go$shiftRightUint64(b1, 12), new Go$Uint64(x$14.high ^ x$15.high, (x$14.low ^ x$15.low) >>> 0)), x$16 = go$shiftLeft64(b2, 12), new Go$Uint64(x$13.high ^ x$16.high, (x$13.low ^ x$16.low) >>> 0)), new Go$Uint64(block.high ^ x$12.high, (block.low ^ x$12.low) >>> 0));
		b1 = new Go$Uint64(block.high & 855651072, (block.low & 855651072) >>> 0);
		b2 = new Go$Uint64(block.high & 13369548, (block.low & 13369548) >>> 0);
		block = (x$17 = (x$18 = (x$19 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$20 = go$shiftRightUint64(b1, 6), new Go$Uint64(x$19.high ^ x$20.high, (x$19.low ^ x$20.low) >>> 0)), x$21 = go$shiftLeft64(b2, 6), new Go$Uint64(x$18.high ^ x$21.high, (x$18.low ^ x$21.low) >>> 0)), new Go$Uint64(block.high ^ x$17.high, (block.low ^ x$17.low) >>> 0));
		b1 = new Go$Uint64(block.high & 2863311530, (block.low & 1431655765) >>> 0);
		block = (x$22 = (x$23 = (x$24 = go$shiftRightUint64(b1, 33), new Go$Uint64(b1.high ^ x$24.high, (b1.low ^ x$24.low) >>> 0)), x$25 = go$shiftLeft64(b1, 33), new Go$Uint64(x$23.high ^ x$25.high, (x$23.low ^ x$25.low) >>> 0)), new Go$Uint64(block.high ^ x$22.high, (block.low ^ x$22.low) >>> 0));
		return block;
	};
0Ç
@permuteFinalBlockÇ
)	var permuteFinalBlock = function(block) {
		var b1, x, x$1, x$2, x$3, b2, x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25;
		b1 = new Go$Uint64(block.high & 2863311530, (block.low & 1431655765) >>> 0);
		block = (x = (x$1 = (x$2 = go$shiftRightUint64(b1, 33), new Go$Uint64(b1.high ^ x$2.high, (b1.low ^ x$2.low) >>> 0)), x$3 = go$shiftLeft64(b1, 33), new Go$Uint64(x$1.high ^ x$3.high, (x$1.low ^ x$3.low) >>> 0)), new Go$Uint64(block.high ^ x.high, (block.low ^ x.low) >>> 0));
		b1 = new Go$Uint64(block.high & 855651072, (block.low & 855651072) >>> 0);
		b2 = new Go$Uint64(block.high & 13369548, (block.low & 13369548) >>> 0);
		block = (x$4 = (x$5 = (x$6 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$7 = go$shiftRightUint64(b1, 6), new Go$Uint64(x$6.high ^ x$7.high, (x$6.low ^ x$7.low) >>> 0)), x$8 = go$shiftLeft64(b2, 6), new Go$Uint64(x$5.high ^ x$8.high, (x$5.low ^ x$8.low) >>> 0)), new Go$Uint64(block.high ^ x$4.high, (block.low ^ x$4.low) >>> 0));
		b1 = new Go$Uint64(block.high & 252641280, (block.low & 252641280) >>> 0);
		b2 = new Go$Uint64(block.high & 61680, (block.low & 61680) >>> 0);
		block = (x$9 = (x$10 = (x$11 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$12 = go$shiftRightUint64(b1, 12), new Go$Uint64(x$11.high ^ x$12.high, (x$11.low ^ x$12.low) >>> 0)), x$13 = go$shiftLeft64(b2, 12), new Go$Uint64(x$10.high ^ x$13.high, (x$10.low ^ x$13.low) >>> 0)), new Go$Uint64(block.high ^ x$9.high, (block.low ^ x$9.low) >>> 0));
		b1 = (x$14 = go$shiftRightUint64(block, 32), new Go$Uint64(x$14.high & 0, (x$14.low & 16711935) >>> 0));
		b2 = new Go$Uint64(block.high & 0, (block.low & 4278255360) >>> 0);
		block = (x$15 = (x$16 = (x$17 = (x$18 = go$shiftLeft64(b1, 32), new Go$Uint64(x$18.high ^ b2.high, (x$18.low ^ b2.low) >>> 0)), x$19 = go$shiftLeft64(b1, 8), new Go$Uint64(x$17.high ^ x$19.high, (x$17.low ^ x$19.low) >>> 0)), x$20 = go$shiftLeft64(b2, 24), new Go$Uint64(x$16.high ^ x$20.high, (x$16.low ^ x$20.low) >>> 0)), new Go$Uint64(block.high ^ x$15.high, (block.low ^ x$15.low) >>> 0));
		b1 = go$shiftRightUint64(block, 48);
		b2 = go$shiftLeft64(block, 48);
		block = (x$21 = (x$22 = (x$23 = new Go$Uint64(b1.high ^ b2.high, (b1.low ^ b2.low) >>> 0), x$24 = go$shiftLeft64(b1, 48), new Go$Uint64(x$23.high ^ x$24.high, (x$23.low ^ x$24.low) >>> 0)), x$25 = go$shiftRightUint64(b2, 48), new Go$Uint64(x$22.high ^ x$25.high, (x$22.low ^ x$25.low) >>> 0)), new Go$Uint64(block.high ^ x$21.high, (block.low ^ x$21.low) >>> 0));
		return block;
	};
0ÇxksRotateÇj	var ksRotate = function(in$1) {
		var out, last, i, y, left, y$1, right, _slice, _index, _slice$1, _index$1;
		out = (go$sliceType(Go$Uint32)).nil;
		out = (go$sliceType(Go$Uint32)).make(16, 0, function() { return 0; });
		last = in$1;
		i = 0;
		while (i < 16) {
			left = (((y = ((4 + ksRotations[i] << 24 >>> 24)), y < 32 ? (last << y) : 0) >>> 0)) >>> 4 >>> 0;
			right = (y$1 = ((32 - ksRotations[i] << 24 >>> 24)), y$1 < 32 ? (((last << 4 >>> 0)) >>> y$1) : 0) >>> 0;
			_slice = out, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (left | right) >>> 0) : go$throwRuntimeError("index out of range");
			last = (_slice$1 = out, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			i = i + 1 >> 0;
		}
		return out;
	};
0Ç’generateSubkeysÇ¿	desCipher.Ptr.prototype.generateSubkeys = function(keyBytes) {
		var c, key, permutedKey, leftRotations, rightRotations, i, x, _slice, _index, x$1, _slice$1, _index$1, pc2Input;
		c = this;
		key = binary.BigEndian.Uint64(keyBytes);
		permutedKey = permuteBlock(key, new (go$sliceType(Go$Uint8))(permutedChoice1));
		leftRotations = ksRotate((go$shiftRightUint64(permutedKey, 28).low >>> 0));
		rightRotations = ksRotate((go$shiftLeft64(permutedKey, 4).low >>> 0) >>> 4 >>> 0);
		i = 0;
		while (i < 16) {
			pc2Input = (x = go$shiftLeft64(new Go$Uint64(0, (_slice = leftRotations, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))), 28), x$1 = new Go$Uint64(0, (_slice$1 = rightRotations, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))), new Go$Uint64(x.high | x$1.high, (x.low | x$1.low) >>> 0));
			c.subkeys[i] = permuteBlock(pc2Input, new (go$sliceType(Go$Uint8))(permutedChoice2));
			i = i + 1 >> 0;
		}
	};
	desCipher.prototype.generateSubkeys = function(keyBytes) { return this.go$val.generateSubkeys(keyBytes); };
0ÇErrorÅ¸	KeySizeError.prototype.Error = function() {
		var k;
		k = this.go$val;
		return "crypto/des: invalid key size " + strconv.Itoa((k >> 0));
	};
	go$ptrType(KeySizeError).prototype.Error = function() { return new KeySizeError(this.go$get()).Error(); };
0ÅÚ	NewCipherÅ‰	var NewCipher = go$pkg.NewCipher = function(key) {
		var c;
		if (!((key.length === 8))) {
			return [null, new KeySizeError((key.length >> 0))];
		}
		c = new desCipher.Ptr();
		c.generateSubkeys(key);
		return [c, null];
	};
0Å∂	BlockSizeÅ®	desCipher.Ptr.prototype.BlockSize = function() {
		var c;
		c = this;
		return 8;
	};
	desCipher.prototype.BlockSize = function() { return this.go$val.BlockSize(); };
0Å˛EncryptÅÚ	desCipher.Ptr.prototype.Encrypt = function(dst, src) {
		var c;
		c = this;
		encryptBlock(new (go$sliceType(Go$Uint64))(c.subkeys), dst, src);
	};
	desCipher.prototype.Encrypt = function(dst, src) { return this.go$val.Encrypt(dst, src); };
0Å˛DecryptÅÚ	desCipher.Ptr.prototype.Decrypt = function(dst, src) {
		var c;
		c = this;
		decryptBlock(new (go$sliceType(Go$Uint64))(c.subkeys), dst, src);
	};
	desCipher.prototype.Decrypt = function(dst, src) { return this.go$val.Decrypt(dst, src); };
0ÇôNewTripleDESCipherÇÅ	var NewTripleDESCipher = go$pkg.NewTripleDESCipher = function(key) {
		var c;
		if (!((key.length === 24))) {
			return [null, new KeySizeError((key.length >> 0))];
		}
		c = new tripleDESCipher.Ptr();
		c.cipher1.generateSubkeys(go$subslice(key, 0, 8));
		c.cipher2.generateSubkeys(go$subslice(key, 8, 16));
		c.cipher3.generateSubkeys(go$subslice(key, 16));
		return [c, null];
	};
0Å¬	BlockSizeÅ¥	tripleDESCipher.Ptr.prototype.BlockSize = function() {
		var c;
		c = this;
		return 8;
	};
	tripleDESCipher.prototype.BlockSize = function() { return this.go$val.BlockSize(); };
0Ç$EncryptÇ	tripleDESCipher.Ptr.prototype.Encrypt = function(dst, src) {
		var c;
		c = this;
		c.cipher1.Encrypt(dst, src);
		c.cipher2.Decrypt(dst, dst);
		c.cipher3.Encrypt(dst, dst);
	};
	tripleDESCipher.prototype.Encrypt = function(dst, src) { return this.go$val.Encrypt(dst, src); };
0Ç$DecryptÇ	tripleDESCipher.Ptr.prototype.Decrypt = function(dst, src) {
		var c;
		c = this;
		c.cipher3.Decrypt(dst, src);
		c.cipher2.Encrypt(dst, dst);
		c.cipher1.Decrypt(dst, dst);
	};
	tripleDESCipher.prototype.Decrypt = function(dst, src) { return this.go$val.Decrypt(dst, src); };
0ÇinitÇ		go$pkg.init = function() {
		var _ref, _i, s, i, j, x, x$1, f, x$2;
		initialPermutation = go$toNativeArray("Uint8", [6, 14, 22, 30, 38, 46, 54, 62, 4, 12, 20, 28, 36, 44, 52, 60, 2, 10, 18, 26, 34, 42, 50, 58, 0, 8, 16, 24, 32, 40, 48, 56, 7, 15, 23, 31, 39, 47, 55, 63, 5, 13, 21, 29, 37, 45, 53, 61, 3, 11, 19, 27, 35, 43, 51, 59, 1, 9, 17, 25, 33, 41, 49, 57]);
		finalPermutation = go$toNativeArray("Uint8", [24, 56, 16, 48, 8, 40, 0, 32, 25, 57, 17, 49, 9, 41, 1, 33, 26, 58, 18, 50, 10, 42, 2, 34, 27, 59, 19, 51, 11, 43, 3, 35, 28, 60, 20, 52, 12, 44, 4, 36, 29, 61, 21, 53, 13, 45, 5, 37, 30, 62, 22, 54, 14, 46, 6, 38, 31, 63, 23, 55, 15, 47, 7, 39]);
		expansionFunction = go$toNativeArray("Uint8", [0, 31, 30, 29, 28, 27, 28, 27, 26, 25, 24, 23, 24, 23, 22, 21, 20, 19, 20, 19, 18, 17, 16, 15, 16, 15, 14, 13, 12, 11, 12, 11, 10, 9, 8, 7, 8, 7, 6, 5, 4, 3, 4, 3, 2, 1, 0, 31]);
		permutationFunction = go$toNativeArray("Uint8", [16, 25, 12, 11, 3, 20, 4, 15, 31, 17, 9, 6, 27, 14, 1, 22, 30, 24, 8, 18, 0, 5, 29, 23, 13, 19, 2, 26, 10, 21, 28, 7]);
		permutedChoice1 = go$toNativeArray("Uint8", [7, 15, 23, 31, 39, 47, 55, 63, 6, 14, 22, 30, 38, 46, 54, 62, 5, 13, 21, 29, 37, 45, 53, 61, 4, 12, 20, 28, 1, 9, 17, 25, 33, 41, 49, 57, 2, 10, 18, 26, 34, 42, 50, 58, 3, 11, 19, 27, 35, 43, 51, 59, 36, 44, 52, 60]);
		permutedChoice2 = go$toNativeArray("Uint8", [42, 39, 45, 32, 55, 51, 53, 28, 41, 50, 35, 46, 33, 37, 44, 52, 30, 48, 40, 49, 29, 36, 43, 54, 15, 4, 25, 19, 9, 1, 26, 16, 5, 11, 23, 8, 12, 7, 17, 0, 22, 3, 10, 14, 6, 20, 27, 24]);
		sBoxes = go$toNativeArray("Array", [go$toNativeArray("Array", [go$toNativeArray("Uint8", [14, 4, 13, 1, 2, 15, 11, 8, 3, 10, 6, 12, 5, 9, 0, 7]), go$toNativeArray("Uint8", [0, 15, 7, 4, 14, 2, 13, 1, 10, 6, 12, 11, 9, 5, 3, 8]), go$toNativeArray("Uint8", [4, 1, 14, 8, 13, 6, 2, 11, 15, 12, 9, 7, 3, 10, 5, 0]), go$toNativeArray("Uint8", [15, 12, 8, 2, 4, 9, 1, 7, 5, 11, 3, 14, 10, 0, 6, 13])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [15, 1, 8, 14, 6, 11, 3, 4, 9, 7, 2, 13, 12, 0, 5, 10]), go$toNativeArray("Uint8", [3, 13, 4, 7, 15, 2, 8, 14, 12, 0, 1, 10, 6, 9, 11, 5]), go$toNativeArray("Uint8", [0, 14, 7, 11, 10, 4, 13, 1, 5, 8, 12, 6, 9, 3, 2, 15]), go$toNativeArray("Uint8", [13, 8, 10, 1, 3, 15, 4, 2, 11, 6, 7, 12, 0, 5, 14, 9])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [10, 0, 9, 14, 6, 3, 15, 5, 1, 13, 12, 7, 11, 4, 2, 8]), go$toNativeArray("Uint8", [13, 7, 0, 9, 3, 4, 6, 10, 2, 8, 5, 14, 12, 11, 15, 1]), go$toNativeArray("Uint8", [13, 6, 4, 9, 8, 15, 3, 0, 11, 1, 2, 12, 5, 10, 14, 7]), go$toNativeArray("Uint8", [1, 10, 13, 0, 6, 9, 8, 7, 4, 15, 14, 3, 11, 5, 2, 12])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [7, 13, 14, 3, 0, 6, 9, 10, 1, 2, 8, 5, 11, 12, 4, 15]), go$toNativeArray("Uint8", [13, 8, 11, 5, 6, 15, 0, 3, 4, 7, 2, 12, 1, 10, 14, 9]), go$toNativeArray("Uint8", [10, 6, 9, 0, 12, 11, 7, 13, 15, 1, 3, 14, 5, 2, 8, 4]), go$toNativeArray("Uint8", [3, 15, 0, 6, 10, 1, 13, 8, 9, 4, 5, 11, 12, 7, 2, 14])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [2, 12, 4, 1, 7, 10, 11, 6, 8, 5, 3, 15, 13, 0, 14, 9]), go$toNativeArray("Uint8", [14, 11, 2, 12, 4, 7, 13, 1, 5, 0, 15, 10, 3, 9, 8, 6]), go$toNativeArray("Uint8", [4, 2, 1, 11, 10, 13, 7, 8, 15, 9, 12, 5, 6, 3, 0, 14]), go$toNativeArray("Uint8", [11, 8, 12, 7, 1, 14, 2, 13, 6, 15, 0, 9, 10, 4, 5, 3])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [12, 1, 10, 15, 9, 2, 6, 8, 0, 13, 3, 4, 14, 7, 5, 11]), go$toNativeArray("Uint8", [10, 15, 4, 2, 7, 12, 9, 5, 6, 1, 13, 14, 0, 11, 3, 8]), go$toNativeArray("Uint8", [9, 14, 15, 5, 2, 8, 12, 3, 7, 0, 4, 10, 1, 13, 11, 6]), go$toNativeArray("Uint8", [4, 3, 2, 12, 9, 5, 15, 10, 11, 14, 1, 7, 6, 0, 8, 13])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [4, 11, 2, 14, 15, 0, 8, 13, 3, 12, 9, 7, 5, 10, 6, 1]), go$toNativeArray("Uint8", [13, 0, 11, 7, 4, 9, 1, 10, 14, 3, 5, 12, 2, 15, 8, 6]), go$toNativeArray("Uint8", [1, 4, 11, 13, 12, 3, 7, 14, 10, 15, 6, 8, 0, 5, 9, 2]), go$toNativeArray("Uint8", [6, 11, 13, 8, 1, 4, 10, 7, 9, 5, 0, 15, 14, 2, 3, 12])]), go$toNativeArray("Array", [go$toNativeArray("Uint8", [13, 2, 8, 4, 6, 15, 11, 1, 10, 9, 3, 14, 5, 0, 12, 7]), go$toNativeArray("Uint8", [1, 15, 13, 8, 10, 3, 7, 4, 12, 5, 6, 11, 0, 14, 9, 2]), go$toNativeArray("Uint8", [7, 11, 4, 1, 9, 12, 14, 2, 0, 6, 10, 13, 15, 3, 5, 8]), go$toNativeArray("Uint8", [2, 1, 14, 7, 4, 10, 8, 13, 15, 12, 9, 0, 3, 5, 6, 11])])]);
		ksRotations = go$toNativeArray("Uint8", [1, 1, 2, 2, 2, 2, 2, 2, 1, 2, 2, 2, 2, 2, 2, 1]);
		_ref = sBoxes;
		_i = 0;
		for (; _i < 8; _i += 1) {
			s = _i;
			i = 0;
			while (i < 4) {
				j = 0;
				while (j < 16) {
					f = go$shiftLeft64(new Go$Uint64(0, sBoxes[s][i][j]), ((x = 4, x$1 = (7 - (s >>> 0) >>> 0), (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0)));
					f = permuteBlock(f, new (go$sliceType(Go$Uint8))(permutationFunction));
					feistelBox[s][(x$2 = 16, (((x$2 >>> 16 << 16) * i >> 0) + (x$2 << 16 >>> 16) * i) >> 0) + j >> 0] = (f.low >>> 0);
					j = j + 1 >> 0;
				}
				i = i + 1 >> 0;
			}
		}
	};
