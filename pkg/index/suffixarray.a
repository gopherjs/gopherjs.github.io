0ÇáÔÇ'¯package suffixarray
import sort "sort"
import bytes "bytes"
import binary "encoding/binary"
import io "io"
import regexp "regexp"
type @"".Index struct { @"".data []byte; @"".sa []int }
func (? *@"".Index) @"".Bytes() (? []byte)
func (? *@"".Index) @"".FindAllIndex(@"".r *@"regexp".Regexp, @"".n int) (@"".result [][]int)
func (? *@"".Index) @"".Lookup(@"".s []byte, @"".n int) (@"".result []int)
func (? *@"".Index) @"".Read(@"".r @"io".Reader) (? error)
func (? *@"".Index) @"".Write(@"".w @"io".Writer) (? error)
func (? *@"".Index) @"".at(@"".i int) (? []byte)
func (? *@"".Index) @"".lookupAll(@"".s []byte) (? []int)
func @"".New(@"".data []byte) (? *@"".Index)
type @"".suffixSortable struct { @"".sa []int; @"".inv []int; @"".h int; @"".buf []int }
func (? *@"".suffixSortable) @"".Len() (? int)
func (? *@"".suffixSortable) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".suffixSortable) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".suffixSortable) @"".updateGroups(@"".offset int) ()
import syntax "regexp/syntax"
import sync "sync"
type @"regexp".Regexp struct { @"regexp".expr string; @"regexp".prog *@"regexp/syntax".Prog; @"regexp".prefix string; @"regexp".prefixBytes []byte; @"regexp".prefixComplete bool; @"regexp".prefixRune rune; @"regexp".cond @"regexp/syntax".EmptyOp; @"regexp".numSubexp int; @"regexp".subexpNames []string; @"regexp".longest bool; @"regexp".mu @"sync".Mutex; @"regexp".machine []*@"regexp".machine }
func (? *@"regexp".Regexp) @"regexp".Expand(@"".dst []byte, @"".template []byte, @"".src []byte, @"".match []int) (? []byte)
func (? *@"regexp".Regexp) @"regexp".ExpandString(@"".dst []byte, @"".template string, @"".src string, @"".match []int) (? []byte)
func (? *@"regexp".Regexp) @"regexp".Find(@"".b []byte) (? []byte)
func (? *@"regexp".Regexp) @"regexp".FindAll(@"".b []byte, @"".n int) (? [][]byte)
func (? *@"regexp".Regexp) @"regexp".FindAllIndex(@"".b []byte, @"".n int) (? [][]int)
func (? *@"regexp".Regexp) @"regexp".FindAllString(@"".s string, @"".n int) (? []string)
func (? *@"regexp".Regexp) @"regexp".FindAllStringIndex(@"".s string, @"".n int) (? [][]int)
func (? *@"regexp".Regexp) @"regexp".FindAllStringSubmatch(@"".s string, @"".n int) (? [][]string)
func (? *@"regexp".Regexp) @"regexp".FindAllStringSubmatchIndex(@"".s string, @"".n int) (? [][]int)
func (? *@"regexp".Regexp) @"regexp".FindAllSubmatch(@"".b []byte, @"".n int) (? [][][]byte)
func (? *@"regexp".Regexp) @"regexp".FindAllSubmatchIndex(@"".b []byte, @"".n int) (? [][]int)
func (? *@"regexp".Regexp) @"regexp".FindIndex(@"".b []byte) (@"".loc []int)
func (? *@"regexp".Regexp) @"regexp".FindReaderIndex(@"".r @"io".RuneReader) (@"".loc []int)
func (? *@"regexp".Regexp) @"regexp".FindReaderSubmatchIndex(@"".r @"io".RuneReader) (? []int)
func (? *@"regexp".Regexp) @"regexp".FindString(@"".s string) (? string)
func (? *@"regexp".Regexp) @"regexp".FindStringIndex(@"".s string) (@"".loc []int)
func (? *@"regexp".Regexp) @"regexp".FindStringSubmatch(@"".s string) (? []string)
func (? *@"regexp".Regexp) @"regexp".FindStringSubmatchIndex(@"".s string) (? []int)
func (? *@"regexp".Regexp) @"regexp".FindSubmatch(@"".b []byte) (? [][]byte)
func (? *@"regexp".Regexp) @"regexp".FindSubmatchIndex(@"".b []byte) (? []int)
func (? *@"regexp".Regexp) @"regexp".LiteralPrefix() (@"".prefix string, @"".complete bool)
func (? *@"regexp".Regexp) @"regexp".Longest() ()
func (? *@"regexp".Regexp) @"regexp".Match(@"".b []byte) (? bool)
func (? *@"regexp".Regexp) @"regexp".MatchReader(@"".r @"io".RuneReader) (? bool)
func (? *@"regexp".Regexp) @"regexp".MatchString(@"".s string) (? bool)
func (? *@"regexp".Regexp) @"regexp".NumSubexp() (? int)
func (? *@"regexp".Regexp) @"regexp".ReplaceAll(@"".src []byte, @"".repl []byte) (? []byte)
func (? *@"regexp".Regexp) @"regexp".ReplaceAllFunc(@"".src []byte, @"".repl func (? []byte) (? []byte)) (? []byte)
func (? *@"regexp".Regexp) @"regexp".ReplaceAllLiteral(@"".src []byte, @"".repl []byte) (? []byte)
func (? *@"regexp".Regexp) @"regexp".ReplaceAllLiteralString(@"".src string, @"".repl string) (? string)
func (? *@"regexp".Regexp) @"regexp".ReplaceAllString(@"".src string, @"".repl string) (? string)
func (? *@"regexp".Regexp) @"regexp".ReplaceAllStringFunc(@"".src string, @"".repl func (? string) (? string)) (? string)
func (? *@"regexp".Regexp) @"regexp".Split(@"".s string, @"".n int) (? []string)
func (? *@"regexp".Regexp) @"regexp".String() (? string)
func (? *@"regexp".Regexp) @"regexp".SubexpNames() (? []string)
func (? *@"regexp".Regexp) @"regexp".allMatches(@"".s string, @"".b []byte, @"".n int, @"".deliver func (? []int) ()) ()
func (? *@"regexp".Regexp) @"regexp".doExecute(@"".r @"io".RuneReader, @"".b []byte, @"".s string, @"".pos int, @"".ncap int) (? []int)
func (? *@"regexp".Regexp) @"regexp".expand(@"".dst []byte, @"".template string, @"".bsrc []byte, @"".src string, @"".match []int) (? []byte)
func (? *@"regexp".Regexp) @"regexp".get() (? *@"regexp".machine)
func (? *@"regexp".Regexp) @"regexp".pad(@"".a []int) (? []int)
func (? *@"regexp".Regexp) @"regexp".put(@"".z *@"regexp".machine) ()
func (? *@"regexp".Regexp) @"regexp".replaceAll(@"".bsrc []byte, @"".src string, @"".nmatch int, @"".repl func (@"".dst []byte, @"".m []int) (? []byte)) (? []byte)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
type @"regexp/syntax".Prog struct { @"regexp/syntax".Inst []@"regexp/syntax".Inst; @"regexp/syntax".Start int; @"regexp/syntax".NumCap int }
func (? *@"regexp/syntax".Prog) @"regexp/syntax".Prefix() (@"".prefix string, @"".complete bool)
func (? *@"regexp/syntax".Prog) @"regexp/syntax".StartCond() (? @"regexp/syntax".EmptyOp)
func (? *@"regexp/syntax".Prog) @"regexp/syntax".String() (? string)
func (? *@"regexp/syntax".Prog) @"regexp/syntax".skipNop(@"".pc uint32) (? *@"regexp/syntax".Inst)
type @"regexp/syntax".EmptyOp uint8
type @"sync".Mutex struct { @"sync".state int32; @"sync".sema uint32 }
func (? *@"sync".Mutex) @"sync".Lock() ()
func (? *@"sync".Mutex) @"sync".Unlock() ()
type @"regexp".machine struct { @"regexp".re *@"regexp".Regexp; @"regexp".p *@"regexp/syntax".Prog; @"regexp".q0 @"regexp".queue; @"regexp".q1 @"regexp".queue; @"regexp".pool []*@"regexp".thread; @"regexp".matched bool; @"regexp".matchcap []int; @"regexp".inputBytes @"regexp".inputBytes; @"regexp".inputString @"regexp".inputString; @"regexp".inputReader @"regexp".inputReader }
func (? *@"regexp".machine) @"regexp".add(@"".q *@"regexp".queue, @"".pc uint32, @"".pos int, @"".cap []int, @"".cond @"regexp/syntax".EmptyOp, @"".t *@"regexp".thread) (? *@"regexp".thread)
func (? *@"regexp".machine) @"regexp".alloc(@"".i *@"regexp/syntax".Inst) (? *@"regexp".thread)
func (? *@"regexp".machine) @"regexp".clear(@"".q *@"regexp".queue) ()
func (? *@"regexp".machine) @"regexp".free(@"".t *@"regexp".thread) ()
func (? *@"regexp".machine) @"regexp".init(@"".ncap int) ()
func (? *@"regexp".machine) @"regexp".match(@"".i @"regexp".input, @"".pos int) (? bool)
func (? *@"regexp".machine) @"regexp".newInputBytes(@"".b []byte) (? @"regexp".input)
func (? *@"regexp".machine) @"regexp".newInputReader(@"".r @"io".RuneReader) (? @"regexp".input)
func (? *@"regexp".machine) @"regexp".newInputString(@"".s string) (? @"regexp".input)
func (? *@"regexp".machine) @"regexp".step(@"".runq *@"regexp".queue, @"".nextq *@"regexp".queue, @"".pos int, @"".nextPos int, @"".c rune, @"".nextCond @"regexp/syntax".EmptyOp) ()
type @"io".RuneReader interface { @"io".ReadRune() (@"".r rune, @"".size int, @"".err error) }
type @"regexp/syntax".Inst struct { @"regexp/syntax".Op @"regexp/syntax".InstOp; @"regexp/syntax".Out uint32; @"regexp/syntax".Arg uint32; @"regexp/syntax".Rune []rune }
func (? *@"regexp/syntax".Inst) @"regexp/syntax".MatchEmptyWidth(@"".before rune, @"".after rune) (? bool)
func (? *@"regexp/syntax".Inst) @"regexp/syntax".MatchRune(@"".r rune) (? bool)
func (? *@"regexp/syntax".Inst) @"regexp/syntax".String() (? string)
func (? *@"regexp/syntax".Inst) @"regexp/syntax".op() (? @"regexp/syntax".InstOp)
type @"regexp".queue struct { @"regexp".sparse []uint32; @"regexp".dense []@"regexp".entry }
type @"regexp".thread struct { @"regexp".inst *@"regexp/syntax".Inst; @"regexp".cap []int }
type @"regexp".inputBytes struct { @"regexp".str []byte }
func (? *@"regexp".inputBytes) @"regexp".canCheckPrefix() (? bool)
func (? *@"regexp".inputBytes) @"regexp".context(@"".pos int) (? @"regexp/syntax".EmptyOp)
func (? *@"regexp".inputBytes) @"regexp".hasPrefix(@"".re *@"regexp".Regexp) (? bool)
func (? *@"regexp".inputBytes) @"regexp".index(@"".re *@"regexp".Regexp, @"".pos int) (? int)
func (? *@"regexp".inputBytes) @"regexp".step(@"".pos int) (? rune, ? int)
type @"regexp".inputString struct { @"regexp".str string }
func (? *@"regexp".inputString) @"regexp".canCheckPrefix() (? bool)
func (? *@"regexp".inputString) @"regexp".context(@"".pos int) (? @"regexp/syntax".EmptyOp)
func (? *@"regexp".inputString) @"regexp".hasPrefix(@"".re *@"regexp".Regexp) (? bool)
func (? *@"regexp".inputString) @"regexp".index(@"".re *@"regexp".Regexp, @"".pos int) (? int)
func (? *@"regexp".inputString) @"regexp".step(@"".pos int) (? rune, ? int)
type @"regexp".inputReader struct { @"regexp".r @"io".RuneReader; @"regexp".atEOT bool; @"regexp".pos int }
func (? *@"regexp".inputReader) @"regexp".canCheckPrefix() (? bool)
func (? *@"regexp".inputReader) @"regexp".context(@"".pos int) (? @"regexp/syntax".EmptyOp)
func (? *@"regexp".inputReader) @"regexp".hasPrefix(@"".re *@"regexp".Regexp) (? bool)
func (? *@"regexp".inputReader) @"regexp".index(@"".re *@"regexp".Regexp, @"".pos int) (? int)
func (? *@"regexp".inputReader) @"regexp".step(@"".pos int) (? rune, ? int)
type @"regexp".input interface { @"regexp".canCheckPrefix() (? bool); @"regexp".context(@"".pos int) (? @"regexp/syntax".EmptyOp); @"regexp".hasPrefix(@"".re *@"regexp".Regexp) (? bool); @"regexp".index(@"".re *@"regexp".Regexp, @"".pos int) (? int); @"regexp".step(@"".pos int) (@"".r rune, @"".width int) }
type @"regexp/syntax".InstOp uint8
type @"regexp".entry struct { @"regexp".pc uint32; @"regexp".t *@"regexp".thread }
$$
0Å®runtimeerrorssync/atomicsynciounicodeunicode/utf8bytesmathstrconvreflectencoding/binarysortstringsregexp/syntaxregexpindex/suffixarrayÇ_D	var sort = go$packages["sort"];
	var bytes = go$packages["bytes"];
	var binary = go$packages["encoding/binary"];
	var io = go$packages["io"];
	var regexp = go$packages["regexp"];
	var suffixSortable;
	suffixSortable = go$newType(0, "Struct", "suffixarray.suffixSortable", "suffixSortable", "index/suffixarray", function(sa_, inv_, h_, buf_) {
		this.go$val = this;
		this.sa = sa_ !== undefined ? sa_ : (go$sliceType(Go$Int)).nil;
		this.inv = inv_ !== undefined ? inv_ : (go$sliceType(Go$Int)).nil;
		this.h = h_ !== undefined ? h_ : 0;
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Int)).nil;
	});
	go$pkg.suffixSortable = suffixSortable;
	var Index;
	Index = go$newType(0, "Struct", "suffixarray.Index", "Index", "index/suffixarray", function(data_, sa_) {
		this.go$val = this;
		this.data = data_ !== undefined ? data_ : (go$sliceType(Go$Uint8)).nil;
		this.sa = sa_ !== undefined ? sa_ : (go$sliceType(Go$Int)).nil;
	});
	go$pkg.Index = Index;
	suffixSortable.init([["sa", "index/suffixarray", (go$sliceType(Go$Int)), ""], ["inv", "index/suffixarray", (go$sliceType(Go$Int)), ""], ["h", "index/suffixarray", Go$Int, ""], ["buf", "index/suffixarray", (go$sliceType(Go$Int)), ""]]);
	(go$ptrType(suffixSortable)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false], ["updateGroups", "index/suffixarray", [Go$Int], [], false]];
	Index.init([["data", "index/suffixarray", (go$sliceType(Go$Uint8)), ""], ["sa", "index/suffixarray", (go$sliceType(Go$Int)), ""]]);
	(go$ptrType(Index)).methods = [["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["FindAllIndex", "", [(go$ptrType(regexp.Regexp)), Go$Int], [(go$sliceType((go$sliceType(Go$Int))))], false], ["Lookup", "", [(go$sliceType(Go$Uint8)), Go$Int], [(go$sliceType(Go$Int))], false], ["Read", "", [io.Reader], [go$error], false], ["Write", "", [io.Writer], [go$error], false], ["at", "index/suffixarray", [Go$Int], [(go$sliceType(Go$Uint8))], false], ["lookupAll", "index/suffixarray", [(go$sliceType(Go$Uint8))], [(go$sliceType(Go$Int))], false]];
	var qsufsort = function(data) {
		var sa, inv, sufSortable, _slice, _index, pi, sl, s, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, pk, _slice$4, _index$4, x, x$1, _ref, _i, i, _slice$5, _index$5, _slice$6, _index$6;
		sa = sortedByFirstByte(data);
		if (sa.length < 2) {
			return sa;
		}
		inv = initGroups(sa, data);
		sufSortable = new suffixSortable.Ptr(sa, inv, 1, (go$sliceType(Go$Int)).nil);
		while ((_slice = sa, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) > -sa.length) {
			pi = 0;
			sl = 0;
			while (pi < sa.length) {
				if (s = (_slice$1 = sa, _index$1 = pi, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), s < 0) {
					pi = pi - (s) >> 0;
					sl = sl + (s) >> 0;
				} else {
					if (!((sl === 0))) {
						_slice$2 = sa, _index$2 = pi + sl >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = sl) : go$throwRuntimeError("index out of range");
						sl = 0;
					}
					pk = (_slice$3 = inv, _index$3 = s, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) + 1 >> 0;
					sufSortable.sa = go$subslice(sa, pi, pk);
					sort.Sort(sufSortable);
					sufSortable.updateGroups(pi);
					pi = pk;
				}
			}
			if (!((sl === 0))) {
				_slice$4 = sa, _index$4 = pi + sl >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = sl) : go$throwRuntimeError("index out of range");
			}
			sufSortable.h = (x = sufSortable.h, x$1 = 2, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
		}
		_ref = sa;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i = _i;
			_slice$5 = sa, _index$5 = (_slice$6 = inv, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")), (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = i) : go$throwRuntimeError("index out of range");
		}
		return sa;
	};
	var sortedByFirstByte = function(data) {
		var count, _ref, _i, _slice, _index, b, _lhs, _index$1, sum, _ref$1, _i$1, b$1, _tuple, sa, _ref$2, _i$2, _slice$1, _index$2, b$2, i, _slice$2, _index$3, _lhs$1, _index$4;
		count = go$makeNativeArray("Int", 256, function() { return 0; });
		_ref = data;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_lhs = count, _index$1 = b, _lhs[_index$1] = _lhs[_index$1] + 1 >> 0;
		}
		sum = 0;
		_ref$1 = count;
		_i$1 = 0;
		for (; _i$1 < 256; _i$1 += 1) {
			b$1 = _i$1;
			_tuple = [sum, count[b$1] + sum >> 0], count[b$1] = _tuple[0], sum = _tuple[1];
		}
		sa = (go$sliceType(Go$Int)).make(data.length, 0, function() { return 0; });
		_ref$2 = data;
		_i$2 = 0;
		for (; _i$2 < _ref$2.length; _i$2 += 1) {
			b$2 = (_slice$1 = _ref$2, _index$2 = _i$2, (_index$2 >= 0 && _index$2 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$2] : go$throwRuntimeError("index out of range"));
			i = _i$2;
			_slice$2 = sa, _index$3 = count[b$2], (_index$3 >= 0 && _index$3 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$3] = i) : go$throwRuntimeError("index out of range");
			_lhs$1 = count, _index$4 = b$2, _lhs$1[_index$4] = _lhs$1[_index$4] + 1 >> 0;
		}
		return sa;
	};
	var initGroups = function(sa, data) {
		var inv, prevGroup, _slice, _index, _slice$1, _index$1, groupByte, i, b, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, lastByte, s, _ref, _i, i$1, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, _slice$12, _index$12, _slice$13, _index$13, _slice$14, _index$14, _tuple, _slice$15, _index$15, _slice$16, _index$16, _slice$17, _index$17, _slice$18, _index$18, _slice$19, _index$19;
		inv = (go$sliceType(Go$Int)).make(data.length, 0, function() { return 0; });
		prevGroup = sa.length - 1 >> 0;
		groupByte = (_slice = data, _index = (_slice$1 = sa, _index$1 = prevGroup, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		i = sa.length - 1 >> 0;
		while (i >= 0) {
			if (b = (_slice$2 = data, _index$2 = (_slice$3 = sa, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), b < groupByte) {
				if (prevGroup === (i + 1 >> 0)) {
					_slice$4 = sa, _index$4 = i + 1 >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = -1) : go$throwRuntimeError("index out of range");
				}
				groupByte = b;
				prevGroup = i;
			}
			_slice$5 = inv, _index$5 = (_slice$6 = sa, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")), (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = prevGroup) : go$throwRuntimeError("index out of range");
			if (prevGroup === 0) {
				_slice$7 = sa, _index$7 = 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = -1) : go$throwRuntimeError("index out of range");
			}
			i = i - 1 >> 0;
		}
		lastByte = (_slice$8 = data, _index$8 = (data.length - 1 >> 0), (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range"));
		s = -1;
		_ref = sa;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i$1 = _i;
			if ((_slice$9 = sa, _index$9 = i$1, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")) >= 0) {
				if (((_slice$10 = data, _index$10 = (_slice$11 = sa, _index$11 = i$1, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range")), (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")) === lastByte) && (s === -1)) {
					s = i$1;
				}
				if ((_slice$12 = sa, _index$12 = i$1, (_index$12 >= 0 && _index$12 < _slice$12.length) ? _slice$12.array[_slice$12.offset + _index$12] : go$throwRuntimeError("index out of range")) === (sa.length - 1 >> 0)) {
					_tuple = [(_slice$13 = sa, _index$13 = s, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range")), (_slice$14 = sa, _index$14 = i$1, (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range"))], _slice$15 = sa, _index$15 = i$1, (_index$15 >= 0 && _index$15 < _slice$15.length) ? (_slice$15.array[_slice$15.offset + _index$15] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$16 = sa, _index$16 = s, (_index$16 >= 0 && _index$16 < _slice$16.length) ? (_slice$16.array[_slice$16.offset + _index$16] = _tuple[1]) : go$throwRuntimeError("index out of range");
					_slice$17 = inv, _index$17 = (_slice$18 = sa, _index$18 = s, (_index$18 >= 0 && _index$18 < _slice$18.length) ? _slice$18.array[_slice$18.offset + _index$18] : go$throwRuntimeError("index out of range")), (_index$17 >= 0 && _index$17 < _slice$17.length) ? (_slice$17.array[_slice$17.offset + _index$17] = s) : go$throwRuntimeError("index out of range");
					_slice$19 = sa, _index$19 = s, (_index$19 >= 0 && _index$19 < _slice$19.length) ? (_slice$19.array[_slice$19.offset + _index$19] = -1) : go$throwRuntimeError("index out of range");
					break;
				}
			}
		}
		return inv;
	};
	suffixSortable.Ptr.prototype.Len = function() {
		var x;
		x = this;
		return x.sa.length;
	};
	suffixSortable.prototype.Len = function() { return this.go$val.Len(); };
	suffixSortable.Ptr.prototype.Less = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		return (_slice = x.inv, _index = ((_slice$1 = x.sa, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) + x.h >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) < (_slice$2 = x.inv, _index$2 = ((_slice$3 = x.sa, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) + x.h >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
	};
	suffixSortable.prototype.Less = function(i, j) { return this.go$val.Less(i, j); };
	suffixSortable.Ptr.prototype.Swap = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_slice = x.sa, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = x.sa, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = x.sa, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x.sa, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	suffixSortable.prototype.Swap = function(i, j) { return this.go$val.Swap(i, j); };
	suffixSortable.Ptr.prototype.updateGroups = function(offset) {
		var x, bounds, _slice, _index, _slice$1, _index$1, group, i, g, _slice$2, _index$2, _slice$3, _index$3, prev, _ref, _i, _slice$4, _index$4, b, i$1, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		x = this;
		bounds = go$subslice(x.buf, 0, 0);
		group = (_slice = x.inv, _index = ((_slice$1 = x.sa, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) + x.h >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		i = 1;
		while (i < x.sa.length) {
			if (g = (_slice$2 = x.inv, _index$2 = ((_slice$3 = x.sa, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) + x.h >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), g > group) {
				bounds = go$append(bounds, i);
				group = g;
			}
			i = i + 1 >> 0;
		}
		bounds = go$append(bounds, x.sa.length);
		x.buf = bounds;
		prev = 0;
		_ref = bounds;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			b = (_slice$4 = _ref, _index$4 = _i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
			i$1 = prev;
			while (i$1 < b) {
				_slice$5 = x.inv, _index$5 = (_slice$6 = x.sa, _index$6 = i$1, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")), (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (offset + b >> 0) - 1 >> 0) : go$throwRuntimeError("index out of range");
				i$1 = i$1 + 1 >> 0;
			}
			if ((b - prev >> 0) === 1) {
				_slice$7 = x.sa, _index$7 = prev, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = -1) : go$throwRuntimeError("index out of range");
			}
			prev = b;
		}
	};
	suffixSortable.prototype.updateGroups = function(offset) { return this.go$val.updateGroups(offset); };
	var New = go$pkg.New = function(data) {
		return new Index.Ptr(data, qsufsort(data));
	};
	var writeInt = function(w, buf, x) {
		var _tuple, err;
		binary.PutVarint(buf, new Go$Int64(0, x));
		_tuple = w.Write(go$subslice(buf, 0, 10)), err = _tuple[1];
		return err;
	};
	var readInt = function(r, buf) {
		var _tuple, err, _tuple$1, x;
		_tuple = io.ReadFull(r, go$subslice(buf, 0, 10)), err = _tuple[1];
		_tuple$1 = binary.Varint(buf), x = _tuple$1[0];
		return [((x.low + ((x.high >> 31) * 4294967296)) >> 0), err];
	};
	var writeSlice = function(w, buf, data) {
		var n, err, p, _slice, _index, _tuple;
		n = 0;
		err = null;
		p = 10;
		while (n < data.length && (p + 10 >> 0) <= buf.length) {
			p = p + (binary.PutUvarint(go$subslice(buf, p), new Go$Uint64(0, (_slice = data, _index = n, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))))) >> 0;
			n = n + 1 >> 0;
		}
		binary.PutVarint(buf, new Go$Int64(0, p));
		_tuple = w.Write(go$subslice(buf, 0, p)), err = _tuple[1];
		return [n, err];
	};
	var readSlice = function(r, buf, data) {
		var n, err, size, _tuple, _tuple$1, p, _tuple$2, x, w, _slice, _index;
		n = 0;
		err = null;
		size = 0;
		_tuple = readInt(r, buf), size = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [n, err];
		}
		if (_tuple$1 = io.ReadFull(r, go$subslice(buf, 10, size)), err = _tuple$1[1], !(go$interfaceIsEqual(err, null))) {
			return [n, err];
		}
		p = 10;
		while (p < size) {
			_tuple$2 = binary.Uvarint(go$subslice(buf, p)), x = _tuple$2[0], w = _tuple$2[1];
			_slice = data, _index = n, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (x.low >> 0)) : go$throwRuntimeError("index out of range");
			p = p + (w) >> 0;
			n = n + 1 >> 0;
		}
		return [n, err];
	};
	Index.Ptr.prototype.Read = function(r) {
		var x, buf, _tuple, n, err, x$1, err$1, _tuple$1, sa, _tuple$2, n$1, err$2;
		x = this;
		buf = (go$sliceType(Go$Uint8)).make(16384, 0, function() { return 0; });
		_tuple = readInt(r, buf), n = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		if ((x$1 = 2, (((x$1 >>> 16 << 16) * n >> 0) + (x$1 << 16 >>> 16) * n) >> 0) < x.data.capacity || x.data.capacity < n) {
			x.data = (go$sliceType(Go$Uint8)).make(n, 0, function() { return 0; });
			x.sa = (go$sliceType(Go$Int)).make(n, 0, function() { return 0; });
		} else {
			x.data = go$subslice(x.data, 0, n);
			x.sa = go$subslice(x.sa, 0, n);
		}
		if (_tuple$1 = io.ReadFull(r, x.data), err$1 = _tuple$1[1], !(go$interfaceIsEqual(err$1, null))) {
			return err$1;
		}
		sa = x.sa;
		while (sa.length > 0) {
			_tuple$2 = readSlice(r, buf, sa), n$1 = _tuple$2[0], err$2 = _tuple$2[1];
			if (!(go$interfaceIsEqual(err$2, null))) {
				return err$2;
			}
			sa = go$subslice(sa, n$1);
		}
		return null;
	};
	Index.prototype.Read = function(r) { return this.go$val.Read(r); };
	Index.Ptr.prototype.Write = function(w) {
		var x, buf, err, err$1, _tuple, sa, _tuple$1, n, err$2;
		x = this;
		buf = (go$sliceType(Go$Uint8)).make(16384, 0, function() { return 0; });
		if (err = writeInt(w, buf, x.data.length), !(go$interfaceIsEqual(err, null))) {
			return err;
		}
		if (_tuple = w.Write(x.data), err$1 = _tuple[1], !(go$interfaceIsEqual(err$1, null))) {
			return err$1;
		}
		sa = x.sa;
		while (sa.length > 0) {
			_tuple$1 = writeSlice(w, buf, sa), n = _tuple$1[0], err$2 = _tuple$1[1];
			if (!(go$interfaceIsEqual(err$2, null))) {
				return err$2;
			}
			sa = go$subslice(sa, n);
		}
		return null;
	};
	Index.prototype.Write = function(w) { return this.go$val.Write(w); };
	Index.Ptr.prototype.Bytes = function() {
		var x;
		x = this;
		return x.data;
	};
	Index.prototype.Bytes = function() { return this.go$val.Bytes(); };
	Index.Ptr.prototype.at = function(i) {
		var x, _slice, _index;
		x = this;
		return go$subslice(x.data, (_slice = x.sa, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
	};
	Index.prototype.at = function(i) { return this.go$val.at(i); };
	Index.Ptr.prototype.lookupAll = function(s) {
		var x, i, j;
		x = this;
		i = sort.Search(x.sa.length, (function(i) {
			return bytes.Compare(x.at(i), s) >= 0;
		}));
		j = i + sort.Search(x.sa.length - i >> 0, (function(j) {
			return !bytes.HasPrefix(x.at(j + i >> 0), s);
		})) >> 0;
		return go$subslice(x.sa, i, j);
	};
	Index.prototype.lookupAll = function(s) { return this.go$val.lookupAll(s); };
	Index.Ptr.prototype.Lookup = function(s, n) {
		var result, x, matches;
		result = (go$sliceType(Go$Int)).nil;
		x = this;
		if (s.length > 0 && !((n === 0))) {
			matches = x.lookupAll(s);
			if (n < 0 || matches.length < n) {
				n = matches.length;
			}
			if (n > 0) {
				result = (go$sliceType(Go$Int)).make(n, 0, function() { return 0; });
				go$copySlice(result, matches);
			}
		}
		return result;
	};
	Index.prototype.Lookup = function(s, n) { return this.go$val.Lookup(s, n); };
	Index.Ptr.prototype.FindAllIndex = function(r, n) {
		var result, x, _tuple, prefix, complete, lit, n1, indices, x$1, x$2, pairs, count, prev, _ref, _i, _slice, _index, i, x$3, j, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, x$4, x$5, n1$1, indices$1, prev$1, _ref$1, _i$1, _slice$4, _index$4, i$1, m, _slice$5, _index$5, _lhs, _index$6, _slice$6, _index$7, _slice$7, _index$8, _slice$8, _index$9, x$6, x$7;
		result = (go$sliceType((go$sliceType(Go$Int)))).nil;
		x = this;
		_tuple = r.LiteralPrefix(), prefix = _tuple[0], complete = _tuple[1];
		lit = new (go$sliceType(Go$Uint8))(go$stringToBytes(prefix));
		if (prefix === "") {
			result = r.FindAllIndex(x.data, n);
			return result;
		}
		if (complete) {
			n1 = n;
			while (true) {
				indices = x.Lookup(lit, n1);
				if (indices.length === 0) {
					return result;
				}
				sort.Ints(indices);
				pairs = (go$sliceType(Go$Int)).make((x$1 = 2, x$2 = indices.length, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0), 0, function() { return 0; });
				result = (go$sliceType((go$sliceType(Go$Int)))).make(indices.length, 0, function() { return (go$sliceType(Go$Int)).nil; });
				count = 0;
				prev = 0;
				_ref = indices;
				_i = 0;
				for (; _i < _ref.length; _i += 1) {
					i = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
					if (count === n) {
						break;
					}
					if (prev <= i) {
						j = (x$3 = 2, (((x$3 >>> 16 << 16) * count >> 0) + (x$3 << 16 >>> 16) * count) >> 0);
						_slice$1 = pairs, _index$1 = j + 0 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = i) : go$throwRuntimeError("index out of range");
						_slice$2 = pairs, _index$2 = j + 1 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = i + lit.length >> 0) : go$throwRuntimeError("index out of range");
						_slice$3 = result, _index$3 = count, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = go$subslice(pairs, j, (j + 2 >> 0))) : go$throwRuntimeError("index out of range");
						count = count + 1 >> 0;
						prev = i + lit.length >> 0;
					}
				}
				result = go$subslice(result, 0, count);
				if (result.length >= n || !((indices.length === n1))) {
					break;
				}
				n1 = n1 + ((x$4 = 2, x$5 = (n - result.length >> 0), (((x$4 >>> 16 << 16) * x$5 >> 0) + (x$4 << 16 >>> 16) * x$5) >> 0)) >> 0;
			}
			if (result.length === 0) {
				result = (go$sliceType((go$sliceType(Go$Int)))).nil;
			}
			return result;
		}
		r = regexp.MustCompile("^" + r.String());
		n1$1 = n;
		while (true) {
			indices$1 = x.Lookup(lit, n1$1);
			if (indices$1.length === 0) {
				return result;
			}
			sort.Ints(indices$1);
			result = go$subslice(result, 0, 0);
			prev$1 = 0;
			_ref$1 = indices$1;
			_i$1 = 0;
			for (; _i$1 < _ref$1.length; _i$1 += 1) {
				i$1 = (_slice$4 = _ref$1, _index$4 = _i$1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
				if (result.length === n) {
					break;
				}
				m = r.FindIndex(go$subslice(x.data, i$1));
				if (!(m === (go$sliceType(Go$Int)).nil) && prev$1 <= i$1) {
					_slice$5 = m, _index$5 = 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = i$1) : go$throwRuntimeError("index out of range");
					_lhs = m, _index$6 = 1, _slice$7 = _lhs, _index$8 = _index$6, (_index$8 >= 0 && _index$8 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$8] = (_slice$6 = _lhs, _index$7 = _index$6, (_index$7 >= 0 && _index$7 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$7] : go$throwRuntimeError("index out of range")) + (i$1) >> 0) : go$throwRuntimeError("index out of range");
					result = go$append(result, m);
					prev$1 = (_slice$8 = m, _index$9 = 1, (_index$9 >= 0 && _index$9 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$9] : go$throwRuntimeError("index out of range"));
				}
			}
			if (result.length >= n || !((indices$1.length === n1$1))) {
				break;
			}
			n1$1 = n1$1 + ((x$6 = 2, x$7 = (n - result.length >> 0), (((x$6 >>> 16 << 16) * x$7 >> 0) + (x$6 << 16 >>> 16) * x$7) >> 0)) >> 0;
		}
		if (result.length === 0) {
			result = (go$sliceType((go$sliceType(Go$Int)))).nil;
		}
		return result;
	};
	Index.prototype.FindAllIndex = function(r, n) { return this.go$val.FindAllIndex(r, n); };
	var bufSize = 16384;
	go$pkg.init = function() {
	};
