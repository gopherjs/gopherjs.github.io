0ÉV6encoding/jsonÇfpackage json
import encoding "encoding"
import base64 "encoding/base64"
import errors "errors"
import fmt "fmt"
import reflect "reflect"
import runtime "runtime"
import strconv "strconv"
import strings "strings"
import unicode "unicode"
import utf16 "unicode/utf16"
import utf8 "unicode/utf8"
import bytes "bytes"
import math "math"
import sort "sort"
import sync "sync"
import io "io"
func @"".Compact(@"".dst *@"bytes".Buffer, @"".src []byte) (? error)
type @"".Decoder struct { @"".r @"io".Reader; @"".buf []byte; @"".d @"".decodeState; @"".scan @"".scanner; @"".err error }
func (? *@"".Decoder) @"".Buffered() (? @"io".Reader)
func (? *@"".Decoder) @"".Decode(@"".v interface {  }) (? error)
func (? *@"".Decoder) @"".UseNumber() ()
func (? *@"".Decoder) @"".readValue() (? int, ? error)
type @"".Encoder struct { @"".w @"io".Writer; @"".e @"".encodeState; @"".err error }
func (? *@"".Encoder) @"".Encode(@"".v interface {  }) (? error)
func @"".HTMLEscape(@"".dst *@"bytes".Buffer, @"".src []byte) ()
func @"".Indent(@"".dst *@"bytes".Buffer, @"".src []byte, @"".prefix string, @"".indent string) (? error)
type @"".InvalidUTF8Error struct { @"".S string }
func (? *@"".InvalidUTF8Error) @"".Error() (? string)
type @"".InvalidUnmarshalError struct { @"".Type @"reflect".Type }
func (? *@"".InvalidUnmarshalError) @"".Error() (? string)
func @"".Marshal(@"".v interface {  }) (? []byte, ? error)
func @"".MarshalIndent(@"".v interface {  }, @"".prefix string, @"".indent string) (? []byte, ? error)
type @"".Marshaler interface { @"".MarshalJSON() (? []byte, ? error) }
type @"".MarshalerError struct { @"".Type @"reflect".Type; @"".Err error }
func (? *@"".MarshalerError) @"".Error() (? string)
func @"".NewDecoder(@"".r @"io".Reader) (? *@"".Decoder)
func @"".NewEncoder(@"".w @"io".Writer) (? *@"".Encoder)
type @"".Number string
func (? @"".Number) @"".Float64() (? float64, ? error)
func (? @"".Number) @"".Int64() (? int64, ? error)
func (? @"".Number) @"".String() (? string)
func (? *@"".Number) @"".Float64() (? float64, ? error)
func (? *@"".Number) @"".Int64() (? int64, ? error)
func (? *@"".Number) @"".String() (? string)
type @"".RawMessage []byte
func (? *@"".RawMessage) @"".MarshalJSON() (? []byte, ? error)
func (? *@"".RawMessage) @"".UnmarshalJSON(@"".data []byte) (? error)
type @"".SyntaxError struct { @"".msg string; @"".Offset int64 }
func (? *@"".SyntaxError) @"".Error() (? string)
func @"".Unmarshal(@"".data []byte, @"".v interface {  }) (? error)
type @"".UnmarshalFieldError struct { @"".Key string; @"".Type @"reflect".Type; @"".Field @"reflect".StructField }
func (? *@"".UnmarshalFieldError) @"".Error() (? string)
type @"".UnmarshalTypeError struct { @"".Value string; @"".Type @"reflect".Type }
func (? *@"".UnmarshalTypeError) @"".Error() (? string)
type @"".Unmarshaler interface { @"".UnmarshalJSON(? []byte) (? error) }
type @"".UnsupportedTypeError struct { @"".Type @"reflect".Type }
func (? *@"".UnsupportedTypeError) @"".Error() (? string)
type @"".UnsupportedValueError struct { @"".Value @"reflect".Value; @"".Str string }
func (? *@"".UnsupportedValueError) @"".Error() (? string)
type @"".arrayEncoder struct { @"".elemEnc @"".encoderFunc }
func (? *@"".arrayEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, _ bool) ()
type @"".byIndex []@"".field
func (? @"".byIndex) @"".Len() (? int)
func (? @"".byIndex) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byIndex) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byIndex) @"".Len() (? int)
func (? *@"".byIndex) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byIndex) @"".Swap(@"".i int, @"".j int) ()
type @"".byName []@"".field
func (? @"".byName) @"".Len() (? int)
func (? @"".byName) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byName) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byName) @"".Len() (? int)
func (? *@"".byName) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byName) @"".Swap(@"".i int, @"".j int) ()
type @"".condAddrEncoder struct { @"".canAddrEnc @"".encoderFunc; @"".elseEnc @"".encoderFunc }
func (? *@"".condAddrEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, @"".quoted bool) ()
type @"".decodeState struct { @"".data []byte; @"".off int; @"".scan @"".scanner; @"".nextscan @"".scanner; @"".savedError error; @"".tempstr string; @"".useNumber bool }
func (? *@"".decodeState) @"".array(@"".v @"reflect".Value) ()
func (? *@"".decodeState) @"".arrayInterface() (? []interface {  })
func (? *@"".decodeState) @"".convertNumber(@"".s string) (? interface {  }, ? error)
func (? *@"".decodeState) @"".error(@"".err error) ()
func (? *@"".decodeState) @"".indirect(@"".v @"reflect".Value, @"".decodingNull bool) (? @"".Unmarshaler, ? @"encoding".TextUnmarshaler, ? @"reflect".Value)
func (? *@"".decodeState) @"".init(@"".data []byte) (? *@"".decodeState)
func (? *@"".decodeState) @"".literal(@"".v @"reflect".Value) ()
func (? *@"".decodeState) @"".literalInterface() (? interface {  })
func (? *@"".decodeState) @"".literalStore(@"".item []byte, @"".v @"reflect".Value, @"".fromQuoted bool) ()
func (? *@"".decodeState) @"".next() (? []byte)
func (? *@"".decodeState) @"".object(@"".v @"reflect".Value) ()
func (? *@"".decodeState) @"".objectInterface() (? map[string]interface {  })
func (? *@"".decodeState) @"".saveError(@"".err error) ()
func (? *@"".decodeState) @"".scanWhile(@"".op int) (? int)
func (? *@"".decodeState) @"".unmarshal(@"".v interface {  }) (@"".err error)
func (? *@"".decodeState) @"".value(@"".v @"reflect".Value) ()
func (? *@"".decodeState) @"".valueInterface() (? interface {  })
type @"".encodeState struct { ? @"bytes".Buffer; @"".scratch [64]byte }
func (? *@"".encodeState) @"".error(@"".err error) ()
func (? *@"".encodeState) @"".marshal(@"".v interface {  }) (@"".err error)
func (? *@"".encodeState) @"".reflectValue(@"".v @"reflect".Value) ()
func (? *@"".encodeState) @"".string(@"".s string) (? int, ? error)
func (? *@"".encodeState) @"".stringBytes(@"".s []byte) (? int, ? error)
type @"".encoderFunc func (@"".e *@"".encodeState, @"".v @"reflect".Value, @"".quoted bool) ()
type @"".field struct { @"".name string; @"".tag bool; @"".index []int; @"".typ @"reflect".Type; @"".omitEmpty bool; @"".quoted bool }
type @"".floatEncoder int
func (? @"".floatEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, @"".quoted bool) ()
func (? *@"".floatEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, @"".quoted bool) ()
type @"".mapEncoder struct { @"".elemEnc @"".encoderFunc }
func (? *@"".mapEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, _ bool) ()
type @"".ptrEncoder struct { @"".elemEnc @"".encoderFunc }
func (? *@"".ptrEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, _ bool) ()
type @"".scanner struct { @"".step func (? *@"".scanner, ? int) (? int); @"".endTop bool; @"".parseState []int; @"".err error; @"".redo bool; @"".redoCode int; @"".redoState func (? *@"".scanner, ? int) (? int); @"".bytes int64 }
func (? *@"".scanner) @"".eof() (? int)
func (? *@"".scanner) @"".error(@"".c int, @"".context string) (? int)
func (? *@"".scanner) @"".popParseState() ()
func (? *@"".scanner) @"".pushParseState(@"".p int) ()
func (? *@"".scanner) @"".reset() ()
func (? *@"".scanner) @"".undo(@"".scanCode int) ()
type @"".sliceEncoder struct { @"".arrayEnc @"".encoderFunc }
func (? *@"".sliceEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, _ bool) ()
type @"".stringValues []@"reflect".Value
func (? @"".stringValues) @"".Len() (? int)
func (? @"".stringValues) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".stringValues) @"".Swap(@"".i int, @"".j int) ()
func (? @"".stringValues) @"".get(@"".i int) (? string)
func (? *@"".stringValues) @"".Len() (? int)
func (? *@"".stringValues) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".stringValues) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".stringValues) @"".get(@"".i int) (? string)
type @"".structEncoder struct { @"".fields []@"".field; @"".fieldEncs []@"".encoderFunc }
func (? *@"".structEncoder) @"".encode(@"".e *@"".encodeState, @"".v @"reflect".Value, @"".quoted bool) ()
type @"".tagOptions string
func (? @"".tagOptions) @"".Contains(@"".optionName string) (? bool)
func (? *@"".tagOptions) @"".Contains(@"".optionName string) (? bool)
type @"bytes".Buffer struct { @"bytes".buf []byte; @"bytes".off int; @"bytes".runeBytes [4]byte; @"bytes".bootstrap [64]byte; @"bytes".lastRead @"bytes".readOp }
func (? *@"bytes".Buffer) @"bytes".Bytes() (? []byte)
func (? *@"bytes".Buffer) @"bytes".Grow(@"".n int) ()
func (? *@"bytes".Buffer) @"bytes".Len() (? int)
func (? *@"bytes".Buffer) @"bytes".Next(@"".n int) (? []byte)
func (? *@"bytes".Buffer) @"bytes".Read(@"".p []byte) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadByte() (@"".c byte, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadBytes(@"".delim byte) (@"".line []byte, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadFrom(@"".r @"io".Reader) (@"".n int64, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadRune() (@"".r rune, @"".size int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".ReadString(@"".delim byte) (@"".line string, @"".err error)
func (? *@"bytes".Buffer) @"bytes".Reset() ()
func (? *@"bytes".Buffer) @"bytes".String() (? string)
func (? *@"bytes".Buffer) @"bytes".Truncate(@"".n int) ()
func (? *@"bytes".Buffer) @"bytes".UnreadByte() (? error)
func (? *@"bytes".Buffer) @"bytes".UnreadRune() (? error)
func (? *@"bytes".Buffer) @"bytes".Write(@"".p []byte) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteByte(@"".c byte) (? error)
func (? *@"bytes".Buffer) @"bytes".WriteRune(@"".r rune) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteString(@"".s string) (@"".n int, @"".err error)
func (? *@"bytes".Buffer) @"bytes".WriteTo(@"".w @"io".Writer) (@"".n int64, @"".err error)
func (? *@"bytes".Buffer) @"bytes".grow(@"".n int) (? int)
func (? *@"bytes".Buffer) @"bytes".readSlice(@"".delim byte) (@"".line []byte, @"".err error)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
type @"reflect".Type interface { @"reflect".Align() (? int); @"reflect".AssignableTo(@"".u @"reflect".Type) (? bool); @"reflect".Bits() (? int); @"reflect".ChanDir() (? @"reflect".ChanDir); @"reflect".ConvertibleTo(@"".u @"reflect".Type) (? bool); @"reflect".Elem() (? @"reflect".Type); @"reflect".Field(@"".i int) (? @"reflect".StructField); @"reflect".FieldAlign() (? int); @"reflect".FieldByIndex(@"".index []int) (? @"reflect".StructField); @"reflect".FieldByName(@"".name string) (? @"reflect".StructField, ? bool); @"reflect".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"reflect".StructField, ? bool); @"reflect".Implements(@"".u @"reflect".Type) (? bool); @"reflect".In(@"".i int) (? @"reflect".Type); @"reflect".IsVariadic() (? bool); @"reflect".Key() (? @"reflect".Type); @"reflect".Kind() (? @"reflect".Kind); @"reflect".Len() (? int); @"reflect".Method(? int) (? @"reflect".Method); @"reflect".MethodByName(? string) (? @"reflect".Method, ? bool); @"reflect".Name() (? string); @"reflect".NumField() (? int); @"reflect".NumIn() (? int); @"reflect".NumMethod() (? int); @"reflect".NumOut() (? int); @"reflect".Out(@"".i int) (? @"reflect".Type); @"reflect".PkgPath() (? string); @"reflect".Size() (? uintptr); @"reflect".String() (? string); @"reflect".common() (? *@"reflect".rtype); @"reflect".uncommon() (? *@"reflect".uncommonType) }
type @"reflect".StructField struct { @"reflect".Name string; @"reflect".PkgPath string; @"reflect".Type @"reflect".Type; @"reflect".Tag @"reflect".StructTag; @"reflect".Offset uintptr; @"reflect".Index []int; @"reflect".Anonymous bool }
type @"reflect".Value struct { @"reflect".typ *@"reflect".rtype; @"reflect".val @"unsafe".Pointer; ? @"reflect".flag }
func (? @"reflect".Value) @"reflect".Addr() (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Bool() (? bool)
func (? @"reflect".Value) @"reflect".Bytes() (? []byte)
func (? @"reflect".Value) @"reflect".Call(@"".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".CallSlice(@"".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".CanAddr() (? bool)
func (? @"reflect".Value) @"reflect".CanInterface() (? bool)
func (? @"reflect".Value) @"reflect".CanSet() (? bool)
func (? @"reflect".Value) @"reflect".Cap() (? int)
func (? @"reflect".Value) @"reflect".Close() ()
func (? @"reflect".Value) @"reflect".Complex() (? complex128)
func (? @"reflect".Value) @"reflect".Convert(@"".t @"reflect".Type) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Elem() (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Field(@"".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByIndex(@"".index []int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByName(@"".name string) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Float() (? float64)
func (? @"reflect".Value) @"reflect".Index(@"".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Int() (? int64)
func (? @"reflect".Value) @"reflect".Interface() (@"".i interface {  })
func (? @"reflect".Value) @"reflect".InterfaceData() (? [2]uintptr)
func (? @"reflect".Value) @"reflect".IsNil() (? bool)
func (? @"reflect".Value) @"reflect".IsValid() (? bool)
func (? @"reflect".Value) @"reflect".Kind() (? @"reflect".Kind)
func (? @"reflect".Value) @"reflect".Len() (? int)
func (? @"reflect".Value) @"reflect".MapIndex(@"".key @"reflect".Value) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".MapKeys() (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".Method(@"".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".MethodByName(@"".name string) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".NumField() (? int)
func (? @"reflect".Value) @"reflect".NumMethod() (? int)
func (? @"reflect".Value) @"reflect".OverflowComplex(@"".x complex128) (? bool)
func (? @"reflect".Value) @"reflect".OverflowFloat(@"".x float64) (? bool)
func (? @"reflect".Value) @"reflect".OverflowInt(@"".x int64) (? bool)
func (? @"reflect".Value) @"reflect".OverflowUint(@"".x uint64) (? bool)
func (? @"reflect".Value) @"reflect".Pointer() (? uintptr)
func (? @"reflect".Value) @"reflect".Recv() (@"".x @"reflect".Value, @"".ok bool)
func (? @"reflect".Value) @"reflect".Send(@"".x @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".Set(@"".x @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".SetBool(@"".x bool) ()
func (? @"reflect".Value) @"reflect".SetBytes(@"".x []byte) ()
func (? @"reflect".Value) @"reflect".SetCap(@"".n int) ()
func (? @"reflect".Value) @"reflect".SetComplex(@"".x complex128) ()
func (? @"reflect".Value) @"reflect".SetFloat(@"".x float64) ()
func (? @"reflect".Value) @"reflect".SetInt(@"".x int64) ()
func (? @"reflect".Value) @"reflect".SetLen(@"".n int) ()
func (? @"reflect".Value) @"reflect".SetMapIndex(@"".key @"reflect".Value, @"".val @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".SetPointer(@"".x @"unsafe".Pointer) ()
func (? @"reflect".Value) @"reflect".SetString(@"".x string) ()
func (? @"reflect".Value) @"reflect".SetUint(@"".x uint64) ()
func (? @"reflect".Value) @"reflect".Slice(@"".i int, @"".j int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Slice3(@"".i int, @"".j int, @"".k int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".String() (? string)
func (? @"reflect".Value) @"reflect".TryRecv() (@"".x @"reflect".Value, @"".ok bool)
func (? @"reflect".Value) @"reflect".TrySend(@"".x @"reflect".Value) (? bool)
func (? @"reflect".Value) @"reflect".Type() (? @"reflect".Type)
func (? @"reflect".Value) @"reflect".Uint() (? uint64)
func (? @"reflect".Value) @"reflect".UnsafeAddr() (? uintptr)
func (? @"reflect".Value) @"reflect".assignTo(@"".context string, @"".dst *@"reflect".rtype, @"".target *interface {  }) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".call(@"".op string, @"".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".iword() (? @"reflect".iword)
func (? @"reflect".Value) @"reflect".recv(@"".nb bool) (@"".val @"reflect".Value, @"".ok bool)
func (? @"reflect".Value) @"reflect".runes() (? []rune)
func (? @"reflect".Value) @"reflect".send(@"".x @"reflect".Value, @"".nb bool) (@"".selected bool)
func (? @"reflect".Value) @"reflect".setRunes(@"".x []rune) ()
func (? *@"reflect".Value) @"reflect".Addr() (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Bool() (? bool)
func (? *@"reflect".Value) @"reflect".Bytes() (? []byte)
func (? *@"reflect".Value) @"reflect".Call(@"".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".CallSlice(@"".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".CanAddr() (? bool)
func (? *@"reflect".Value) @"reflect".CanInterface() (? bool)
func (? *@"reflect".Value) @"reflect".CanSet() (? bool)
func (? *@"reflect".Value) @"reflect".Cap() (? int)
func (? *@"reflect".Value) @"reflect".Close() ()
func (? *@"reflect".Value) @"reflect".Complex() (? complex128)
func (? *@"reflect".Value) @"reflect".Convert(@"".t @"reflect".Type) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Elem() (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Field(@"".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByIndex(@"".index []int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByName(@"".name string) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Float() (? float64)
func (? *@"reflect".Value) @"reflect".Index(@"".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Int() (? int64)
func (? *@"reflect".Value) @"reflect".Interface() (@"".i interface {  })
func (? *@"reflect".Value) @"reflect".InterfaceData() (? [2]uintptr)
func (? *@"reflect".Value) @"reflect".IsNil() (? bool)
func (? *@"reflect".Value) @"reflect".IsValid() (? bool)
func (? *@"reflect".Value) @"reflect".Kind() (? @"reflect".Kind)
func (? *@"reflect".Value) @"reflect".Len() (? int)
func (? *@"reflect".Value) @"reflect".MapIndex(@"".key @"reflect".Value) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".MapKeys() (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".Method(@"".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".MethodByName(@"".name string) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".NumField() (? int)
func (? *@"reflect".Value) @"reflect".NumMethod() (? int)
func (? *@"reflect".Value) @"reflect".OverflowComplex(@"".x complex128) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowFloat(@"".x float64) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowInt(@"".x int64) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowUint(@"".x uint64) (? bool)
func (? *@"reflect".Value) @"reflect".Pointer() (? uintptr)
func (? *@"reflect".Value) @"reflect".Recv() (@"".x @"reflect".Value, @"".ok bool)
func (? *@"reflect".Value) @"reflect".Send(@"".x @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".Set(@"".x @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".SetBool(@"".x bool) ()
func (? *@"reflect".Value) @"reflect".SetBytes(@"".x []byte) ()
func (? *@"reflect".Value) @"reflect".SetCap(@"".n int) ()
func (? *@"reflect".Value) @"reflect".SetComplex(@"".x complex128) ()
func (? *@"reflect".Value) @"reflect".SetFloat(@"".x float64) ()
func (? *@"reflect".Value) @"reflect".SetInt(@"".x int64) ()
func (? *@"reflect".Value) @"reflect".SetLen(@"".n int) ()
func (? *@"reflect".Value) @"reflect".SetMapIndex(@"".key @"reflect".Value, @"".val @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".SetPointer(@"".x @"unsafe".Pointer) ()
func (? *@"reflect".Value) @"reflect".SetString(@"".x string) ()
func (? *@"reflect".Value) @"reflect".SetUint(@"".x uint64) ()
func (? *@"reflect".Value) @"reflect".Slice(@"".i int, @"".j int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Slice3(@"".i int, @"".j int, @"".k int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".String() (? string)
func (? *@"reflect".Value) @"reflect".TryRecv() (@"".x @"reflect".Value, @"".ok bool)
func (? *@"reflect".Value) @"reflect".TrySend(@"".x @"reflect".Value) (? bool)
func (? *@"reflect".Value) @"reflect".Type() (? @"reflect".Type)
func (? *@"reflect".Value) @"reflect".Uint() (? uint64)
func (? *@"reflect".Value) @"reflect".UnsafeAddr() (? uintptr)
func (? *@"reflect".Value) @"reflect".assignTo(@"".context string, @"".dst *@"reflect".rtype, @"".target *interface {  }) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".call(@"".op string, @"".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".iword() (? @"reflect".iword)
func (? *@"reflect".Value) @"reflect".recv(@"".nb bool) (@"".val @"reflect".Value, @"".ok bool)
func (? *@"reflect".Value) @"reflect".runes() (? []rune)
func (? *@"reflect".Value) @"reflect".send(@"".x @"reflect".Value, @"".nb bool) (@"".selected bool)
func (? *@"reflect".Value) @"reflect".setRunes(@"".x []rune) ()
type @"encoding".TextUnmarshaler interface { @"encoding".UnmarshalText(@"encoding".text []byte) (? error) }
type @"bytes".readOp int
type @"reflect".ChanDir int
func (? @"reflect".ChanDir) @"reflect".String() (? string)
func (? *@"reflect".ChanDir) @"reflect".String() (? string)
type @"reflect".Kind uint
func (? @"reflect".Kind) @"reflect".String() (? string)
func (? *@"reflect".Kind) @"reflect".String() (? string)
type @"reflect".Method struct { @"reflect".Name string; @"reflect".PkgPath string; @"reflect".Type @"reflect".Type; @"reflect".Func @"reflect".Value; @"reflect".Index int }
type @"reflect".rtype struct { @"reflect".size uintptr; @"reflect".hash uint32; _ uint8; @"reflect".align uint8; @"reflect".fieldAlign uint8; @"reflect".kind uint8; @"reflect".alg *uintptr; @"reflect".gc @"unsafe".Pointer; @"reflect".string *string; ? *@"reflect".uncommonType; @"reflect".ptrToThis *@"reflect".rtype }
func (? *@"reflect".rtype) @"reflect".Align() (? int)
func (? *@"reflect".rtype) @"reflect".AssignableTo(@"".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".Bits() (? int)
func (? *@"reflect".rtype) @"reflect".ChanDir() (? @"reflect".ChanDir)
func (? *@"reflect".rtype) @"reflect".ConvertibleTo(@"".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".Elem() (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".Field(@"".i int) (? @"reflect".StructField)
func (? *@"reflect".rtype) @"reflect".FieldAlign() (? int)
func (? *@"reflect".rtype) @"reflect".FieldByIndex(@"".index []int) (? @"reflect".StructField)
func (? *@"reflect".rtype) @"reflect".FieldByName(@"".name string) (? @"reflect".StructField, ? bool)
func (? *@"reflect".rtype) @"reflect".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"reflect".StructField, ? bool)
func (? *@"reflect".rtype) @"reflect".Implements(@"".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".In(@"".i int) (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".IsVariadic() (? bool)
func (? *@"reflect".rtype) @"reflect".Key() (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".Kind() (? @"reflect".Kind)
func (? *@"reflect".rtype) @"reflect".Len() (? int)
func (? *@"reflect".rtype) @"reflect".Method(@"".i int) (@"".m @"reflect".Method)
func (? *@"reflect".rtype) @"reflect".MethodByName(@"".name string) (@"".m @"reflect".Method, @"".ok bool)
func (? *@"reflect".rtype) @"reflect".Name() (? string)
func (? *@"reflect".rtype) @"reflect".NumField() (? int)
func (? *@"reflect".rtype) @"reflect".NumIn() (? int)
func (? *@"reflect".rtype) @"reflect".NumMethod() (? int)
func (? *@"reflect".rtype) @"reflect".NumOut() (? int)
func (? *@"reflect".rtype) @"reflect".Out(@"".i int) (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".PkgPath() (? string)
func (? *@"reflect".rtype) @"reflect".Size() (? uintptr)
func (? *@"reflect".rtype) @"reflect".String() (? string)
func (? *@"reflect".rtype) @"reflect".common() (? *@"reflect".rtype)
func (? *@"reflect".rtype) @"reflect".ptrTo() (? *@"reflect".rtype)
type @"reflect".uncommonType struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".methods []@"reflect".method }
func (? *@"reflect".uncommonType) @"reflect".Method(@"".i int) (@"".m @"reflect".Method)
func (? *@"reflect".uncommonType) @"reflect".MethodByName(@"".name string) (@"".m @"reflect".Method, @"".ok bool)
func (? *@"reflect".uncommonType) @"reflect".Name() (? string)
func (? *@"reflect".uncommonType) @"reflect".NumMethod() (? int)
func (? *@"reflect".uncommonType) @"reflect".PkgPath() (? string)
func (? *@"reflect".uncommonType) @"reflect".uncommon() (? *@"reflect".uncommonType)
type @"reflect".StructTag string
func (? @"reflect".StructTag) @"reflect".Get(@"".key string) (? string)
func (? *@"reflect".StructTag) @"reflect".Get(@"".key string) (? string)
type @"reflect".flag uintptr
func (? @"reflect".flag) @"reflect".kind() (? @"reflect".Kind)
func (? @"reflect".flag) @"reflect".mustBe(@"".expected @"reflect".Kind) ()
func (? @"reflect".flag) @"reflect".mustBeAssignable() ()
func (? @"reflect".flag) @"reflect".mustBeExported() ()
func (? *@"reflect".flag) @"reflect".kind() (? @"reflect".Kind)
func (? *@"reflect".flag) @"reflect".mustBe(@"".expected @"reflect".Kind) ()
func (? *@"reflect".flag) @"reflect".mustBeAssignable() ()
func (? *@"reflect".flag) @"reflect".mustBeExported() ()
type @"reflect".iword @"unsafe".Pointer
type @"reflect".method struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".mtyp *@"reflect".rtype; @"reflect".typ *@"reflect".rtype; @"reflect".ifn @"unsafe".Pointer; @"reflect".tfn @"unsafe".Pointer }
$$
0Åæruntimeerrorssync/atomicsynciounicodeunicode/utf8bytesencodingmathstrconvstringsencoding/base64syscalltimeosreflectfmtsortunicode/utf16encoding/json0Ç%0encodingencoding0encoding/base64base640errorserrors0
fmtfmt0reflectreflect0runtimeruntime0strconvstrconv0stringsstrings0unicodeunicode0unicode/utf16utf160unicode/utf8utf80bytesbytes0mathmath0sortsort0syncsync0ioioÇYK	var Unmarshaler;
	Unmarshaler = go$newType(0, "Interface", "json.Unmarshaler", "Unmarshaler", "encoding/json", null);
	go$pkg.Unmarshaler = Unmarshaler;
	var UnmarshalTypeError;
	UnmarshalTypeError = go$newType(0, "Struct", "json.UnmarshalTypeError", "UnmarshalTypeError", "encoding/json", function(Value_, Type_) {
		this.go$val = this;
		this.Value = Value_ !== undefined ? Value_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.UnmarshalTypeError = UnmarshalTypeError;
	var UnmarshalFieldError;
	UnmarshalFieldError = go$newType(0, "Struct", "json.UnmarshalFieldError", "UnmarshalFieldError", "encoding/json", function(Key_, Type_, Field_) {
		this.go$val = this;
		this.Key = Key_ !== undefined ? Key_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Field = Field_ !== undefined ? Field_ : new reflect.StructField.Ptr();
	});
	go$pkg.UnmarshalFieldError = UnmarshalFieldError;
	var InvalidUnmarshalError;
	InvalidUnmarshalError = go$newType(0, "Struct", "json.InvalidUnmarshalError", "InvalidUnmarshalError", "encoding/json", function(Type_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.InvalidUnmarshalError = InvalidUnmarshalError;
	var Number;
	Number = go$newType(0, "String", "json.Number", "Number", "encoding/json", null);
	go$pkg.Number = Number;
	var decodeState;
	decodeState = go$newType(0, "Struct", "json.decodeState", "decodeState", "encoding/json", function(data_, off_, scan_, nextscan_, savedError_, tempstr_, useNumber_) {
		this.go$val = this;
		this.data = data_ !== undefined ? data_ : (go$sliceType(Go$Uint8)).nil;
		this.off = off_ !== undefined ? off_ : 0;
		this.scan = scan_ !== undefined ? scan_ : new scanner.Ptr();
		this.nextscan = nextscan_ !== undefined ? nextscan_ : new scanner.Ptr();
		this.savedError = savedError_ !== undefined ? savedError_ : null;
		this.tempstr = tempstr_ !== undefined ? tempstr_ : "";
		this.useNumber = useNumber_ !== undefined ? useNumber_ : false;
	});
	go$pkg.decodeState = decodeState;
	var Marshaler;
	Marshaler = go$newType(0, "Interface", "json.Marshaler", "Marshaler", "encoding/json", null);
	go$pkg.Marshaler = Marshaler;
	var UnsupportedTypeError;
	UnsupportedTypeError = go$newType(0, "Struct", "json.UnsupportedTypeError", "UnsupportedTypeError", "encoding/json", function(Type_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
	});
	go$pkg.UnsupportedTypeError = UnsupportedTypeError;
	var UnsupportedValueError;
	UnsupportedValueError = go$newType(0, "Struct", "json.UnsupportedValueError", "UnsupportedValueError", "encoding/json", function(Value_, Str_) {
		this.go$val = this;
		this.Value = Value_ !== undefined ? Value_ : new reflect.Value.Ptr();
		this.Str = Str_ !== undefined ? Str_ : "";
	});
	go$pkg.UnsupportedValueError = UnsupportedValueError;
	var InvalidUTF8Error;
	InvalidUTF8Error = go$newType(0, "Struct", "json.InvalidUTF8Error", "InvalidUTF8Error", "encoding/json", function(S_) {
		this.go$val = this;
		this.S = S_ !== undefined ? S_ : "";
	});
	go$pkg.InvalidUTF8Error = InvalidUTF8Error;
	var MarshalerError;
	MarshalerError = go$newType(0, "Struct", "json.MarshalerError", "MarshalerError", "encoding/json", function(Type_, Err_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.MarshalerError = MarshalerError;
	var encodeState;
	encodeState = go$newType(0, "Struct", "json.encodeState", "encodeState", "encoding/json", function(Buffer_, scratch_) {
		this.go$val = this;
		this.Buffer = Buffer_ !== undefined ? Buffer_ : new bytes.Buffer.Ptr();
		this.scratch = scratch_ !== undefined ? scratch_ : go$makeNativeArray("Uint8", 64, function() { return 0; });
	});
	encodeState.prototype.Bytes = function() { return this.go$val.Bytes(); };
	encodeState.Ptr.prototype.Bytes = function() { return this.Buffer.Bytes(); };
	encodeState.prototype.Grow = function(n) { return this.go$val.Grow(n); };
	encodeState.Ptr.prototype.Grow = function(n) { return this.Buffer.Grow(n); };
	encodeState.prototype.Len = function() { return this.go$val.Len(); };
	encodeState.Ptr.prototype.Len = function() { return this.Buffer.Len(); };
	encodeState.prototype.Next = function(n) { return this.go$val.Next(n); };
	encodeState.Ptr.prototype.Next = function(n) { return this.Buffer.Next(n); };
	encodeState.prototype.Read = function(p) { return this.go$val.Read(p); };
	encodeState.Ptr.prototype.Read = function(p) { return this.Buffer.Read(p); };
	encodeState.prototype.ReadByte = function() { return this.go$val.ReadByte(); };
	encodeState.Ptr.prototype.ReadByte = function() { return this.Buffer.ReadByte(); };
	encodeState.prototype.ReadBytes = function(delim) { return this.go$val.ReadBytes(delim); };
	encodeState.Ptr.prototype.ReadBytes = function(delim) { return this.Buffer.ReadBytes(delim); };
	encodeState.prototype.ReadFrom = function(r) { return this.go$val.ReadFrom(r); };
	encodeState.Ptr.prototype.ReadFrom = function(r) { return this.Buffer.ReadFrom(r); };
	encodeState.prototype.ReadRune = function() { return this.go$val.ReadRune(); };
	encodeState.Ptr.prototype.ReadRune = function() { return this.Buffer.ReadRune(); };
	encodeState.prototype.ReadString = function(delim) { return this.go$val.ReadString(delim); };
	encodeState.Ptr.prototype.ReadString = function(delim) { return this.Buffer.ReadString(delim); };
	encodeState.prototype.Reset = function() { return this.go$val.Reset(); };
	encodeState.Ptr.prototype.Reset = function() { return this.Buffer.Reset(); };
	encodeState.prototype.String = function() { return this.go$val.String(); };
	encodeState.Ptr.prototype.String = function() { return this.Buffer.String(); };
	encodeState.prototype.Truncate = function(n) { return this.go$val.Truncate(n); };
	encodeState.Ptr.prototype.Truncate = function(n) { return this.Buffer.Truncate(n); };
	encodeState.prototype.UnreadByte = function() { return this.go$val.UnreadByte(); };
	encodeState.Ptr.prototype.UnreadByte = function() { return this.Buffer.UnreadByte(); };
	encodeState.prototype.UnreadRune = function() { return this.go$val.UnreadRune(); };
	encodeState.Ptr.prototype.UnreadRune = function() { return this.Buffer.UnreadRune(); };
	encodeState.prototype.Write = function(p) { return this.go$val.Write(p); };
	encodeState.Ptr.prototype.Write = function(p) { return this.Buffer.Write(p); };
	encodeState.prototype.WriteByte = function(c) { return this.go$val.WriteByte(c); };
	encodeState.Ptr.prototype.WriteByte = function(c) { return this.Buffer.WriteByte(c); };
	encodeState.prototype.WriteRune = function(r) { return this.go$val.WriteRune(r); };
	encodeState.Ptr.prototype.WriteRune = function(r) { return this.Buffer.WriteRune(r); };
	encodeState.prototype.WriteString = function(s) { return this.go$val.WriteString(s); };
	encodeState.Ptr.prototype.WriteString = function(s) { return this.Buffer.WriteString(s); };
	encodeState.prototype.WriteTo = function(w) { return this.go$val.WriteTo(w); };
	encodeState.Ptr.prototype.WriteTo = function(w) { return this.Buffer.WriteTo(w); };
	encodeState.prototype.grow = function(n) { return this.go$val.grow(n); };
	encodeState.Ptr.prototype.grow = function(n) { return this.Buffer.grow(n); };
	encodeState.prototype.readSlice = function(delim) { return this.go$val.readSlice(delim); };
	encodeState.Ptr.prototype.readSlice = function(delim) { return this.Buffer.readSlice(delim); };
	go$pkg.encodeState = encodeState;
	var encoderFunc;
	encoderFunc = go$newType(0, "Func", "json.encoderFunc", "encoderFunc", "encoding/json", null);
	go$pkg.encoderFunc = encoderFunc;
	var floatEncoder;
	floatEncoder = go$newType(4, "Int", "json.floatEncoder", "floatEncoder", "encoding/json", null);
	go$pkg.floatEncoder = floatEncoder;
	var structEncoder;
	structEncoder = go$newType(0, "Struct", "json.structEncoder", "structEncoder", "encoding/json", function(fields_, fieldEncs_) {
		this.go$val = this;
		this.fields = fields_ !== undefined ? fields_ : (go$sliceType(field)).nil;
		this.fieldEncs = fieldEncs_ !== undefined ? fieldEncs_ : (go$sliceType(encoderFunc)).nil;
	});
	go$pkg.structEncoder = structEncoder;
	var mapEncoder;
	mapEncoder = go$newType(0, "Struct", "json.mapEncoder", "mapEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.mapEncoder = mapEncoder;
	var sliceEncoder;
	sliceEncoder = go$newType(0, "Struct", "json.sliceEncoder", "sliceEncoder", "encoding/json", function(arrayEnc_) {
		this.go$val = this;
		this.arrayEnc = arrayEnc_ !== undefined ? arrayEnc_ : go$throwNilPointerError;
	});
	go$pkg.sliceEncoder = sliceEncoder;
	var arrayEncoder;
	arrayEncoder = go$newType(0, "Struct", "json.arrayEncoder", "arrayEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.arrayEncoder = arrayEncoder;
	var ptrEncoder;
	ptrEncoder = go$newType(0, "Struct", "json.ptrEncoder", "ptrEncoder", "encoding/json", function(elemEnc_) {
		this.go$val = this;
		this.elemEnc = elemEnc_ !== undefined ? elemEnc_ : go$throwNilPointerError;
	});
	go$pkg.ptrEncoder = ptrEncoder;
	var condAddrEncoder;
	condAddrEncoder = go$newType(0, "Struct", "json.condAddrEncoder", "condAddrEncoder", "encoding/json", function(canAddrEnc_, elseEnc_) {
		this.go$val = this;
		this.canAddrEnc = canAddrEnc_ !== undefined ? canAddrEnc_ : go$throwNilPointerError;
		this.elseEnc = elseEnc_ !== undefined ? elseEnc_ : go$throwNilPointerError;
	});
	go$pkg.condAddrEncoder = condAddrEncoder;
	var stringValues;
	stringValues = go$newType(0, "Slice", "json.stringValues", "stringValues", "encoding/json", null);
	go$pkg.stringValues = stringValues;
	var field;
	field = go$newType(0, "Struct", "json.field", "field", "encoding/json", function(name_, tag_, index_, typ_, omitEmpty_, quoted_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.tag = tag_ !== undefined ? tag_ : false;
		this.index = index_ !== undefined ? index_ : (go$sliceType(Go$Int)).nil;
		this.typ = typ_ !== undefined ? typ_ : null;
		this.omitEmpty = omitEmpty_ !== undefined ? omitEmpty_ : false;
		this.quoted = quoted_ !== undefined ? quoted_ : false;
	});
	go$pkg.field = field;
	var byName;
	byName = go$newType(0, "Slice", "json.byName", "byName", "encoding/json", null);
	go$pkg.byName = byName;
	var byIndex;
	byIndex = go$newType(0, "Slice", "json.byIndex", "byIndex", "encoding/json", null);
	go$pkg.byIndex = byIndex;
	var SyntaxError;
	SyntaxError = go$newType(0, "Struct", "json.SyntaxError", "SyntaxError", "encoding/json", function(msg_, Offset_) {
		this.go$val = this;
		this.msg = msg_ !== undefined ? msg_ : "";
		this.Offset = Offset_ !== undefined ? Offset_ : new Go$Int64(0, 0);
	});
	go$pkg.SyntaxError = SyntaxError;
	var scanner;
	scanner = go$newType(0, "Struct", "json.scanner", "scanner", "encoding/json", function(step_, endTop_, parseState_, err_, redo_, redoCode_, redoState_, bytes_) {
		this.go$val = this;
		this.step = step_ !== undefined ? step_ : go$throwNilPointerError;
		this.endTop = endTop_ !== undefined ? endTop_ : false;
		this.parseState = parseState_ !== undefined ? parseState_ : (go$sliceType(Go$Int)).nil;
		this.err = err_ !== undefined ? err_ : null;
		this.redo = redo_ !== undefined ? redo_ : false;
		this.redoCode = redoCode_ !== undefined ? redoCode_ : 0;
		this.redoState = redoState_ !== undefined ? redoState_ : go$throwNilPointerError;
		this.bytes = bytes_ !== undefined ? bytes_ : new Go$Int64(0, 0);
	});
	go$pkg.scanner = scanner;
	var Decoder;
	Decoder = go$newType(0, "Struct", "json.Decoder", "Decoder", "encoding/json", function(r_, buf_, d_, scan_, err_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Uint8)).nil;
		this.d = d_ !== undefined ? d_ : new decodeState.Ptr();
		this.scan = scan_ !== undefined ? scan_ : new scanner.Ptr();
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.Decoder = Decoder;
	var Encoder;
	Encoder = go$newType(0, "Struct", "json.Encoder", "Encoder", "encoding/json", function(w_, e_, err_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : null;
		this.e = e_ !== undefined ? e_ : new encodeState.Ptr();
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.Encoder = Encoder;
	var RawMessage;
	RawMessage = go$newType(0, "Slice", "json.RawMessage", "RawMessage", "encoding/json", null);
	go$pkg.RawMessage = RawMessage;
	var tagOptions;
	tagOptions = go$newType(0, "String", "json.tagOptions", "tagOptions", "encoding/json", null);
	go$pkg.tagOptions = tagOptions;
	Unmarshaler.init([["UnmarshalJSON", "", (go$funcType([(go$sliceType(Go$Uint8))], [go$error], false))]]);
	UnmarshalTypeError.init([["Value", "", Go$String, ""], ["Type", "", reflect.Type, ""]]);
	(go$ptrType(UnmarshalTypeError)).methods = [["Error", "", [], [Go$String], false]];
	UnmarshalFieldError.init([["Key", "", Go$String, ""], ["Type", "", reflect.Type, ""], ["Field", "", reflect.StructField, ""]]);
	(go$ptrType(UnmarshalFieldError)).methods = [["Error", "", [], [Go$String], false]];
	InvalidUnmarshalError.init([["Type", "", reflect.Type, ""]]);
	(go$ptrType(InvalidUnmarshalError)).methods = [["Error", "", [], [Go$String], false]];
	Number.methods = [["Float64", "", [], [Go$Float64, go$error], false], ["Int64", "", [], [Go$Int64, go$error], false], ["String", "", [], [Go$String], false]];
	(go$ptrType(Number)).methods = [["Float64", "", [], [Go$Float64, go$error], false], ["Int64", "", [], [Go$Int64, go$error], false], ["String", "", [], [Go$String], false]];
	decodeState.init([["data", "encoding/json", (go$sliceType(Go$Uint8)), ""], ["off", "encoding/json", Go$Int, ""], ["scan", "encoding/json", scanner, ""], ["nextscan", "encoding/json", scanner, ""], ["savedError", "encoding/json", go$error, ""], ["tempstr", "encoding/json", Go$String, ""], ["useNumber", "encoding/json", Go$Bool, ""]]);
	(go$ptrType(decodeState)).methods = [["array", "encoding/json", [reflect.Value], [], false], ["arrayInterface", "encoding/json", [], [(go$sliceType(go$emptyInterface))], false], ["convertNumber", "encoding/json", [Go$String], [go$emptyInterface, go$error], false], ["error", "encoding/json", [go$error], [], false], ["indirect", "encoding/json", [reflect.Value, Go$Bool], [Unmarshaler, encoding.TextUnmarshaler, reflect.Value], false], ["init", "encoding/json", [(go$sliceType(Go$Uint8))], [(go$ptrType(decodeState))], false], ["literal", "encoding/json", [reflect.Value], [], false], ["literalInterface", "encoding/json", [], [go$emptyInterface], false], ["literalStore", "encoding/json", [(go$sliceType(Go$Uint8)), reflect.Value, Go$Bool], [], false], ["next", "encoding/json", [], [(go$sliceType(Go$Uint8))], false], ["object", "encoding/json", [reflect.Value], [], false], ["objectInterface", "encoding/json", [], [(go$mapType(Go$String, go$emptyInterface))], false], ["saveError", "encoding/json", [go$error], [], false], ["scanWhile", "encoding/json", [Go$Int], [Go$Int], false], ["unmarshal", "encoding/json", [go$emptyInterface], [go$error], false], ["value", "encoding/json", [reflect.Value], [], false], ["valueInterface", "encoding/json", [], [go$emptyInterface], false]];
	Marshaler.init([["MarshalJSON", "", (go$funcType([], [(go$sliceType(Go$Uint8)), go$error], false))]]);
	UnsupportedTypeError.init([["Type", "", reflect.Type, ""]]);
	(go$ptrType(UnsupportedTypeError)).methods = [["Error", "", [], [Go$String], false]];
	UnsupportedValueError.init([["Value", "", reflect.Value, ""], ["Str", "", Go$String, ""]]);
	(go$ptrType(UnsupportedValueError)).methods = [["Error", "", [], [Go$String], false]];
	InvalidUTF8Error.init([["S", "", Go$String, ""]]);
	(go$ptrType(InvalidUTF8Error)).methods = [["Error", "", [], [Go$String], false]];
	MarshalerError.init([["Type", "", reflect.Type, ""], ["Err", "", go$error, ""]]);
	(go$ptrType(MarshalerError)).methods = [["Error", "", [], [Go$String], false]];
	encodeState.init([["", "", bytes.Buffer, ""], ["scratch", "encoding/json", (go$arrayType(Go$Uint8, 64)), ""]]);
	(go$ptrType(encodeState)).methods = [["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Grow", "", [Go$Int], [], false], ["Len", "", [], [Go$Int], false], ["Next", "", [Go$Int], [(go$sliceType(Go$Uint8))], false], ["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["ReadByte", "", [], [Go$Uint8, go$error], false], ["ReadBytes", "", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false], ["ReadFrom", "", [io.Reader], [Go$Int64, go$error], false], ["ReadRune", "", [], [Go$Int32, Go$Int, go$error], false], ["ReadString", "", [Go$Uint8], [Go$String, go$error], false], ["Reset", "", [], [], false], ["String", "", [], [Go$String], false], ["Truncate", "", [Go$Int], [], false], ["UnreadByte", "", [], [go$error], false], ["UnreadRune", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["WriteByte", "", [Go$Uint8], [go$error], false], ["WriteRune", "", [Go$Int32], [Go$Int, go$error], false], ["WriteString", "", [Go$String], [Go$Int, go$error], false], ["WriteTo", "", [io.Writer], [Go$Int64, go$error], false], ["grow", "bytes", [Go$Int], [Go$Int], false], ["readSlice", "bytes", [Go$Uint8], [(go$sliceType(Go$Uint8)), go$error], false], ["error", "encoding/json", [go$error], [], false], ["marshal", "encoding/json", [go$emptyInterface], [go$error], false], ["reflectValue", "encoding/json", [reflect.Value], [], false], ["string", "encoding/json", [Go$String], [Go$Int, go$error], false], ["stringBytes", "encoding/json", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	encoderFunc.init([(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false);
	floatEncoder.methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	(go$ptrType(floatEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	structEncoder.init([["fields", "encoding/json", (go$sliceType(field)), ""], ["fieldEncs", "encoding/json", (go$sliceType(encoderFunc)), ""]]);
	(go$ptrType(structEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	mapEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(mapEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	sliceEncoder.init([["arrayEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(sliceEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	arrayEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(arrayEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	ptrEncoder.init([["elemEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(ptrEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	condAddrEncoder.init([["canAddrEnc", "encoding/json", encoderFunc, ""], ["elseEnc", "encoding/json", encoderFunc, ""]]);
	(go$ptrType(condAddrEncoder)).methods = [["encode", "encoding/json", [(go$ptrType(encodeState)), reflect.Value, Go$Bool], [], false]];
	stringValues.init(reflect.Value);
	stringValues.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false], ["get", "encoding/json", [Go$Int], [Go$String], false]];
	(go$ptrType(stringValues)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false], ["get", "encoding/json", [Go$Int], [Go$String], false]];
	field.init([["name", "encoding/json", Go$String, ""], ["tag", "encoding/json", Go$Bool, ""], ["index", "encoding/json", (go$sliceType(Go$Int)), ""], ["typ", "encoding/json", reflect.Type, ""], ["omitEmpty", "encoding/json", Go$Bool, ""], ["quoted", "encoding/json", Go$Bool, ""]]);
	byName.init(field);
	byName.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(byName)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	byIndex.init(field);
	byIndex.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(byIndex)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	SyntaxError.init([["msg", "encoding/json", Go$String, ""], ["Offset", "", Go$Int64, ""]]);
	(go$ptrType(SyntaxError)).methods = [["Error", "", [], [Go$String], false]];
	scanner.init([["step", "encoding/json", (go$funcType([(go$ptrType(scanner)), Go$Int], [Go$Int], false)), ""], ["endTop", "encoding/json", Go$Bool, ""], ["parseState", "encoding/json", (go$sliceType(Go$Int)), ""], ["err", "encoding/json", go$error, ""], ["redo", "encoding/json", Go$Bool, ""], ["redoCode", "encoding/json", Go$Int, ""], ["redoState", "encoding/json", (go$funcType([(go$ptrType(scanner)), Go$Int], [Go$Int], false)), ""], ["bytes", "encoding/json", Go$Int64, ""]]);
	(go$ptrType(scanner)).methods = [["eof", "encoding/json", [], [Go$Int], false], ["error", "encoding/json", [Go$Int, Go$String], [Go$Int], false], ["popParseState", "encoding/json", [], [], false], ["pushParseState", "encoding/json", [Go$Int], [], false], ["reset", "encoding/json", [], [], false], ["undo", "encoding/json", [Go$Int], [], false]];
	Decoder.init([["r", "encoding/json", io.Reader, ""], ["buf", "encoding/json", (go$sliceType(Go$Uint8)), ""], ["d", "encoding/json", decodeState, ""], ["scan", "encoding/json", scanner, ""], ["err", "encoding/json", go$error, ""]]);
	(go$ptrType(Decoder)).methods = [["Buffered", "", [], [io.Reader], false], ["Decode", "", [go$emptyInterface], [go$error], false], ["UseNumber", "", [], [], false], ["readValue", "encoding/json", [], [Go$Int, go$error], false]];
	Encoder.init([["w", "encoding/json", io.Writer, ""], ["e", "encoding/json", encodeState, ""], ["err", "encoding/json", go$error, ""]]);
	(go$ptrType(Encoder)).methods = [["Encode", "", [go$emptyInterface], [go$error], false]];
	RawMessage.init(Go$Uint8);
	(go$ptrType(RawMessage)).methods = [["MarshalJSON", "", [], [(go$sliceType(Go$Uint8)), go$error], false], ["UnmarshalJSON", "", [(go$sliceType(Go$Uint8))], [go$error], false]];
	tagOptions.methods = [["Contains", "", [Go$String], [Go$Bool], false]];
	(go$ptrType(tagOptions)).methods = [["Contains", "", [Go$String], [Go$Bool], false]];
Ç…	var errPhase = null;
	var numberType = null;
	var hex = "";
	var encodeStatePool = (go$chanType((go$ptrType(encodeState)), false, false)).nil;
	var byteSliceType = null;
	var encoderCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "encoding/json", (go$mapType(reflect.Type, encoderFunc)), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
	var marshalerType = null;
	var textMarshalerType = null;
	var float32Encoder = go$throwNilPointerError;
	var float64Encoder = go$throwNilPointerError;
	var fieldCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "encoding/json", (go$mapType(reflect.Type, (go$sliceType(field)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
	var _ = null;
	var _$1 = null;
0Éí0Å˛	UnmarshalÅ	var Unmarshal = go$pkg.Unmarshal = function(data, v) {
		var d, err;
		d = new decodeState.Ptr();
		err = checkValid(data, d.scan);
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		d.init(data);
		return d.unmarshal(v);
	};
0ÇErrorÅ˛	UnmarshalTypeError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: cannot unmarshal " + e.Value + " into Go value of type " + e.Type.String();
	};
	UnmarshalTypeError.prototype.Error = function() { return this.go$val.Error(); };
0Ç@ErrorÇ5	UnmarshalFieldError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: cannot unmarshal object key " + strconv.Quote(e.Key) + " into unexported field " + e.Field.Name + " of type " + e.Type.String();
	};
	UnmarshalFieldError.prototype.Error = function() { return this.go$val.Error(); };
0Ç¶ErrorÇõ	InvalidUnmarshalError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		if (go$interfaceIsEqual(e.Type, null)) {
			return "json: Unmarshal(nil)";
		}
		if (!((e.Type.Kind() === 22))) {
			return "json: Unmarshal(non-pointer " + e.Type.String() + ")";
		}
		return "json: Unmarshal(nil " + e.Type.String() + ")";
	};
	InvalidUnmarshalError.prototype.Error = function() { return this.go$val.Error(); };
0ÇÆ	unmarshalÇü	decodeState.Ptr.prototype.unmarshal = function(v) {
		var err, d, _struct, rv, _struct$1;
		err = null;
		var go$deferred = [];
		try {
			d = this;
			go$deferred.push({ fun: (function() {
				var r, ok, _tuple;
				if (r = go$recover(), !(go$interfaceIsEqual(r, null))) {
					if (_tuple = (r !== null && runtime.Error.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), ok = _tuple[1], ok) {
						throw go$panic(r);
					}
					err = (r !== null && go$error.implementedBy.indexOf(r.constructor) !== -1 ? r : go$typeAssertionFailed(r, go$error));
				}
			}), args: [] });
			rv = (_struct = reflect.ValueOf(v), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			if (!((rv.Kind() === 22)) || rv.IsNil()) {
				err = new InvalidUnmarshalError.Ptr(reflect.TypeOf(v));
				return err;
			}
			d.scan.reset();
			d.value((_struct$1 = rv, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)));
			err = d.savedError;
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	decodeState.prototype.unmarshal = function(v) { return this.go$val.unmarshal(v); };
0Å¡StringÅ∂	Number.prototype.String = function() {
		var n;
		n = this.go$val;
		return n;
	};
	go$ptrType(Number).prototype.String = function() { return new Number(this.go$get()).String(); };
0Å›Float64Å—	Number.prototype.Float64 = function() {
		var n;
		n = this.go$val;
		return strconv.ParseFloat(n, 64);
	};
	go$ptrType(Number).prototype.Float64 = function() { return new Number(this.go$get()).Float64(); };
0Å◊Int64ÅÕ	Number.prototype.Int64 = function() {
		var n;
		n = this.go$val;
		return strconv.ParseInt(n, 10, 64);
	};
	go$ptrType(Number).prototype.Int64 = function() { return new Number(this.go$get()).Int64(); };
0ÅÁinitÅﬁ	decodeState.Ptr.prototype.init = function(data) {
		var d;
		d = this;
		d.data = data;
		d.off = 0;
		d.savedError = null;
		return d;
	};
	decodeState.prototype.init = function(data) { return this.go$val.init(data); };
0ÅæerrorÅ¥	decodeState.Ptr.prototype.error = function(err) {
		var d;
		d = this;
		throw go$panic(err);
	};
	decodeState.prototype.error = function(err) { return this.go$val.error(err); };
0Ç	saveErrorÅı	decodeState.Ptr.prototype.saveError = function(err) {
		var d;
		d = this;
		if (go$interfaceIsEqual(d.savedError, null)) {
			d.savedError = err;
		}
	};
	decodeState.prototype.saveError = function(err) { return this.go$val.saveError(err); };
0Ç∂nextÇ¨	decodeState.Ptr.prototype.next = function() {
		var d, _slice, _index, c, _tuple, item, rest, err;
		d = this;
		c = (_slice = d.data, _index = d.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_tuple = nextValue(go$subslice(d.data, d.off), d.nextscan), item = _tuple[0], rest = _tuple[1], err = _tuple[2];
		if (!(go$interfaceIsEqual(err, null))) {
			d.error(err);
		}
		d.off = d.data.length - rest.length >> 0;
		if (c === 123) {
			d.scan.step(d.scan, 125);
		} else {
			d.scan.step(d.scan, 93);
		}
		return item;
	};
	decodeState.prototype.next = function() { return this.go$val.next(); };
0Çå	scanWhileÇ}	decodeState.Ptr.prototype.scanWhile = function(op) {
		var d, newOp, _slice, _index, c;
		d = this;
		newOp = 0;
		while (true) {
			if (d.off >= d.data.length) {
				newOp = d.scan.eof();
				d.off = d.data.length + 1 >> 0;
			} else {
				c = ((_slice = d.data, _index = d.off, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0);
				d.off = d.off + 1 >> 0;
				newOp = d.scan.step(d.scan, c);
			}
			if (!((newOp === op))) {
				break;
			}
		}
		return newOp;
	};
	decodeState.prototype.scanWhile = function(op) { return this.go$val.scanWhile(op); };
0ÇívalueÇá	decodeState.Ptr.prototype.value = function(v) {
		var d, _tuple, rest, err, n, _slice, _index, op, _ref, _struct, _struct$1, _struct$2;
		d = this;
		if (!v.IsValid()) {
			_tuple = nextValue(go$subslice(d.data, d.off), d.nextscan), rest = _tuple[1], err = _tuple[2];
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			d.off = d.data.length - rest.length >> 0;
			if (d.scan.redo) {
				d.scan.redo = false;
				d.scan.step = stateBeginValue;
			}
			d.scan.step(d.scan, 34);
			d.scan.step(d.scan, 34);
			n = d.scan.parseState.length;
			if (n > 0 && ((_slice = d.scan.parseState, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 0)) {
				d.scan.step(d.scan, 58);
				d.scan.step(d.scan, 34);
				d.scan.step(d.scan, 34);
				d.scan.step(d.scan, 125);
			}
			return;
		}
		op = d.scanWhile(9);
		_ref = op;
		if (_ref === 6) {
			d.array((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
		} else if (_ref === 2) {
			d.object((_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)));
		} else if (_ref === 1) {
			d.literal((_struct$2 = v, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)));
		} else {
			d.error(errPhase);
		}
	};
	decodeState.prototype.value = function(v) { return this.go$val.value(v); };
0Ç≤indirectÇ§	decodeState.Ptr.prototype.indirect = function(v, decodingNull) {
		var d, _struct, _struct$1, e, _struct$2, _struct$3, ok, _tuple, x, u, ok$1, _tuple$1, x$1, u$1, _struct$4, _struct$5;
		d = this;
		if (!((v.Kind() === 22)) && !(v.Type().Name() === "") && v.CanAddr()) {
			v = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		}
		while (true) {
			if ((v.Kind() === 20) && !v.IsNil()) {
				e = (_struct$1 = v.Elem(), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				if ((e.Kind() === 22) && !e.IsNil() && (!decodingNull || (e.Elem().Kind() === 22))) {
					v = (_struct$2 = e, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
					continue;
				}
			}
			if (!((v.Kind() === 22))) {
				break;
			}
			if (!((v.Elem().Kind() === 22)) && decodingNull && v.CanSet()) {
				break;
			}
			if (v.IsNil()) {
				v.Set((_struct$3 = reflect.New(v.Type().Elem()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			}
			if (v.Type().NumMethod() > 0) {
				if (_tuple = (x = v.Interface(), (x !== null && Unmarshaler.implementedBy.indexOf(x.constructor) !== -1 ? [x, true] : [null, false])), u = _tuple[0], ok = _tuple[1], ok) {
					return [u, null, new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0)];
				}
				if (_tuple$1 = (x$1 = v.Interface(), (x$1 !== null && encoding.TextUnmarshaler.implementedBy.indexOf(x$1.constructor) !== -1 ? [x$1, true] : [null, false])), u$1 = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
					return [null, u$1, new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0)];
				}
			}
			v = (_struct$4 = v.Elem(), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
		}
		return [null, null, (_struct$5 = v, new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag))];
	};
	decodeState.prototype.indirect = function(v, decodingNull) { return this.go$val.indirect(v, decodingNull); };
0ÇGarrayÇ<	decodeState.Ptr.prototype.array = function(v) {
		var d, _tuple, _struct, u, ut, _struct$1, pv, err, _struct$2, _ref, _struct$3, i, op, _q, newcap, _struct$4, newv, _struct$5, _struct$6, _struct$7, _struct$8, _struct$9, z, _struct$10, _struct$11;
		d = this;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			d.off = d.off - 1 >> 0;
			err = u.UnmarshalJSON(d.next());
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		_ref = v.Kind();
		switch (undefined) {
		default:
			if (_ref === 20) {
				if (v.NumMethod() === 0) {
					v.Set((_struct$3 = reflect.ValueOf(d.arrayInterface()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
					return;
				}
				d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
				d.off = d.off - 1 >> 0;
				d.next();
				return;
			} else if (_ref === 17) {
			} else if (_ref === 23) {
				break;
			} else {
				d.saveError(new UnmarshalTypeError.Ptr("array", v.Type()));
				d.off = d.off - 1 >> 0;
				d.next();
				return;
			}
		}
		i = 0;
		while (true) {
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			d.off = d.off - 1 >> 0;
			d.scan.undo(op);
			if (v.Kind() === 23) {
				if (i >= v.Cap()) {
					newcap = v.Cap() + (_q = v.Cap() / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
					if (newcap < 4) {
						newcap = 4;
					}
					newv = (_struct$4 = reflect.MakeSlice(v.Type(), v.Len(), newcap), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
					reflect.Copy((_struct$5 = newv, new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), (_struct$6 = v, new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
					v.Set((_struct$7 = newv, new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)));
				}
				if (i >= v.Len()) {
					v.SetLen(i + 1 >> 0);
				}
			}
			if (i < v.Len()) {
				d.value((_struct$8 = v.Index(i), new reflect.Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)));
			} else {
				d.value(new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0));
			}
			i = i + 1 >> 0;
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			if (!((op === 7))) {
				d.error(errPhase);
			}
		}
		if (i < v.Len()) {
			if (v.Kind() === 17) {
				z = (_struct$9 = reflect.Zero(v.Type().Elem()), new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag));
				while (i < v.Len()) {
					v.Index(i).Set((_struct$10 = z, new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)));
					i = i + 1 >> 0;
				}
			} else {
				v.SetLen(i);
			}
		}
		if ((i === 0) && (v.Kind() === 23)) {
			v.Set((_struct$11 = reflect.MakeSlice(v.Type(), 0, 0), new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag)));
		}
	};
	decodeState.prototype.array = function(v) { return this.go$val.array(v); };
0ÇYobjectÇM	decodeState.Ptr.prototype.object = function(v) {
		var d, _tuple, _struct, u, ut, _struct$1, pv, err, _struct$2, _struct$3, _ref, t, _struct$4, mapElem, op, start, item, _tuple$1, key, ok, subv, destring, elemType, _struct$5, _struct$6, _struct$7, f, fields, _ref$1, _i, i, _slice, _index, ff, _struct$8, _ref$2, _i$1, _slice$1, _index$1, i$1, _struct$9, _struct$10, _struct$11, v$1, _struct$12, _struct$13, _struct$14, _struct$15, kv, _struct$16, _struct$17;
		d = this;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			d.off = d.off - 1 >> 0;
			err = u.UnmarshalJSON(d.next());
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
			d.off = d.off - 1 >> 0;
			d.next();
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		if ((v.Kind() === 20) && (v.NumMethod() === 0)) {
			v.Set((_struct$3 = reflect.ValueOf(new (go$mapType(Go$String, go$emptyInterface))(d.objectInterface())), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			return;
		}
		_ref = v.Kind();
		switch (undefined) {
		default:
			if (_ref === 21) {
				t = v.Type();
				if (!((t.Key().Kind() === 24))) {
					d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
					break;
				}
				if (v.IsNil()) {
					v.Set((_struct$4 = reflect.MakeMap(t), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)));
				}
			} else if (_ref === 25) {
			} else {
				d.saveError(new UnmarshalTypeError.Ptr("object", v.Type()));
				d.off = d.off - 1 >> 0;
				d.next();
				return;
			}
		}
		mapElem = new reflect.Value.Ptr();
		while (true) {
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 1))) {
				d.error(errPhase);
			}
			start = d.off - 1 >> 0;
			op = d.scanWhile(0);
			item = go$subslice(d.data, start, (d.off - 1 >> 0));
			_tuple$1 = unquote(item), key = _tuple$1[0], ok = _tuple$1[1];
			if (!ok) {
				d.error(errPhase);
			}
			subv = new reflect.Value.Ptr();
			destring = false;
			if (v.Kind() === 21) {
				elemType = v.Type().Elem();
				if (!mapElem.IsValid()) {
					mapElem = (_struct$5 = reflect.New(elemType).Elem(), new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag));
				} else {
					mapElem.Set((_struct$6 = reflect.Zero(elemType), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
				}
				subv = (_struct$7 = mapElem, new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag));
			} else {
				f = (go$ptrType(field)).nil;
				fields = cachedTypeFields(v.Type());
				_ref$1 = fields;
				_i = 0;
				for (; _i < _ref$1.length; _i += 1) {
					i = _i;
					ff = (_slice = fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
					if (ff.name === key) {
						f = ff;
						break;
					}
					if (f === (go$ptrType(field)).nil && strings.EqualFold(ff.name, key)) {
						f = ff;
					}
				}
				if (!(f === (go$ptrType(field)).nil)) {
					subv = (_struct$8 = v, new reflect.Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag));
					destring = f.quoted;
					_ref$2 = f.index;
					_i$1 = 0;
					for (; _i$1 < _ref$2.length; _i$1 += 1) {
						i$1 = (_slice$1 = _ref$2, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
						if (subv.Kind() === 22) {
							if (subv.IsNil()) {
								subv.Set((_struct$9 = reflect.New(subv.Type().Elem()), new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag)));
							}
							subv = (_struct$10 = subv.Elem(), new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag));
						}
						subv = (_struct$11 = subv.Field(i$1), new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag));
					}
				}
			}
			if (op === 9) {
				op = d.scanWhile(9);
			}
			if (!((op === 3))) {
				d.error(errPhase);
			}
			if (destring) {
				d.value((_struct$12 = reflect.ValueOf(new (go$ptrType(Go$String))(function() { return d.tempstr; }, function(v$1) { d.tempstr = v$1; })), new reflect.Value.Ptr(_struct$12.typ, _struct$12.val, _struct$12.flag)));
				d.literalStore(new (go$sliceType(Go$Uint8))(go$stringToBytes(d.tempstr)), (_struct$13 = subv, new reflect.Value.Ptr(_struct$13.typ, _struct$13.val, _struct$13.flag)), true);
			} else {
				d.value((_struct$14 = subv, new reflect.Value.Ptr(_struct$14.typ, _struct$14.val, _struct$14.flag)));
			}
			if (v.Kind() === 21) {
				kv = (_struct$15 = reflect.ValueOf(new Go$String(key)).Convert(v.Type().Key()), new reflect.Value.Ptr(_struct$15.typ, _struct$15.val, _struct$15.flag));
				v.SetMapIndex((_struct$16 = kv, new reflect.Value.Ptr(_struct$16.typ, _struct$16.val, _struct$16.flag)), (_struct$17 = subv, new reflect.Value.Ptr(_struct$17.typ, _struct$17.val, _struct$17.flag)));
			}
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 4))) {
				d.error(errPhase);
			}
		}
	};
	decodeState.prototype.object = function(v) { return this.go$val.object(v); };
0Ç¶literalÇô	decodeState.Ptr.prototype.literal = function(v) {
		var d, start, op, _struct;
		d = this;
		start = d.off - 1 >> 0;
		op = d.scanWhile(0);
		d.off = d.off - 1 >> 0;
		d.scan.undo(op);
		d.literalStore(go$subslice(d.data, start, d.off), (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	decodeState.prototype.literal = function(v) { return this.go$val.literal(v); };
0ÇconvertNumberÇÚ	decodeState.Ptr.prototype.convertNumber = function(s) {
		var d, _tuple, f, err;
		d = this;
		if (d.useNumber) {
			return [new Number(s), null];
		}
		_tuple = strconv.ParseFloat(s, 64), f = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [null, new UnmarshalTypeError.Ptr("number " + s, reflect.TypeOf(new Go$Float64(0)))];
		}
		return [new Go$Float64(f), null];
	};
	decodeState.prototype.convertNumber = function(s) { return this.go$val.convertNumber(s); };
0Ç´literalStoreÇô	decodeState.Ptr.prototype.literalStore = function(item, v, fromQuoted) {
		var d, _slice, _index, wantptr, _tuple, _struct, u, ut, _struct$1, pv, err, _slice$1, _index$1, _tuple$1, s, ok, err$1, _struct$2, _slice$2, _index$2, c, _ref, _ref$1, _struct$3, value, _ref$2, _struct$4, _tuple$2, s$1, ok$1, _ref$3, b, _tuple$3, n, err$2, _struct$5, _struct$6, s$2, _ref$4, _tuple$4, n$1, err$3, _struct$7, _tuple$5, n$2, err$4, _tuple$6, n$3, err$5, _tuple$7, n$4, err$6;
		d = this;
		if (item.length === 0) {
			d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
			return;
		}
		wantptr = (_slice = item, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 110;
		_tuple = d.indirect((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), wantptr), u = _tuple[0], ut = _tuple[1], pv = (_struct$1 = _tuple[2], new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(go$interfaceIsEqual(u, null))) {
			err = u.UnmarshalJSON(item);
			if (!(go$interfaceIsEqual(err, null))) {
				d.error(err);
			}
			return;
		}
		if (!(go$interfaceIsEqual(ut, null))) {
			if (!(((_slice$1 = item, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 34))) {
				if (fromQuoted) {
					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
				}
			}
			_tuple$1 = unquoteBytes(item), s = _tuple$1[0], ok = _tuple$1[1];
			if (!ok) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			err$1 = ut.UnmarshalText(s);
			if (!(go$interfaceIsEqual(err$1, null))) {
				d.error(err$1);
			}
			return;
		}
		v = (_struct$2 = pv, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		c = (_slice$2 = item, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
		_ref = c;
		if (_ref === 110) {
			_ref$1 = v.Kind();
			if (_ref$1 === 20 || _ref$1 === 22 || _ref$1 === 21 || _ref$1 === 23) {
				v.Set((_struct$3 = reflect.Zero(v.Type()), new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
			}
		} else if (_ref === 116 || _ref === 102) {
			value = c === 116;
			_ref$2 = v.Kind();
			if (_ref$2 === 1) {
				v.SetBool(value);
			} else if (_ref$2 === 20) {
				if (v.NumMethod() === 0) {
					v.Set((_struct$4 = reflect.ValueOf(new Go$Bool(value)), new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("bool", v.Type()));
				}
			} else {
				if (fromQuoted) {
					d.saveError(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("bool", v.Type()));
				}
			}
		} else if (_ref === 34) {
			_tuple$2 = unquoteBytes(item), s$1 = _tuple$2[0], ok$1 = _tuple$2[1];
			if (!ok$1) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			_ref$3 = v.Kind();
			switch (undefined) {
			default:
				if (_ref$3 === 23) {
					if (!(go$interfaceIsEqual(v.Type(), byteSliceType))) {
						d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
						break;
					}
					b = (go$sliceType(Go$Uint8)).make(base64.StdEncoding.DecodedLen(s$1.length), 0, function() { return 0; });
					_tuple$3 = base64.StdEncoding.Decode(b, s$1), n = _tuple$3[0], err$2 = _tuple$3[1];
					if (!(go$interfaceIsEqual(err$2, null))) {
						d.saveError(err$2);
						break;
					}
					v.Set((_struct$5 = reflect.ValueOf(go$subslice(b, 0, n)), new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)));
				} else if (_ref$3 === 24) {
					v.SetString(go$bytesToString(s$1));
				} else if (_ref$3 === 20) {
					if (v.NumMethod() === 0) {
						v.Set((_struct$6 = reflect.ValueOf(new Go$String(go$bytesToString(s$1))), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
					} else {
						d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
					}
				} else {
					d.saveError(new UnmarshalTypeError.Ptr("string", v.Type()));
				}
			}
		} else {
			if (!((c === 45)) && (c < 48 || c > 57)) {
				if (fromQuoted) {
					d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
				} else {
					d.error(errPhase);
				}
			}
			s$2 = go$bytesToString(item);
			_ref$4 = v.Kind();
			switch (undefined) {
			default:
				if (_ref$4 === 20) {
					_tuple$4 = d.convertNumber(s$2), n$1 = _tuple$4[0], err$3 = _tuple$4[1];
					if (!(go$interfaceIsEqual(err$3, null))) {
						d.saveError(err$3);
						break;
					}
					if (!((v.NumMethod() === 0))) {
						d.saveError(new UnmarshalTypeError.Ptr("number", v.Type()));
						break;
					}
					v.Set((_struct$7 = reflect.ValueOf(n$1), new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)));
				} else if (_ref$4 === 2 || _ref$4 === 3 || _ref$4 === 4 || _ref$4 === 5 || _ref$4 === 6) {
					_tuple$5 = strconv.ParseInt(s$2, 10, 64), n$2 = _tuple$5[0], err$4 = _tuple$5[1];
					if (!(go$interfaceIsEqual(err$4, null)) || v.OverflowInt(n$2)) {
						d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
						break;
					}
					v.SetInt(n$2);
				} else if (_ref$4 === 7 || _ref$4 === 8 || _ref$4 === 9 || _ref$4 === 10 || _ref$4 === 11 || _ref$4 === 12) {
					_tuple$6 = strconv.ParseUint(s$2, 10, 64), n$3 = _tuple$6[0], err$5 = _tuple$6[1];
					if (!(go$interfaceIsEqual(err$5, null)) || v.OverflowUint(n$3)) {
						d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
						break;
					}
					v.SetUint(n$3);
				} else if (_ref$4 === 13 || _ref$4 === 14) {
					_tuple$7 = strconv.ParseFloat(s$2, v.Type().Bits()), n$4 = _tuple$7[0], err$6 = _tuple$7[1];
					if (!(go$interfaceIsEqual(err$6, null)) || v.OverflowFloat(n$4)) {
						d.saveError(new UnmarshalTypeError.Ptr("number " + s$2, v.Type()));
						break;
					}
					v.SetFloat(n$4);
				} else {
					if ((v.Kind() === 24) && go$interfaceIsEqual(v.Type(), numberType)) {
						v.SetString(s$2);
						break;
					}
					if (fromQuoted) {
						d.error(fmt.Errorf("json: invalid use of ,string struct tag, trying to unmarshal %q into %v", new (go$sliceType(go$emptyInterface))([item, v.Type()])));
					} else {
						d.error(new UnmarshalTypeError.Ptr("number", v.Type()));
					}
				}
			}
		}
	};
	decodeState.prototype.literalStore = function(item, v, fromQuoted) { return this.go$val.literalStore(item, v, fromQuoted); };
0ÇvalueInterfaceÇ˚	decodeState.Ptr.prototype.valueInterface = function() {
		var d, _ref;
		d = this;
		_ref = d.scanWhile(9);
		if (_ref === 6) {
			return d.arrayInterface();
		} else if (_ref === 2) {
			return new (go$mapType(Go$String, go$emptyInterface))(d.objectInterface());
		} else if (_ref === 1) {
			return d.literalInterface();
		} else {
			d.error(errPhase);
			throw go$panic(new Go$String("unreachable"));
		}
	};
	decodeState.prototype.valueInterface = function() { return this.go$val.valueInterface(); };
0Ç>arrayInterfaceÇ*	decodeState.Ptr.prototype.arrayInterface = function() {
		var d, v, op;
		d = this;
		v = (go$sliceType(go$emptyInterface)).make(0, 0, function() { return null; });
		while (true) {
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			d.off = d.off - 1 >> 0;
			d.scan.undo(op);
			v = go$append(v, d.valueInterface());
			op = d.scanWhile(9);
			if (op === 8) {
				break;
			}
			if (!((op === 7))) {
				d.error(errPhase);
			}
		}
		return v;
	};
	decodeState.prototype.arrayInterface = function() { return this.go$val.arrayInterface(); };
0Ç¥objectInterfaceÇü	decodeState.Ptr.prototype.objectInterface = function() {
		var d, m, op, start, item, _tuple, key, ok, _key;
		d = this;
		m = new Go$Map();
		while (true) {
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 1))) {
				d.error(errPhase);
			}
			start = d.off - 1 >> 0;
			op = d.scanWhile(0);
			item = go$subslice(d.data, start, (d.off - 1 >> 0));
			_tuple = unquote(item), key = _tuple[0], ok = _tuple[1];
			if (!ok) {
				d.error(errPhase);
			}
			if (op === 9) {
				op = d.scanWhile(9);
			}
			if (!((op === 3))) {
				d.error(errPhase);
			}
			_key = key, (m || go$throwRuntimeError("assignment to entry in nil map"))[_key] = { k: _key, v: d.valueInterface() };
			op = d.scanWhile(9);
			if (op === 5) {
				break;
			}
			if (!((op === 4))) {
				d.error(errPhase);
			}
		}
		return m;
	};
	decodeState.prototype.objectInterface = function() { return this.go$val.objectInterface(); };
0ÇgliteralInterfaceÇQ	decodeState.Ptr.prototype.literalInterface = function() {
		var d, start, op, item, _slice, _index, c, _ref, _tuple, s, ok, _tuple$1, n, err;
		d = this;
		start = d.off - 1 >> 0;
		op = d.scanWhile(0);
		d.off = d.off - 1 >> 0;
		d.scan.undo(op);
		item = go$subslice(d.data, start, d.off);
		c = (_slice = item, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_ref = c;
		if (_ref === 110) {
			return null;
		} else if (_ref === 116 || _ref === 102) {
			return new Go$Bool((c === 116));
		} else if (_ref === 34) {
			_tuple = unquote(item), s = _tuple[0], ok = _tuple[1];
			if (!ok) {
				d.error(errPhase);
			}
			return new Go$String(s);
		} else {
			if (!((c === 45)) && (c < 48 || c > 57)) {
				d.error(errPhase);
			}
			_tuple$1 = d.convertNumber(go$bytesToString(item)), n = _tuple$1[0], err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				d.saveError(err);
			}
			return n;
		}
	};
	decodeState.prototype.literalInterface = function() { return this.go$val.literalInterface(); };
0Ç©getu4Çû	var getu4 = function(s) {
		var _slice, _index, _slice$1, _index$1, _tuple, r, err;
		if (s.length < 6 || !(((_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 92)) || !(((_slice$1 = s, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 117))) {
			return -1;
		}
		_tuple = strconv.ParseUint(go$bytesToString(go$subslice(s, 2, 6)), 16, 64), r = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return -1;
		}
		return (r.low >> 0);
	};
0Å¬unquoteÅ∂	var unquote = function(s) {
		var t, ok, _tuple;
		t = "";
		ok = false;
		_tuple = unquoteBytes(s), s = _tuple[0], ok = _tuple[1];
		t = go$bytesToString(s);
		return [t, ok];
	};
0ÇıunquoteBytesÇ„	var unquoteBytes = function(s) {
		var t, ok, _slice, _index, _slice$1, _index$1, r, _slice$2, _index$2, c, _tuple, rr, size, _tuple$1, b, w, x, x$1, nb, _slice$3, _index$3, c$1, _ref, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, _slice$11, _index$11, rr$1, rr1, dec, _slice$12, _index$12, _tuple$2, rr$2, size$1, _tuple$3;
		t = (go$sliceType(Go$Uint8)).nil;
		ok = false;
		if (s.length < 2 || !(((_slice = s, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 34)) || !(((_slice$1 = s, _index$1 = (s.length - 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 34))) {
			return [t, ok];
		}
		s = go$subslice(s, 1, (s.length - 1 >> 0));
		r = 0;
		while (r < s.length) {
			c = (_slice$2 = s, _index$2 = r, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			if ((c === 92) || (c === 34) || c < 32) {
				break;
			}
			if (c < 128) {
				r = r + 1 >> 0;
				continue;
			}
			_tuple = utf8.DecodeRune(go$subslice(s, r)), rr = _tuple[0], size = _tuple[1];
			if ((rr === 65533) && (size === 1)) {
				break;
			}
			r = r + (size) >> 0;
		}
		if (r === s.length) {
			_tuple$1 = [s, true], t = _tuple$1[0], ok = _tuple$1[1];
			return [t, ok];
		}
		b = (go$sliceType(Go$Uint8)).make(s.length + 8 >> 0, 0, function() { return 0; });
		w = go$copySlice(b, go$subslice(s, 0, r));
		while (r < s.length) {
			if (w >= (b.length - 8 >> 0)) {
				nb = (go$sliceType(Go$Uint8)).make((x = (b.length + 4 >> 0), x$1 = 2, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0), 0, function() { return 0; });
				go$copySlice(nb, go$subslice(b, 0, w));
				b = nb;
			}
			c$1 = (_slice$3 = s, _index$3 = r, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			if (c$1 === 92) {
				r = r + 1 >> 0;
				if (r >= s.length) {
					return [t, ok];
				}
				_ref = (_slice$4 = s, _index$4 = r, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
				switch (undefined) {
				default:
					if (_ref === 34 || _ref === 92 || _ref === 47 || _ref === 39) {
						_slice$6 = b, _index$6 = w, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = (_slice$5 = s, _index$5 = r, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 98) {
						_slice$7 = b, _index$7 = w, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = 8) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 102) {
						_slice$8 = b, _index$8 = w, (_index$8 >= 0 && _index$8 < _slice$8.length) ? (_slice$8.array[_slice$8.offset + _index$8] = 12) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 110) {
						_slice$9 = b, _index$9 = w, (_index$9 >= 0 && _index$9 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$9] = 10) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 114) {
						_slice$10 = b, _index$10 = w, (_index$10 >= 0 && _index$10 < _slice$10.length) ? (_slice$10.array[_slice$10.offset + _index$10] = 13) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 116) {
						_slice$11 = b, _index$11 = w, (_index$11 >= 0 && _index$11 < _slice$11.length) ? (_slice$11.array[_slice$11.offset + _index$11] = 9) : go$throwRuntimeError("index out of range");
						r = r + 1 >> 0;
						w = w + 1 >> 0;
					} else if (_ref === 117) {
						r = r - 1 >> 0;
						rr$1 = getu4(go$subslice(s, r));
						if (rr$1 < 0) {
							return [t, ok];
						}
						r = r + 6 >> 0;
						if (utf16.IsSurrogate(rr$1)) {
							rr1 = getu4(go$subslice(s, r));
							if (dec = utf16.DecodeRune(rr$1, rr1), !((dec === 65533))) {
								r = r + 6 >> 0;
								w = w + (utf8.EncodeRune(go$subslice(b, w), dec)) >> 0;
								break;
							}
							rr$1 = 65533;
						}
						w = w + (utf8.EncodeRune(go$subslice(b, w), rr$1)) >> 0;
					} else {
						return [t, ok];
					}
				}
			} else if (c$1 === 34 || c$1 < 32) {
				return [t, ok];
			} else if (c$1 < 128) {
				_slice$12 = b, _index$12 = w, (_index$12 >= 0 && _index$12 < _slice$12.length) ? (_slice$12.array[_slice$12.offset + _index$12] = c$1) : go$throwRuntimeError("index out of range");
				r = r + 1 >> 0;
				w = w + 1 >> 0;
			} else {
				_tuple$2 = utf8.DecodeRune(go$subslice(s, r)), rr$2 = _tuple$2[0], size$1 = _tuple$2[1];
				r = r + (size$1) >> 0;
				w = w + (utf8.EncodeRune(go$subslice(b, w), rr$2)) >> 0;
			}
		}
		_tuple$3 = [go$subslice(b, 0, w), true], t = _tuple$3[0], ok = _tuple$3[1];
		return [t, ok];
	};
0ÇRMarshalÇE	var Marshal = go$pkg.Marshal = function(v) {
		var e, err;
		e = new encodeState.Ptr(new bytes.Buffer.Ptr(), go$makeNativeArray("Uint8", 64, function() { return 0; }));
		err = e.marshal(v);
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		return [e.Buffer.Bytes(), null];
	};
0Ç’MarshalIndentÇ¬	var MarshalIndent = go$pkg.MarshalIndent = function(v, prefix, indent) {
		var _tuple, b, err, buf;
		_tuple = Marshal(v), b = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		buf = new bytes.Buffer.Ptr();
		err = Indent(buf, b, prefix, indent);
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(Go$Uint8)).nil, err];
		}
		return [buf.Bytes(), null];
	};
0ÇA
HTMLEscapeÇ1	var HTMLEscape = go$pkg.HTMLEscape = function(dst, src) {
		var start, _ref, _i, _slice, _index, c, i, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		start = 0;
		_ref = src;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if ((c === 60) || (c === 62) || (c === 38)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u00");
				dst.WriteByte(hex.charCodeAt((c >>> 4 << 24 >>> 24)));
				dst.WriteByte(hex.charCodeAt(((c & 15) >>> 0)));
				start = i + 1 >> 0;
			}
			if ((c === 226) && (i + 2 >> 0) < src.length && ((_slice$1 = src, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 128) && (((_slice$2 = src, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) & ~1) === 168)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u202");
				dst.WriteByte(hex.charCodeAt((((_slice$3 = src, _index$3 = (i + 2 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) & 15) >>> 0)));
				start = i + 3 >> 0;
			}
		}
		if (start < src.length) {
			dst.Write(go$subslice(src, start));
		}
	};
0ÅÁErrorÅ›	UnsupportedTypeError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: unsupported type: " + e.Type.String();
	};
	UnsupportedTypeError.prototype.Error = function() { return this.go$val.Error(); };
0Å‡ErrorÅ÷	UnsupportedValueError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: unsupported value: " + e.Str;
	};
	UnsupportedValueError.prototype.Error = function() { return this.go$val.Error(); };
0ÅÈErrorÅﬂ	InvalidUTF8Error.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: invalid UTF-8 in string: " + strconv.Quote(e.S);
	};
	InvalidUTF8Error.prototype.Error = function() { return this.go$val.Error(); };
0ÇErrorÅ˘	MarshalerError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return "json: error calling MarshalJSON for type " + e.Type.String() + ": " + e.Err.Error();
	};
	MarshalerError.prototype.Error = function() { return this.go$val.Error(); };
0Å∑newEncodeStateÅ§	var newEncodeState = function() {
			var e = encodeStates.pop();
			if (e !== undefined) {
				e.Reset();
				return e;
			}
			return new encodeState.Ptr();
		};
0TputEncodeStateB	var putEncodeState = function(e) {
			encodeStates.push(e);
		};
0ÇvmarshalÇi	encodeState.Ptr.prototype.marshal = function(v) {
		var err, e, _struct;
		err = null;
		var go$deferred = [];
		try {
			e = this;
			go$deferred.push({ fun: (function() {
				var r, ok, _tuple, ok$1, _tuple$1, s;
				if (r = go$recover(), !(go$interfaceIsEqual(r, null))) {
					if (_tuple = (r !== null && runtime.Error.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), ok = _tuple[1], ok) {
						throw go$panic(r);
					}
					if (_tuple$1 = (r !== null && r.constructor === Go$String ? [r.go$val, true] : ["", false]), s = _tuple$1[0], ok$1 = _tuple$1[1], ok$1) {
						throw go$panic(new Go$String(s));
					}
					err = (r !== null && go$error.implementedBy.indexOf(r.constructor) !== -1 ? r : go$typeAssertionFailed(r, go$error));
				}
			}), args: [] });
			e.reflectValue((_struct = reflect.ValueOf(v), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
			err = null;
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
	encodeState.prototype.marshal = function(v) { return this.go$val.marshal(v); };
0ÅæerrorÅ¥	encodeState.Ptr.prototype.error = function(err) {
		var e;
		e = this;
		throw go$panic(err);
	};
	encodeState.prototype.error = function(err) { return this.go$val.error(err); };
0Ç≤isEmptyValueÇ†	var isEmptyValue = function(v) {
		var _ref, x, x$1;
		_ref = v.Kind();
		if (_ref === 17 || _ref === 21 || _ref === 23 || _ref === 24) {
			return v.Len() === 0;
		} else if (_ref === 1) {
			return !v.Bool();
		} else if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			return (x = v.Int(), (x.high === 0 && x.low === 0));
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			return (x$1 = v.Uint(), (x$1.high === 0 && x$1.low === 0));
		} else if (_ref === 13 || _ref === 14) {
			return v.Float() === 0;
		} else if (_ref === 20 || _ref === 22) {
			return v.IsNil();
		}
		return false;
	};
0ÇêreflectValueÇ~	encodeState.Ptr.prototype.reflectValue = function(v) {
		var e, _struct, _struct$1;
		e = this;
		valueEncoder((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)))(e, (_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), false);
	};
	encodeState.prototype.reflectValue = function(v) { return this.go$val.reflectValue(v); };
0ÅèvalueEncoder	var valueEncoder = function(v) {
		if (!v.IsValid()) {
			return invalidValueEncoder;
		}
		return typeEncoder(v.Type());
	};
0ÇAtypeEncoderÇ0	var typeEncoder = function(t) {
		var _entry, f, wg, _key, _key$1;
		encoderCache.RWMutex.RLock();
		f = (_entry = encoderCache.m[(t || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : go$throwNilPointerError);
		encoderCache.RWMutex.RUnlock();
		if (!(f === go$throwNilPointerError)) {
			return f;
		}
		encoderCache.RWMutex.Lock();
		if (encoderCache.m === false) {
			encoderCache.m = new Go$Map();
		}
		wg = new sync.WaitGroup.Ptr();
		wg.Add(1);
		_key = t, (encoderCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: (function(e, v, quoted) {
			var _struct;
			wg.Wait();
			f(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), quoted);
		}) };
		encoderCache.RWMutex.Unlock();
		f = newTypeEncoder(t, true);
		wg.Done();
		encoderCache.RWMutex.Lock();
		_key$1 = t, (encoderCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key$1 || go$interfaceNil).go$key()] = { k: _key$1, v: f };
		encoderCache.RWMutex.Unlock();
		return f;
	};
0Ç®newTypeEncoderÇî	var newTypeEncoder = function(t, allowAddr) {
		var _ref;
		if (t.Implements(marshalerType)) {
			return marshalerEncoder;
		}
		if (!((t.Kind() === 22)) && allowAddr) {
			if (reflect.PtrTo(t).Implements(marshalerType)) {
				return newCondAddrEncoder(addrMarshalerEncoder, newTypeEncoder(t, false));
			}
		}
		if (t.Implements(textMarshalerType)) {
			return textMarshalerEncoder;
		}
		if (!((t.Kind() === 22)) && allowAddr) {
			if (reflect.PtrTo(t).Implements(textMarshalerType)) {
				return newCondAddrEncoder(addrTextMarshalerEncoder, newTypeEncoder(t, false));
			}
		}
		_ref = t.Kind();
		if (_ref === 1) {
			return boolEncoder;
		} else if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			return intEncoder;
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			return uintEncoder;
		} else if (_ref === 13) {
			return float32Encoder;
		} else if (_ref === 14) {
			return float64Encoder;
		} else if (_ref === 24) {
			return stringEncoder;
		} else if (_ref === 20) {
			return interfaceEncoder;
		} else if (_ref === 25) {
			return newStructEncoder(t);
		} else if (_ref === 21) {
			return newMapEncoder(t);
		} else if (_ref === 23) {
			return newSliceEncoder(t);
		} else if (_ref === 17) {
			return newArrayEncoder(t);
		} else if (_ref === 22) {
			return newPtrEncoder(t);
		} else {
			return unsupportedTypeEncoder;
		}
	};
0oinvalidValueEncoderX	var invalidValueEncoder = function(e, v, quoted) {
		e.Buffer.WriteString("null");
	};
0Ç;marshalerEncoderÇ%	var marshalerEncoder = function(e, v, quoted) {
		var x, m, _tuple, b, err;
		if ((v.Kind() === 22) && v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = v.Interface(), (x !== null && Marshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, Marshaler)));
		_tuple = m.MarshalJSON(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			err = compact(e.Buffer, b, true);
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
0ÇôaddrMarshalerEncoderÇ	var addrMarshalerEncoder = function(e, v, quoted) {
		var _struct, va, x, m, _tuple, b, err;
		va = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (va.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = va.Interface(), (x !== null && Marshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, Marshaler)));
		_tuple = m.MarshalJSON(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			err = compact(e.Buffer, b, true);
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
0ÇutextMarshalerEncoderÇ[	var textMarshalerEncoder = function(e, v, quoted) {
		var x, m, _tuple, b, err, _tuple$1;
		if ((v.Kind() === 22) && v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = v.Interface(), (x !== null && encoding.TextMarshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, encoding.TextMarshaler)));
		_tuple = m.MarshalText(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			_tuple$1 = e.stringBytes(b), err = _tuple$1[1];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
0Ç”addrTextMarshalerEncoderÇµ	var addrTextMarshalerEncoder = function(e, v, quoted) {
		var _struct, va, x, m, _tuple, b, err, _tuple$1;
		va = (_struct = v.Addr(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (va.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		m = (x = va.Interface(), (x !== null && encoding.TextMarshaler.implementedBy.indexOf(x.constructor) !== -1 ? x : go$typeAssertionFailed(x, encoding.TextMarshaler)));
		_tuple = m.MarshalText(), b = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			_tuple$1 = e.stringBytes(b), err = _tuple$1[1];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			e.error(new MarshalerError.Ptr(v.Type(), err));
		}
	};
0ÇboolEncoderÅÚ	var boolEncoder = function(e, v, quoted) {
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		if (v.Bool()) {
			e.Buffer.WriteString("true");
		} else {
			e.Buffer.WriteString("false");
		}
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
0Ç
intEncoderÇ	var intEncoder = function(e, v, quoted) {
		var b;
		b = strconv.AppendInt(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), v.Int(), 10);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
0Ç!uintEncoderÇ	var uintEncoder = function(e, v, quoted) {
		var b;
		b = strconv.AppendUint(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), v.Uint(), 10);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
0ÇÀencodeÇø	floatEncoder.prototype.encode = function(e, v, quoted) {
		var bits, f, _struct, b;
		bits = this.go$val;
		f = v.Float();
		if (math.IsInf(f, 0) || math.IsNaN(f)) {
			e.error(new UnsupportedValueError.Ptr((_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), strconv.FormatFloat(f, 103, -1, (bits >> 0))));
		}
		b = strconv.AppendFloat(go$subslice(new (go$sliceType(Go$Uint8))(e.scratch), 0, 0), f, 103, -1, (bits >> 0));
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
		e.Buffer.Write(b);
		if (quoted) {
			e.Buffer.WriteByte(34);
		}
	};
	go$ptrType(floatEncoder).prototype.encode = function(e, v, quoted) { return new floatEncoder(this.go$get()).encode(e, v, quoted); };
0Ç˝stringEncoderÇÍ	var stringEncoder = function(e, v, quoted) {
		var numStr, _tuple, sb, err;
		if (go$interfaceIsEqual(v.Type(), numberType)) {
			numStr = v.String();
			if (numStr === "") {
				numStr = "0";
			}
			e.Buffer.WriteString(numStr);
			return;
		}
		if (quoted) {
			_tuple = Marshal(new Go$String(v.String())), sb = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				e.error(err);
			}
			e.string(go$bytesToString(sb));
		} else {
			e.string(v.String());
		}
	};
0ÇinterfaceEncoderÅÓ	var interfaceEncoder = function(e, v, quoted) {
		var _struct;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		e.reflectValue((_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
	};
0ÅàunsupportedTypeEncodern	var unsupportedTypeEncoder = function(e, v, quoted) {
		e.error(new UnsupportedTypeError.Ptr(v.Type()));
	};
0ÇÛencodeÇÁ	structEncoder.Ptr.prototype.encode = function(e, v, quoted) {
		var se, first, _ref, _i, _slice, _index, _struct, f, i, _struct$1, _struct$2, fv, _struct$3, _slice$1, _index$1, _struct$4;
		se = this;
		e.Buffer.WriteByte(123);
		first = true;
		_ref = se.fields;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			fv = (_struct$2 = fieldByIndex((_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), f.index), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
			if (!fv.IsValid() || f.omitEmpty && isEmptyValue((_struct$3 = fv, new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)))) {
				continue;
			}
			if (first) {
				first = false;
			} else {
				e.Buffer.WriteByte(44);
			}
			e.string(f.name);
			e.Buffer.WriteByte(58);
			(_slice$1 = se.fieldEncs, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))(e, (_struct$4 = fv, new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), f.quoted);
		}
		e.Buffer.WriteByte(125);
	};
	structEncoder.prototype.encode = function(e, v, quoted) { return this.go$val.encode(e, v, quoted); };
0ÇÁnewStructEncoderÇ—	var newStructEncoder = function(t) {
		var fields, se, _ref, _i, _slice, _index, _struct, f, i, _slice$1, _index$1, e, v, quoted, _recv;
		fields = cachedTypeFields(t);
		se = new structEncoder.Ptr(fields, (go$sliceType(encoderFunc)).make(fields.length, 0, function() { return go$throwNilPointerError; }));
		_ref = fields;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			_slice$1 = se.fieldEncs, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = typeEncoder(typeByIndex(t, f.index))) : go$throwRuntimeError("index out of range");
		}
		return (_recv = se, function(e, v, quoted) { return _recv.encode(e, v, quoted); });
	};
0ÇaencodeÇU	mapEncoder.Ptr.prototype.encode = function(e, v, param) {
		var me, x, sv, _ref, _i, _slice, _index, _struct, k, i, _struct$1, _struct$2;
		me = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		e.Buffer.WriteByte(123);
		sv = (x = v.MapKeys(), go$subslice(new stringValues(x.array), x.offset, x.offset + x.length));
		sort.Sort(sv);
		_ref = sv;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			k = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			i = _i;
			if (i > 0) {
				e.Buffer.WriteByte(44);
			}
			e.string(k.String());
			e.Buffer.WriteByte(58);
			me.elemEnc(e, (_struct$2 = v.MapIndex((_struct$1 = k, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), false);
		}
		e.Buffer.WriteByte(125);
	};
	mapEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
0Ç"newMapEncoderÇ	var newMapEncoder = function(t) {
		var me, e, v, _$2, _recv;
		if (!((t.Key().Kind() === 24))) {
			return unsupportedTypeEncoder;
		}
		me = new mapEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = me, function(e, v, _$2) { return _recv.encode(e, v, _$2); });
	};
0ÇencodeByteSliceÇˆ	var encodeByteSlice = function(e, v, param) {
		var s, dst, enc;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		s = v.Bytes();
		e.Buffer.WriteByte(34);
		if (s.length < 1024) {
			dst = (go$sliceType(Go$Uint8)).make(base64.StdEncoding.EncodedLen(s.length), 0, function() { return 0; });
			base64.StdEncoding.Encode(dst, s);
			e.Buffer.Write(dst);
		} else {
			enc = base64.NewEncoder(base64.StdEncoding, e);
			enc.Write(s);
			enc.Close();
		}
		e.Buffer.WriteByte(34);
	};
0Ç{encodeÇo	sliceEncoder.Ptr.prototype.encode = function(e, v, param) {
		var se, _struct;
		se = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		se.arrayEnc(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	sliceEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
0ÇnewSliceEncoderÇ	var newSliceEncoder = function(t) {
		var enc, e, v, _$2, _recv;
		if (t.Elem().Kind() === 8) {
			return encodeByteSlice;
		}
		enc = new sliceEncoder.Ptr(newArrayEncoder(t));
		return (_recv = enc, function(e, v, _$2) { return _recv.encode(e, v, _$2); });
	};
0ÇÌencodeÇ·	arrayEncoder.Ptr.prototype.encode = function(e, v, param) {
		var ae, n, i, _struct;
		ae = this;
		e.Buffer.WriteByte(91);
		n = v.Len();
		i = 0;
		while (i < n) {
			if (i > 0) {
				e.Buffer.WriteByte(44);
			}
			ae.elemEnc(e, (_struct = v.Index(i), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
			i = i + 1 >> 0;
		}
		e.Buffer.WriteByte(93);
	};
	arrayEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
0Å‡newArrayEncoderÅÃ	var newArrayEncoder = function(t) {
		var enc, e, v, _$2, _recv;
		enc = new arrayEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = enc, function(e, v, _$2) { return _recv.encode(e, v, _$2); });
	};
0Ç}encodeÇq	ptrEncoder.Ptr.prototype.encode = function(e, v, param) {
		var pe, _struct;
		pe = this;
		if (v.IsNil()) {
			e.Buffer.WriteString("null");
			return;
		}
		pe.elemEnc(e, (_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
	};
	ptrEncoder.prototype.encode = function(e, v, param) { return this.go$val.encode(e, v, param); };
0Å⁄newPtrEncoderÅ»	var newPtrEncoder = function(t) {
		var enc, e, v, _$2, _recv;
		enc = new ptrEncoder.Ptr(typeEncoder(t.Elem()));
		return (_recv = enc, function(e, v, _$2) { return _recv.encode(e, v, _$2); });
	};
0Ç‰encodeÇÿ	condAddrEncoder.Ptr.prototype.encode = function(e, v, quoted) {
		var ce, _struct, _struct$1;
		ce = this;
		if (v.CanAddr()) {
			ce.canAddrEnc(e, (_struct = v, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), quoted);
		} else {
			ce.elseEnc(e, (_struct$1 = v, new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), quoted);
		}
	};
	condAddrEncoder.prototype.encode = function(e, v, quoted) { return this.go$val.encode(e, v, quoted); };
0ÇnewCondAddrEncoderÅÎ	var newCondAddrEncoder = function(canAddrEnc, elseEnc) {
		var enc, e, v, quoted, _recv;
		enc = new condAddrEncoder.Ptr(canAddrEnc, elseEnc);
		return (_recv = enc, function(e, v, quoted) { return _recv.encode(e, v, quoted); });
	};
0Ç¢
isValidTagÇí	var isValidTag = function(s) {
		var _ref, _i, _rune, c;
		if (s === "") {
			return false;
		}
		_ref = s;
		_i = 0;
		for (; _i < _ref.length; _i += _rune[1]) {
			_rune = go$decodeRune(_ref, _i);
			c = _rune[0];
			if (strings.ContainsRune("!#$%&()*+-./:<=>?@[]^_{|}~ ", c)) {
			} else {
				if (!unicode.IsLetter(c) && !unicode.IsDigit(c)) {
					return false;
				}
			}
		}
		return true;
	};
0ÇfieldByIndexÇ˚	var fieldByIndex = function(v, index) {
		var _ref, _i, _slice, _index, i, _struct, _struct$1, _struct$2;
		_ref = index;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (v.Kind() === 22) {
				if (v.IsNil()) {
					return new reflect.Value.Ptr((go$ptrType(reflect.rtype)).nil, 0, 0);
				}
				v = (_struct = v.Elem(), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			}
			v = (_struct$1 = v.Field(i), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		}
		return (_struct$2 = v, new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
	};
0ÇõtypeByIndexÇä	var typeByIndex = function(t, index) {
		var _ref, _i, _slice, _index, i;
		_ref = index;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (t.Kind() === 22) {
				t = t.Elem();
			}
			t = t.Field(i).Type;
		}
		return t;
	};
0Å∏LenÅ∞	stringValues.prototype.Len = function() {
		var sv;
		sv = this;
		return sv.length;
	};
	go$ptrType(stringValues).prototype.Len = function() { return this.go$get().Len(); };
0ÇpSwapÇf	stringValues.prototype.Swap = function(i, j) {
		var sv, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		sv = this;
		_tuple = [(_struct = (_slice = sv, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)), (_struct$1 = (_slice$1 = sv, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))], _slice$2 = sv, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = sv, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(stringValues).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
0Å‘LessÅÀ	stringValues.prototype.Less = function(i, j) {
		var sv;
		sv = this;
		return sv.get(i) < sv.get(j);
	};
	go$ptrType(stringValues).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
0ÇbgetÇY	stringValues.prototype.get = function(i) {
		var sv, _slice, _index;
		sv = this;
		return (_slice = sv, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).String();
	};
	go$ptrType(stringValues).prototype.get = function(i) { return this.go$get().get(i); };
0ÇstringÇ	encodeState.Ptr.prototype.string = function(s) {
		var e, len0, start, i, b, _ref, _tuple, c, size;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (i < s.length) {
			if (b = s.charCodeAt(i), b < 128) {
				if (32 <= b && !((b === 92)) && !((b === 34)) && !((b === 60)) && !((b === 62)) && !((b === 38))) {
					i = i + 1 >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				_ref = b;
				if (_ref === 92 || _ref === 34) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_ref === 10) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_ref === 13) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + 1 >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRuneInString(s.substring(i)), c = _tuple[0], size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.WriteString(s.substring(start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.length) {
			e.Buffer.WriteString(s.substring(start));
		}
		e.Buffer.WriteByte(34);
		return [e.Buffer.Len() - len0 >> 0, null];
	};
	encodeState.prototype.string = function(s) { return this.go$val.string(s); };
0Ç∑stringBytesÇ¶	encodeState.Ptr.prototype.stringBytes = function(s) {
		var e, len0, start, i, b, _slice, _index, _ref, _tuple, c, size;
		e = this;
		len0 = e.Buffer.Len();
		e.Buffer.WriteByte(34);
		start = 0;
		i = 0;
		while (i < s.length) {
			if (b = (_slice = s, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), b < 128) {
				if (32 <= b && !((b === 92)) && !((b === 34)) && !((b === 60)) && !((b === 62)) && !((b === 38))) {
					i = i + 1 >> 0;
					continue;
				}
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				_ref = b;
				if (_ref === 92 || _ref === 34) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(b);
				} else if (_ref === 10) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(110);
				} else if (_ref === 13) {
					e.Buffer.WriteByte(92);
					e.Buffer.WriteByte(114);
				} else {
					e.Buffer.WriteString("\\u00");
					e.Buffer.WriteByte(hex.charCodeAt((b >>> 4 << 24 >>> 24)));
					e.Buffer.WriteByte(hex.charCodeAt(((b & 15) >>> 0)));
				}
				i = i + 1 >> 0;
				start = i;
				continue;
			}
			_tuple = utf8.DecodeRune(go$subslice(s, i)), c = _tuple[0], size = _tuple[1];
			if ((c === 65533) && (size === 1)) {
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				e.Buffer.WriteString("\\ufffd");
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			if ((c === 8232) || (c === 8233)) {
				if (start < i) {
					e.Buffer.Write(go$subslice(s, start, i));
				}
				e.Buffer.WriteString("\\u202");
				e.Buffer.WriteByte(hex.charCodeAt((c & 15)));
				i = i + (size) >> 0;
				start = i;
				continue;
			}
			i = i + (size) >> 0;
		}
		if (start < s.length) {
			e.Buffer.Write(go$subslice(s, start));
		}
		e.Buffer.WriteByte(34);
		return [e.Buffer.Len() - len0 >> 0, null];
	};
	encodeState.prototype.stringBytes = function(s) { return this.go$val.stringBytes(s); };
0Å©LenÅ°	byName.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byName).prototype.Len = function() { return this.go$get().Len(); };
0Ç∏SwapÇÆ	byName.prototype.Swap = function(i, j) {
		var x, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_struct = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted)), (_struct$1 = (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byName).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
0Ç	®LessÇ	û	byName.prototype.Less = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10;
		x = this;
		if (!((_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).name === (_slice$1 = x, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).name)) {
			return (_slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).name < (_slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).name;
		}
		if (!(((_slice$4 = x, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).index.length === (_slice$5 = x, _index$5 = j, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).index.length))) {
			return (_slice$6 = x, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).index.length < (_slice$7 = x, _index$7 = j, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).index.length;
		}
		if (!((_slice$8 = x, _index$8 = i, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).tag === (_slice$9 = x, _index$9 = j, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")).tag)) {
			return (_slice$10 = x, _index$10 = i, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")).tag;
		}
		return go$subslice(new byIndex(x.array), x.offset, x.offset + x.length).Less(i, j);
	};
	go$ptrType(byName).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
0Å´LenÅ£	byIndex.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byIndex).prototype.Len = function() { return this.go$get().Len(); };
0Ç∫SwapÇ∞	byIndex.prototype.Swap = function(i, j) {
		var x, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_struct = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted)), (_struct$1 = (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byIndex).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
0ÇLessÇ	byIndex.prototype.Less = function(i, j) {
		var x, _ref, _slice, _index, _i, _slice$1, _index$1, xik, k, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8;
		x = this;
		_ref = (_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).index;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			xik = (_slice$1 = _ref, _index$1 = _i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			k = _i;
			if (k >= (_slice$2 = x, _index$2 = j, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).index.length) {
				return false;
			}
			if (!((xik === (_slice$3 = (_slice$4 = x, _index$4 = j, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).index, _index$3 = k, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))))) {
				return xik < (_slice$5 = (_slice$6 = x, _index$6 = j, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).index, _index$5 = k, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
			}
		}
		return (_slice$7 = x, _index$7 = i, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).index.length < (_slice$8 = x, _index$8 = j, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).index.length;
	};
	go$ptrType(byIndex).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
0Çq
typeFieldsÇa	var typeFields = function(t) {
		var current, next, _map, _key, count, _map$1, _key$1, nextCount, _map$2, _key$2, visited, fields, _tuple, _map$3, _key$3, _tuple$1, _ref, _i, _slice, _index, _struct, f, _entry, _key$4, i, _struct$1, sf, tag, _tuple$2, name, opts, index, _slice$1, _index$1, ft, tagged, _entry$1, _slice$2, _index$2, _struct$2, _lhs, _index$3, _entry$2, _key$5, _entry$3, out, _tuple$3, advance, i$1, _slice$3, _index$4, _struct$3, fi, name$1, _slice$4, _index$5, _struct$4, fj, _struct$5, _tuple$4, _struct$6, dominant, ok, _struct$7;
		current = new (go$sliceType(field))([]);
		next = new (go$sliceType(field))([new field.Ptr("", false, (go$sliceType(Go$Int)).nil, t, false, false)]);
		count = (_map = new Go$Map(), _map);
		nextCount = (_map$1 = new Go$Map(), _map$1);
		visited = (_map$2 = new Go$Map(), _map$2);
		fields = (go$sliceType(field)).nil;
		while (next.length > 0) {
			_tuple = [next, go$subslice(current, 0, 0)], current = _tuple[0], next = _tuple[1];
			_tuple$1 = [nextCount, (_map$3 = new Go$Map(), _map$3)], count = _tuple$1[0], nextCount = _tuple$1[1];
			_ref = current;
			_i = 0;
			for (; _i < _ref.length; _i += 1) {
				f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
				if ((_entry = visited[(f.typ || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : false)) {
					continue;
				}
				_key$4 = f.typ, (visited || go$throwRuntimeError("assignment to entry in nil map"))[(_key$4 || go$interfaceNil).go$key()] = { k: _key$4, v: true };
				i = 0;
				while (i < f.typ.NumField()) {
					sf = (_struct$1 = f.typ.Field(i), new reflect.StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
					if (!(sf.PkgPath === "")) {
						i = i + 1 >> 0;
						continue;
					}
					tag = (new reflect.StructTag(sf.Tag)).Get("json");
					if (tag === "-") {
						i = i + 1 >> 0;
						continue;
					}
					_tuple$2 = parseTag(tag), name = _tuple$2[0], opts = _tuple$2[1];
					if (!isValidTag(name)) {
						name = "";
					}
					index = (go$sliceType(Go$Int)).make(f.index.length + 1 >> 0, 0, function() { return 0; });
					go$copySlice(index, f.index);
					_slice$1 = index, _index$1 = f.index.length, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = i) : go$throwRuntimeError("index out of range");
					ft = sf.Type;
					if (ft.Name() === "" && (ft.Kind() === 22)) {
						ft = ft.Elem();
					}
					if (!(name === "") || !sf.Anonymous || !((ft.Kind() === 25))) {
						tagged = !(name === "");
						if (name === "") {
							name = sf.Name;
						}
						fields = go$append(fields, new field.Ptr(name, tagged, index, ft, (new tagOptions(opts)).Contains("omitempty"), (new tagOptions(opts)).Contains("string")));
						if ((_entry$1 = count[(f.typ || go$interfaceNil).go$key()], _entry$1 !== undefined ? _entry$1.v : 0) > 1) {
							fields = go$append(fields, (_struct$2 = (_slice$2 = fields, _index$2 = (fields.length - 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$2.name, _struct$2.tag, _struct$2.index, _struct$2.typ, _struct$2.omitEmpty, _struct$2.quoted)));
						}
						i = i + 1 >> 0;
						continue;
					}
					_lhs = nextCount, _index$3 = ft, _key$5 = _index$3, (_lhs || go$throwRuntimeError("assignment to entry in nil map"))[(_key$5 || go$interfaceNil).go$key()] = { k: _key$5, v: (_entry$2 = _lhs[(_index$3 || go$interfaceNil).go$key()], _entry$2 !== undefined ? _entry$2.v : 0) + 1 >> 0 };
					if ((_entry$3 = nextCount[(ft || go$interfaceNil).go$key()], _entry$3 !== undefined ? _entry$3.v : 0) === 1) {
						next = go$append(next, new field.Ptr(ft.Name(), false, index, ft, false, false));
					}
					i = i + 1 >> 0;
				}
			}
		}
		sort.Sort(go$subslice(new byName(fields.array), fields.offset, fields.offset + fields.length));
		out = go$subslice(fields, 0, 0);
		_tuple$3 = [0, 0], advance = _tuple$3[0], i$1 = _tuple$3[1];
		while (i$1 < fields.length) {
			fi = (_struct$3 = (_slice$3 = fields, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$4] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$3.name, _struct$3.tag, _struct$3.index, _struct$3.typ, _struct$3.omitEmpty, _struct$3.quoted));
			name$1 = fi.name;
			advance = 1;
			while ((i$1 + advance >> 0) < fields.length) {
				fj = (_struct$4 = (_slice$4 = fields, _index$5 = (i$1 + advance >> 0), (_index$5 >= 0 && _index$5 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$5] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$4.name, _struct$4.tag, _struct$4.index, _struct$4.typ, _struct$4.omitEmpty, _struct$4.quoted));
				if (!(fj.name === name$1)) {
					break;
				}
				advance = advance + 1 >> 0;
			}
			if (advance === 1) {
				out = go$append(out, (_struct$5 = fi, new field.Ptr(_struct$5.name, _struct$5.tag, _struct$5.index, _struct$5.typ, _struct$5.omitEmpty, _struct$5.quoted)));
				i$1 = i$1 + (advance) >> 0;
				continue;
			}
			_tuple$4 = dominantField(go$subslice(fields, i$1, (i$1 + advance >> 0))), dominant = (_struct$6 = _tuple$4[0], new field.Ptr(_struct$6.name, _struct$6.tag, _struct$6.index, _struct$6.typ, _struct$6.omitEmpty, _struct$6.quoted)), ok = _tuple$4[1];
			if (ok) {
				out = go$append(out, (_struct$7 = dominant, new field.Ptr(_struct$7.name, _struct$7.tag, _struct$7.index, _struct$7.typ, _struct$7.omitEmpty, _struct$7.quoted)));
			}
			i$1 = i$1 + (advance) >> 0;
		}
		fields = out;
		sort.Sort(go$subslice(new byIndex(fields.array), fields.offset, fields.offset + fields.length));
		return fields;
	};
0Ç dominantFieldÇ	var dominantField = function(fields) {
		var _slice, _index, length, tagged, _ref, _i, _slice$1, _index$1, _struct, f, i, _slice$2, _index$2, _struct$1, _slice$3, _index$3, _struct$2;
		length = (_slice = fields, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).index.length;
		tagged = -1;
		_ref = fields;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			f = (_struct = (_slice$1 = _ref, _index$1 = _i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct.name, _struct.tag, _struct.index, _struct.typ, _struct.omitEmpty, _struct.quoted));
			i = _i;
			if (f.index.length > length) {
				fields = go$subslice(fields, 0, i);
				break;
			}
			if (f.tag) {
				if (tagged >= 0) {
					return [new field.Ptr("", false, (go$sliceType(Go$Int)).nil, null, false, false), false];
				}
				tagged = i;
			}
		}
		if (tagged >= 0) {
			return [(_struct$1 = (_slice$2 = fields, _index$2 = tagged, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$1.name, _struct$1.tag, _struct$1.index, _struct$1.typ, _struct$1.omitEmpty, _struct$1.quoted)), true];
		}
		if (fields.length > 1) {
			return [new field.Ptr("", false, (go$sliceType(Go$Int)).nil, null, false, false), false];
		}
		return [(_struct$2 = (_slice$3 = fields, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")), new field.Ptr(_struct$2.name, _struct$2.tag, _struct$2.index, _struct$2.typ, _struct$2.omitEmpty, _struct$2.quoted)), true];
	};
0ÇÙcachedTypeFieldsÇﬁ	var cachedTypeFields = function(t) {
		var _entry, f, _map, _key, _key$1;
		fieldCache.RWMutex.RLock();
		f = (_entry = fieldCache.m[(t || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : (go$sliceType(field)).nil);
		fieldCache.RWMutex.RUnlock();
		if (!(f === (go$sliceType(field)).nil)) {
			return f;
		}
		f = typeFields(t);
		if (f === (go$sliceType(field)).nil) {
			f = new (go$sliceType(field))([]);
		}
		fieldCache.RWMutex.Lock();
		if (fieldCache.m === false) {
			fieldCache.m = (_map = new Go$Map(), _map);
		}
		_key$1 = t, (fieldCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(_key$1 || go$interfaceNil).go$key()] = { k: _key$1, v: f };
		fieldCache.RWMutex.Unlock();
		return f;
	};
0gCompact\	var Compact = go$pkg.Compact = function(dst, src) {
		return compact(dst, src, false);
	};
0Ç©compactÇú	var compact = function(dst, src, escape) {
		var origLen, scan, start, _ref, _i, _slice, _index, c, i, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, v;
		origLen = dst.Len();
		scan = new scanner.Ptr();
		scan.reset();
		start = 0;
		_ref = src;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (escape && ((c === 60) || (c === 62) || (c === 38))) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u00");
				dst.WriteByte(hex.charCodeAt((c >>> 4 << 24 >>> 24)));
				dst.WriteByte(hex.charCodeAt(((c & 15) >>> 0)));
				start = i + 1 >> 0;
			}
			if ((c === 226) && (i + 2 >> 0) < src.length && ((_slice$1 = src, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 128) && (((_slice$2 = src, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) & ~1) === 168)) {
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				dst.WriteString("\\u202");
				dst.WriteByte(hex.charCodeAt((((_slice$3 = src, _index$3 = (i + 2 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) & 15) >>> 0)));
				start = i + 3 >> 0;
			}
			v = scan.step(scan, (c >> 0));
			if (v >= 9) {
				if (v === 11) {
					break;
				}
				if (start < i) {
					dst.Write(go$subslice(src, start, i));
				}
				start = i + 1 >> 0;
			}
		}
		if (scan.eof() === 11) {
			dst.Truncate(origLen);
			return scan.err;
		}
		if (start < src.length) {
			dst.Write(go$subslice(src, start));
		}
		return null;
	};
0Å—newlineÅ≈	var newline = function(dst, prefix, indent, depth) {
		var i;
		dst.WriteByte(10);
		dst.WriteString(prefix);
		i = 0;
		while (i < depth) {
			dst.WriteString(indent);
			i = i + 1 >> 0;
		}
	};
0Ç÷IndentÇ 	var Indent = go$pkg.Indent = function(dst, src, prefix, indent) {
		var origLen, scan, needIndent, depth, _ref, _i, _slice, _index, c, x, v, _ref$1;
		origLen = dst.Len();
		scan = new scanner.Ptr();
		scan.reset();
		needIndent = false;
		depth = 0;
		_ref = src;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			scan.bytes = (x = scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
			v = scan.step(scan, (c >> 0));
			if (v === 9) {
				continue;
			}
			if (v === 11) {
				break;
			}
			if (needIndent && !((v === 5)) && !((v === 8))) {
				needIndent = false;
				depth = depth + 1 >> 0;
				newline(dst, prefix, indent, depth);
			}
			if (v === 0) {
				dst.WriteByte(c);
				continue;
			}
			_ref$1 = c;
			if (_ref$1 === 123 || _ref$1 === 91) {
				needIndent = true;
				dst.WriteByte(c);
			} else if (_ref$1 === 44) {
				dst.WriteByte(c);
				newline(dst, prefix, indent, depth);
			} else if (_ref$1 === 58) {
				dst.WriteByte(c);
				dst.WriteByte(32);
			} else if (_ref$1 === 125 || _ref$1 === 93) {
				if (needIndent) {
					needIndent = false;
				} else {
					depth = depth - 1 >> 0;
					newline(dst, prefix, indent, depth);
				}
				dst.WriteByte(c);
			} else {
				dst.WriteByte(c);
			}
		}
		if (scan.eof() === 11) {
			dst.Truncate(origLen);
			return scan.err;
		}
		return null;
	};
0Ç&
checkValidÇ	var checkValid = function(data, scan) {
		var _ref, _i, _slice, _index, c, x;
		scan.reset();
		_ref = data;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			scan.bytes = (x = scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
			if (scan.step(scan, (c >> 0)) === 11) {
				return scan.err;
			}
		}
		if (scan.eof() === 11) {
			return scan.err;
		}
		return null;
	};
0Ç9	nextValueÇ*	var nextValue = function(data, scan) {
		var value, rest, err, _ref, _i, _slice, _index, c, i, v, _ref$1, _tuple, _tuple$1, _tuple$2, _tuple$3;
		value = (go$sliceType(Go$Uint8)).nil;
		rest = (go$sliceType(Go$Uint8)).nil;
		err = null;
		scan.reset();
		_ref = data;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			v = scan.step(scan, (c >> 0));
			if (v >= 10) {
				_ref$1 = v;
				if (_ref$1 === 11) {
					_tuple = [(go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, scan.err], value = _tuple[0], rest = _tuple[1], err = _tuple[2];
					return [value, rest, err];
				} else if (_ref$1 === 10) {
					_tuple$1 = [go$subslice(data, 0, i), go$subslice(data, i), null], value = _tuple$1[0], rest = _tuple$1[1], err = _tuple$1[2];
					return [value, rest, err];
				}
			}
		}
		if (scan.eof() === 11) {
			_tuple$2 = [(go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, scan.err], value = _tuple$2[0], rest = _tuple$2[1], err = _tuple$2[2];
			return [value, rest, err];
		}
		_tuple$3 = [data, (go$sliceType(Go$Uint8)).nil, null], value = _tuple$3[0], rest = _tuple$3[1], err = _tuple$3[2];
		return [value, rest, err];
	};
0ÅÆErrorÅ§	SyntaxError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		return e.msg;
	};
	SyntaxError.prototype.Error = function() { return this.go$val.Error(); };
0ÇresetÇ	scanner.Ptr.prototype.reset = function() {
		var s;
		s = this;
		s.step = stateBeginValue;
		s.parseState = go$subslice(s.parseState, 0, 0);
		s.err = null;
		s.redo = false;
		s.endTop = false;
	};
	scanner.prototype.reset = function() { return this.go$val.reset(); };
0Ç´eofÇ¢	scanner.Ptr.prototype.eof = function() {
		var s;
		s = this;
		if (!(go$interfaceIsEqual(s.err, null))) {
			return 11;
		}
		if (s.endTop) {
			return 10;
		}
		s.step(s, 32);
		if (s.endTop) {
			return 10;
		}
		if (go$interfaceIsEqual(s.err, null)) {
			s.err = new SyntaxError.Ptr("unexpected end of JSON input", s.bytes);
		}
		return 11;
	};
	scanner.prototype.eof = function() { return this.go$val.eof(); };
0ÅÍpushParseStateÅ◊	scanner.Ptr.prototype.pushParseState = function(p) {
		var s;
		s = this;
		s.parseState = go$append(s.parseState, p);
	};
	scanner.prototype.pushParseState = function(p) { return this.go$val.pushParseState(p); };
0ÇäpopParseStateÇw	scanner.Ptr.prototype.popParseState = function() {
		var s, n;
		s = this;
		n = s.parseState.length - 1 >> 0;
		s.parseState = go$subslice(s.parseState, 0, n);
		s.redo = false;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
		} else {
			s.step = stateEndValue;
		}
	};
	scanner.prototype.popParseState = function() { return this.go$val.popParseState(); };
0jisSpace_	var isSpace = function(c) {
		return (c === 32) || (c === 9) || (c === 13) || (c === 10);
	};
0Å⁄stateBeginValueOrEmptyÅø	var stateBeginValueOrEmpty = function(s, c) {
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 93) {
			return stateEndValue(s, c);
		}
		return stateBeginValue(s, c);
	};
0ÇKstateBeginValueÇ6	var stateBeginValue = function(s, c) {
		var _ref;
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		_ref = c;
		if (_ref === 123) {
			s.step = stateBeginStringOrEmpty;
			s.pushParseState(0);
			return 2;
		} else if (_ref === 91) {
			s.step = stateBeginValueOrEmpty;
			s.pushParseState(2);
			return 6;
		} else if (_ref === 34) {
			s.step = stateInString;
			return 1;
		} else if (_ref === 45) {
			s.step = stateNeg;
			return 1;
		} else if (_ref === 48) {
			s.step = state0;
			return 1;
		} else if (_ref === 116) {
			s.step = stateT;
			return 1;
		} else if (_ref === 102) {
			s.step = stateF;
			return 1;
		} else if (_ref === 110) {
			s.step = stateN;
			return 1;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 1;
		}
		return s.error(c, "looking for beginning of value");
	};
0Ç∆stateBeginStringOrEmptyÇ©	var stateBeginStringOrEmpty = function(s, c) {
		var n, _slice, _index;
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 125) {
			n = s.parseState.length;
			_slice = s.parseState, _index = n - 1 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 1) : go$throwRuntimeError("index out of range");
			return stateEndValue(s, c);
		}
		return stateBeginString(s, c);
	};
0Å˙stateBeginStringÅÂ	var stateBeginString = function(s, c) {
		if (c <= 32 && isSpace((c >> 0))) {
			return 9;
		}
		if (c === 34) {
			s.step = stateInString;
			return 1;
		}
		return s.error(c, "looking for beginning of object key string");
	};
0Ç÷stateEndValueÇ√	var stateEndValue = function(s, c) {
		var n, _slice, _index, ps, _ref, _slice$1, _index$1, _slice$2, _index$2;
		n = s.parseState.length;
		if (n === 0) {
			s.step = stateEndTop;
			s.endTop = true;
			return stateEndTop(s, c);
		}
		if (c <= 32 && isSpace((c >> 0))) {
			s.step = stateEndValue;
			return 9;
		}
		ps = (_slice = s.parseState, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		_ref = ps;
		if (_ref === 0) {
			if (c === 58) {
				_slice$1 = s.parseState, _index$1 = n - 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 1) : go$throwRuntimeError("index out of range");
				s.step = stateBeginValue;
				return 3;
			}
			return s.error(c, "after object key");
		} else if (_ref === 1) {
			if (c === 44) {
				_slice$2 = s.parseState, _index$2 = n - 1 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = 0) : go$throwRuntimeError("index out of range");
				s.step = stateBeginString;
				return 4;
			}
			if (c === 125) {
				s.popParseState();
				return 5;
			}
			return s.error(c, "after object key:value pair");
		} else if (_ref === 2) {
			if (c === 44) {
				s.step = stateBeginValue;
				return 7;
			}
			if (c === 93) {
				s.popParseState();
				return 8;
			}
			return s.error(c, "after array element");
		}
		return s.error(c, "");
	};
0Å∫stateEndTopÅ™	var stateEndTop = function(s, c) {
		if (!((c === 32)) && !((c === 9)) && !((c === 13)) && !((c === 10))) {
			s.error(c, "after top-level value");
		}
		return 10;
	};
0ÇstateInStringÅÙ	var stateInString = function(s, c) {
		if (c === 34) {
			s.step = stateEndValue;
			return 0;
		}
		if (c === 92) {
			s.step = stateInStringEsc;
			return 0;
		}
		if (c < 32) {
			return s.error(c, "in string literal");
		}
		return 0;
	};
0ÇzstateInStringEscÇd	var stateInStringEsc = function(s, c) {
		var _ref;
		_ref = c;
		if (_ref === 98 || _ref === 102 || _ref === 110 || _ref === 114 || _ref === 116 || _ref === 92 || _ref === 47 || _ref === 34) {
			s.step = stateInString;
			return 0;
		}
		if (c === 117) {
			s.step = stateInStringEscU;
			return 0;
		}
		return s.error(c, "in string escape code");
	};
0Å˙stateInStringEscUÅ‰	var stateInStringEscU = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU1;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
0Å˝stateInStringEscU1ÅÊ	var stateInStringEscU1 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU12;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
0Ç stateInStringEscU12ÅË	var stateInStringEscU12 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInStringEscU123;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
0Å˚stateInStringEscU123Å‚	var stateInStringEscU123 = function(s, c) {
		if (48 <= c && c <= 57 || 97 <= c && c <= 102 || 65 <= c && c <= 70) {
			s.step = stateInString;
			return 0;
		}
		return s.error(c, "in \\u hexadecimal character escape");
	};
0Å’stateNegÅ»	var stateNeg = function(s, c) {
		if (c === 48) {
			s.step = state0;
			return 0;
		}
		if (49 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return s.error(c, "in numeric literal");
	};
0ÅÖstate1{	var state1 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = state1;
			return 0;
		}
		return state0(s, c);
	};
0ÅÕstate0Å¬	var state0 = function(s, c) {
		if (c === 46) {
			s.step = stateDot;
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
0ÅµstateDotÅ®	var stateDot = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateDot0;
			return 0;
		}
		return s.error(c, "after decimal point in numeric literal");
	};
0Åﬁ	stateDot0Å–	var stateDot0 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateDot0;
			return 0;
		}
		if ((c === 101) || (c === 69)) {
			s.step = stateE;
			return 0;
		}
		return stateEndValue(s, c);
	};
0ÅøstateEÅ¥	var stateE = function(s, c) {
		if (c === 43) {
			s.step = stateESign;
			return 0;
		}
		if (c === 45) {
			s.step = stateESign;
			return 0;
		}
		return stateESign(s, c);
	};
0ÅØ
stateESignÅ†	var stateESign = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateE0;
			return 0;
		}
		return s.error(c, "in exponent of numeric literal");
	};
0ÅêstateE0ÅÑ	var stateE0 = function(s, c) {
		if (48 <= c && c <= 57) {
			s.step = stateE0;
			return 0;
		}
		return stateEndValue(s, c);
	};
0ÅüstateTÅî	var stateT = function(s, c) {
		if (c === 114) {
			s.step = stateTr;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'r')");
	};
0Å¢stateTrÅñ	var stateTr = function(s, c) {
		if (c === 117) {
			s.step = stateTru;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'u')");
	};
0Å©stateTruÅú	var stateTru = function(s, c) {
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal true (expecting 'e')");
	};
0ÅüstateFÅî	var stateF = function(s, c) {
		if (c === 97) {
			s.step = stateFa;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'a')");
	};
0Å£stateFaÅó	var stateFa = function(s, c) {
		if (c === 108) {
			s.step = stateFal;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'l')");
	};
0Å¶stateFalÅô	var stateFal = function(s, c) {
		if (c === 115) {
			s.step = stateFals;
			return 0;
		}
		return s.error(c, "in literal false (expecting 's')");
	};
0Å¨	stateFalsÅû	var stateFals = function(s, c) {
		if (c === 101) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal false (expecting 'e')");
	};
0ÅüstateNÅî	var stateN = function(s, c) {
		if (c === 117) {
			s.step = stateNu;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'u')");
	};
0Å¢stateNuÅñ	var stateNu = function(s, c) {
		if (c === 108) {
			s.step = stateNul;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
0Å©stateNulÅú	var stateNul = function(s, c) {
		if (c === 108) {
			s.step = stateEndValue;
			return 0;
		}
		return s.error(c, "in literal null (expecting 'l')");
	};
0B
stateError4	var stateError = function(s, c) {
		return 11;
	};
0Ç6errorÇ+	scanner.Ptr.prototype.error = function(c, context) {
		var s;
		s = this;
		s.step = stateError;
		s.err = new SyntaxError.Ptr("invalid character " + quoteChar(c) + " " + context, s.bytes);
		return 11;
	};
	scanner.prototype.error = function(c, context) { return this.go$val.error(c, context); };
0ÅÏ	quoteCharÅﬁ	var quoteChar = function(c) {
		var s;
		if (c === 39) {
			return "'\\''";
		}
		if (c === 34) {
			return "'\"'";
		}
		s = strconv.Quote(go$encodeRune(c));
		return "'" + s.substring(1, (s.length - 1 >> 0)) + "'";
	};
0ÇYundoÇO	scanner.Ptr.prototype.undo = function(scanCode) {
		var s;
		s = this;
		if (s.redo) {
			throw go$panic(new Go$String("json: invalid use of scanner"));
		}
		s.redoCode = scanCode;
		s.redoState = s.step;
		s.step = stateRedo;
		s.redo = true;
	};
	scanner.prototype.undo = function(scanCode) { return this.go$val.undo(scanCode); };
0r	stateRedoe	var stateRedo = function(s, c) {
		s.redo = false;
		s.step = s.redoState;
		return s.redoCode;
	};
0Å≤
NewDecoderÅ£	var NewDecoder = go$pkg.NewDecoder = function(r) {
		return new Decoder.Ptr(r, (go$sliceType(Go$Uint8)).nil, new decodeState.Ptr(), new scanner.Ptr(), null);
	};
0Åƒ	UseNumberÅ∂	Decoder.Ptr.prototype.UseNumber = function() {
		var dec;
		dec = this;
		dec.d.useNumber = true;
	};
	Decoder.prototype.UseNumber = function() { return this.go$val.UseNumber(); };
0Ç0DecodeÇ$	Decoder.Ptr.prototype.Decode = function(v) {
		var dec, _tuple, n, err, rest;
		dec = this;
		if (!(go$interfaceIsEqual(dec.err, null))) {
			return dec.err;
		}
		_tuple = dec.readValue(), n = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		dec.d.init(go$subslice(dec.buf, 0, n));
		err = dec.d.unmarshal(v);
		rest = go$copySlice(dec.buf, go$subslice(dec.buf, n));
		dec.buf = go$subslice(dec.buf, 0, rest);
		return err;
	};
	Decoder.prototype.Decode = function(v) { return this.go$val.Decode(v); };
0Å…BufferedÅº	Decoder.Ptr.prototype.Buffered = function() {
		var dec;
		dec = this;
		return bytes.NewReader(dec.buf);
	};
	Decoder.prototype.Buffered = function() { return this.go$val.Buffered(); };
0ÇB	readValueÇ3	Decoder.Ptr.prototype.readValue = function() {
		var dec, scanp, err, _ref, _i, _slice, _index, c, i, x, v, x$1, x$2, newBuf, n, _tuple;
		dec = this;
		dec.scan.reset();
		scanp = 0;
		err = null;
		Input: while (true) {
			_ref = go$subslice(dec.buf, scanp);
			_i = 0;
			for (; _i < _ref.length; _i += 1) {
				c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				dec.scan.bytes = (x = dec.scan.bytes, new Go$Int64(x.high + 0, x.low + 1));
				v = dec.scan.step(dec.scan, (c >> 0));
				if (v === 10) {
					scanp = scanp + (i) >> 0;
					break Input;
				}
				if (((v === 5) || (v === 8)) && (dec.scan.step(dec.scan, 32) === 10)) {
					scanp = scanp + ((i + 1 >> 0)) >> 0;
					break Input;
				}
				if (v === 11) {
					dec.err = dec.scan.err;
					return [0, dec.scan.err];
				}
			}
			scanp = dec.buf.length;
			if (!(go$interfaceIsEqual(err, null))) {
				if (go$interfaceIsEqual(err, io.EOF)) {
					if (dec.scan.step(dec.scan, 32) === 10) {
						break Input;
					}
					if (nonSpace(dec.buf)) {
						err = io.ErrUnexpectedEOF;
					}
				}
				dec.err = err;
				return [0, err];
			}
			if ((dec.buf.capacity - dec.buf.length >> 0) < 512) {
				newBuf = (go$sliceType(Go$Uint8)).make(dec.buf.length, (x$1 = 2, x$2 = dec.buf.capacity, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + 512 >> 0, function() { return 0; });
				go$copySlice(newBuf, dec.buf);
				dec.buf = newBuf;
			}
			n = 0;
			_tuple = dec.r.Read(go$subslice(dec.buf, dec.buf.length, dec.buf.capacity)), n = _tuple[0], err = _tuple[1];
			dec.buf = go$subslice(dec.buf, 0, (dec.buf.length + n >> 0));
		}
		return [scanp, null];
	};
	Decoder.prototype.readValue = function() { return this.go$val.readValue(); };
0ÇxnonSpaceÇj	var nonSpace = function(b) {
		var _ref, _i, _slice, _index, c;
		_ref = b;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!isSpace((c >> 0))) {
				return true;
			}
		}
		return false;
	};
0ÅÄ
NewEncoderr	var NewEncoder = go$pkg.NewEncoder = function(w) {
		return new Encoder.Ptr(w, new encodeState.Ptr(), null);
	};
0ÇEncodeÇ	Encoder.Ptr.prototype.Encode = function(v) {
		var enc, e, err, _tuple;
		enc = this;
		if (!(go$interfaceIsEqual(enc.err, null))) {
			return enc.err;
		}
		e = newEncodeState();
		err = e.marshal(v);
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		e.Buffer.WriteByte(10);
		if (_tuple = enc.w.Write(e.Buffer.Bytes()), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			enc.err = err;
		}
		putEncodeState(e);
		return err;
	};
	Encoder.prototype.Encode = function(v) { return this.go$val.Encode(v); };
0Ç{MarshalJSONÇj	go$ptrType(RawMessage).prototype.MarshalJSON = function() {
		var m, x;
		m = this;
		return [(x = m.go$get(), go$subslice(new (go$sliceType(Go$Uint8))(x.array), x.offset, x.offset + x.length)), null];
	};
	RawMessage.prototype.MarshalJSON = function() { var obj = this; return (new (go$ptrType(RawMessage))(function() { return obj; }, null)).MarshalJSON(); };
0ÇÔUnmarshalJSONÇ‹	go$ptrType(RawMessage).prototype.UnmarshalJSON = function(data) {
		var m;
		m = this;
		if (go$pointerIsEqual(m, (go$ptrType(RawMessage)).nil)) {
			return errors.New("json.RawMessage: UnmarshalJSON on nil pointer");
		}
		m.go$set(go$appendSlice(go$subslice((m.go$get()), 0, 0), data));
		return null;
	};
	RawMessage.prototype.UnmarshalJSON = function(data) { var obj = this; return (new (go$ptrType(RawMessage))(function() { return obj; }, null)).UnmarshalJSON(data); };
0ÅŒparseTagÅ¡	var parseTag = function(tag) {
		var idx;
		if (idx = strings.Index(tag, ","), !((idx === -1))) {
			return [tag.substring(0, idx), tag.substring((idx + 1 >> 0))];
		}
		return [tag, ""];
	};
0Ç<ContainsÇ.	tagOptions.prototype.Contains = function(optionName) {
		var o, s, next, i, _tuple;
		o = this.go$val;
		if (o.length === 0) {
			return false;
		}
		s = o;
		while (!(s === "")) {
			next = "";
			i = strings.Index(s, ",");
			if (i >= 0) {
				_tuple = [s.substring(0, i), s.substring((i + 1 >> 0))], s = _tuple[0], next = _tuple[1];
			}
			if (s === optionName) {
				return true;
			}
			s = next;
		}
		return false;
	};
	go$ptrType(tagOptions).prototype.Contains = function(optionName) { return new tagOptions(this.go$get()).Contains(optionName); };
0ÇlinitÇb
		  var encodeStates = [];
			go$pkg.init = function() {
		var e, v, quoted, _recv, e$1, v$1, quoted$1, _recv$1;
		errPhase = errors.New("JSON decoder out of sync - data changing underfoot?");
		numberType = reflect.TypeOf(new Number(""));
		hex = "0123456789abcdef";
		encodeStatePool = new (go$chanType((go$ptrType(encodeState)), false, false))();
		byteSliceType = reflect.TypeOf((go$sliceType(Go$Uint8)).nil);
		marshalerType = reflect.TypeOf(go$newDataPointer(null, (go$ptrType(Marshaler)))).Elem();
		textMarshalerType = reflect.TypeOf(go$newDataPointer(null, (go$ptrType(encoding.TextMarshaler)))).Elem();
		float32Encoder = (_recv = (new floatEncoder(32)), function(e, v, quoted) { return _recv.encode(e, v, quoted); });
		float64Encoder = (_recv$1 = (new floatEncoder(64)), function(e$1, v$1, quoted$1) { return _recv$1.encode(e$1, v$1, quoted$1); });
	};
