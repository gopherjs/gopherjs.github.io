0ÇÆåcompress/bzip2Ç˝package bzip2
import bufio "bufio"
import io "io"
import sort "sort"
func @"".NewReader(@"".r @"io".Reader) (? @"io".Reader)
type @"".StructuralError string
func (? @"".StructuralError) @"".Error() (? string)
func (? *@"".StructuralError) @"".Error() (? string)
type @"".bitReader struct { @"".r @"io".ByteReader; @"".n uint64; @"".bits uint; @"".err error }
func (? *@"".bitReader) @"".Err() (? error)
func (? *@"".bitReader) @"".ReadBit() (? bool)
func (? *@"".bitReader) @"".ReadBits(@"".bits uint) (@"".n int)
func (? *@"".bitReader) @"".ReadBits64(@"".bits uint) (@"".n uint64)
func (? *@"".bitReader) @"".TryReadBit() (@"".bit byte, @"".ok bool)
type @"".huffmanCode struct { @"".code uint32; @"".codeLen uint8; @"".value uint16 }
type @"".huffmanCodes []@"".huffmanCode
func (? @"".huffmanCodes) @"".Len() (? int)
func (? @"".huffmanCodes) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".huffmanCodes) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".huffmanCodes) @"".Len() (? int)
func (? *@"".huffmanCodes) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".huffmanCodes) @"".Swap(@"".i int, @"".j int) ()
type @"".huffmanNode struct { @"".left uint16; @"".right uint16; @"".leftValue uint16; @"".rightValue uint16 }
type @"".huffmanSymbolLengthPair struct { @"".value uint16; @"".length uint8 }
type @"".huffmanSymbolLengthPairs []@"".huffmanSymbolLengthPair
func (? @"".huffmanSymbolLengthPairs) @"".Len() (? int)
func (? @"".huffmanSymbolLengthPairs) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".huffmanSymbolLengthPairs) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".huffmanSymbolLengthPairs) @"".Len() (? int)
func (? *@"".huffmanSymbolLengthPairs) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".huffmanSymbolLengthPairs) @"".Swap(@"".i int, @"".j int) ()
type @"".huffmanTree struct { @"".nodes []@"".huffmanNode; @"".nextNode int }
func (? *@"".huffmanTree) @"".Decode(@"".br *@"".bitReader) (@"".v uint16)
type @"".moveToFrontDecoder struct { @"".symbols [256]byte; @"".next [256]uint8; @"".prev [256]uint8; @"".head uint8; @"".len int }
func (? *@"".moveToFrontDecoder) @"".Decode(@"".n int) (@"".b byte)
func (? *@"".moveToFrontDecoder) @"".First() (? byte)
func (? *@"".moveToFrontDecoder) @"".threadLinkedList() ()
type @"".reader struct { @"".br @"".bitReader; @"".fileCRC uint32; @"".blockCRC uint32; @"".wantBlockCRC uint32; @"".setupDone bool; @"".blockSize int; @"".eof bool; @"".buf []byte; @"".c [256]uint; @"".tt []uint32; @"".tPos uint32; @"".preRLE []uint32; @"".preRLEUsed int; @"".lastByte int; @"".byteRepeats uint; @"".repeats uint }
func (? *@"".reader) @"".Read(@"".buf []byte) (@"".n int, @"".err error)
func (? *@"".reader) @"".read(@"".buf []byte) (? int, ? error)
func (? *@"".reader) @"".readBlock() (@"".err error)
func (? *@"".reader) @"".readFromBlock(@"".buf []byte) (? int)
func (? *@"".reader) @"".setup(@"".needMagic bool) (? error)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"io".ByteReader interface { @"io".ReadByte() (@"".c byte, @"".err error) }
$$
0cruntimeerrorssync/atomicsynciounicodeunicode/utf8bytesbufiosortcompress/bzip20(0bufiobufio0ioio0sortsortÇ 	var bitReader;
	bitReader = go$newType(0, "Struct", "bzip2.bitReader", "bitReader", "compress/bzip2", function(r_, n_, bits_, err_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.n = n_ !== undefined ? n_ : new Go$Uint64(0, 0);
		this.bits = bits_ !== undefined ? bits_ : 0;
		this.err = err_ !== undefined ? err_ : null;
	});
	go$pkg.bitReader = bitReader;
	var StructuralError;
	StructuralError = go$newType(0, "String", "bzip2.StructuralError", "StructuralError", "compress/bzip2", null);
	go$pkg.StructuralError = StructuralError;
	var reader;
	reader = go$newType(0, "Struct", "bzip2.reader", "reader", "compress/bzip2", function(br_, fileCRC_, blockCRC_, wantBlockCRC_, setupDone_, blockSize_, eof_, buf_, c_, tt_, tPos_, preRLE_, preRLEUsed_, lastByte_, byteRepeats_, repeats_) {
		this.go$val = this;
		this.br = br_ !== undefined ? br_ : new bitReader.Ptr();
		this.fileCRC = fileCRC_ !== undefined ? fileCRC_ : 0;
		this.blockCRC = blockCRC_ !== undefined ? blockCRC_ : 0;
		this.wantBlockCRC = wantBlockCRC_ !== undefined ? wantBlockCRC_ : 0;
		this.setupDone = setupDone_ !== undefined ? setupDone_ : false;
		this.blockSize = blockSize_ !== undefined ? blockSize_ : 0;
		this.eof = eof_ !== undefined ? eof_ : false;
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Uint8)).nil;
		this.c = c_ !== undefined ? c_ : go$makeNativeArray("Uint", 256, function() { return 0; });
		this.tt = tt_ !== undefined ? tt_ : (go$sliceType(Go$Uint32)).nil;
		this.tPos = tPos_ !== undefined ? tPos_ : 0;
		this.preRLE = preRLE_ !== undefined ? preRLE_ : (go$sliceType(Go$Uint32)).nil;
		this.preRLEUsed = preRLEUsed_ !== undefined ? preRLEUsed_ : 0;
		this.lastByte = lastByte_ !== undefined ? lastByte_ : 0;
		this.byteRepeats = byteRepeats_ !== undefined ? byteRepeats_ : 0;
		this.repeats = repeats_ !== undefined ? repeats_ : 0;
	});
	go$pkg.reader = reader;
	var huffmanTree;
	huffmanTree = go$newType(0, "Struct", "bzip2.huffmanTree", "huffmanTree", "compress/bzip2", function(nodes_, nextNode_) {
		this.go$val = this;
		this.nodes = nodes_ !== undefined ? nodes_ : (go$sliceType(huffmanNode)).nil;
		this.nextNode = nextNode_ !== undefined ? nextNode_ : 0;
	});
	go$pkg.huffmanTree = huffmanTree;
	var huffmanNode;
	huffmanNode = go$newType(0, "Struct", "bzip2.huffmanNode", "huffmanNode", "compress/bzip2", function(left_, right_, leftValue_, rightValue_) {
		this.go$val = this;
		this.left = left_ !== undefined ? left_ : 0;
		this.right = right_ !== undefined ? right_ : 0;
		this.leftValue = leftValue_ !== undefined ? leftValue_ : 0;
		this.rightValue = rightValue_ !== undefined ? rightValue_ : 0;
	});
	go$pkg.huffmanNode = huffmanNode;
	var huffmanSymbolLengthPair;
	huffmanSymbolLengthPair = go$newType(0, "Struct", "bzip2.huffmanSymbolLengthPair", "huffmanSymbolLengthPair", "compress/bzip2", function(value_, length_) {
		this.go$val = this;
		this.value = value_ !== undefined ? value_ : 0;
		this.length = length_ !== undefined ? length_ : 0;
	});
	go$pkg.huffmanSymbolLengthPair = huffmanSymbolLengthPair;
	var huffmanSymbolLengthPairs;
	huffmanSymbolLengthPairs = go$newType(0, "Slice", "bzip2.huffmanSymbolLengthPairs", "huffmanSymbolLengthPairs", "compress/bzip2", null);
	go$pkg.huffmanSymbolLengthPairs = huffmanSymbolLengthPairs;
	var huffmanCode;
	huffmanCode = go$newType(0, "Struct", "bzip2.huffmanCode", "huffmanCode", "compress/bzip2", function(code_, codeLen_, value_) {
		this.go$val = this;
		this.code = code_ !== undefined ? code_ : 0;
		this.codeLen = codeLen_ !== undefined ? codeLen_ : 0;
		this.value = value_ !== undefined ? value_ : 0;
	});
	go$pkg.huffmanCode = huffmanCode;
	var huffmanCodes;
	huffmanCodes = go$newType(0, "Slice", "bzip2.huffmanCodes", "huffmanCodes", "compress/bzip2", null);
	go$pkg.huffmanCodes = huffmanCodes;
	var moveToFrontDecoder;
	moveToFrontDecoder = go$newType(0, "Struct", "bzip2.moveToFrontDecoder", "moveToFrontDecoder", "compress/bzip2", function(symbols_, next_, prev_, head_, len_) {
		this.go$val = this;
		this.symbols = symbols_ !== undefined ? symbols_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
		this.next = next_ !== undefined ? next_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
		this.prev = prev_ !== undefined ? prev_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
		this.head = head_ !== undefined ? head_ : 0;
		this.len = len_ !== undefined ? len_ : 0;
	});
	go$pkg.moveToFrontDecoder = moveToFrontDecoder;
	bitReader.init([["r", "compress/bzip2", io.ByteReader, ""], ["n", "compress/bzip2", Go$Uint64, ""], ["bits", "compress/bzip2", Go$Uint, ""], ["err", "compress/bzip2", go$error, ""]]);
	(go$ptrType(bitReader)).methods = [["Err", "", [], [go$error], false], ["ReadBit", "", [], [Go$Bool], false], ["ReadBits", "", [Go$Uint], [Go$Int], false], ["ReadBits64", "", [Go$Uint], [Go$Uint64], false], ["TryReadBit", "", [], [Go$Uint8, Go$Bool], false]];
	StructuralError.methods = [["Error", "", [], [Go$String], false]];
	(go$ptrType(StructuralError)).methods = [["Error", "", [], [Go$String], false]];
	reader.init([["br", "compress/bzip2", bitReader, ""], ["fileCRC", "compress/bzip2", Go$Uint32, ""], ["blockCRC", "compress/bzip2", Go$Uint32, ""], ["wantBlockCRC", "compress/bzip2", Go$Uint32, ""], ["setupDone", "compress/bzip2", Go$Bool, ""], ["blockSize", "compress/bzip2", Go$Int, ""], ["eof", "compress/bzip2", Go$Bool, ""], ["buf", "compress/bzip2", (go$sliceType(Go$Uint8)), ""], ["c", "compress/bzip2", (go$arrayType(Go$Uint, 256)), ""], ["tt", "compress/bzip2", (go$sliceType(Go$Uint32)), ""], ["tPos", "compress/bzip2", Go$Uint32, ""], ["preRLE", "compress/bzip2", (go$sliceType(Go$Uint32)), ""], ["preRLEUsed", "compress/bzip2", Go$Int, ""], ["lastByte", "compress/bzip2", Go$Int, ""], ["byteRepeats", "compress/bzip2", Go$Uint, ""], ["repeats", "compress/bzip2", Go$Uint, ""]]);
	(go$ptrType(reader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["read", "compress/bzip2", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["readBlock", "compress/bzip2", [], [go$error], false], ["readFromBlock", "compress/bzip2", [(go$sliceType(Go$Uint8))], [Go$Int], false], ["setup", "compress/bzip2", [Go$Bool], [go$error], false]];
	huffmanTree.init([["nodes", "compress/bzip2", (go$sliceType(huffmanNode)), ""], ["nextNode", "compress/bzip2", Go$Int, ""]]);
	(go$ptrType(huffmanTree)).methods = [["Decode", "", [(go$ptrType(bitReader))], [Go$Uint16], false]];
	huffmanNode.init([["left", "compress/bzip2", Go$Uint16, ""], ["right", "compress/bzip2", Go$Uint16, ""], ["leftValue", "compress/bzip2", Go$Uint16, ""], ["rightValue", "compress/bzip2", Go$Uint16, ""]]);
	huffmanSymbolLengthPair.init([["value", "compress/bzip2", Go$Uint16, ""], ["length", "compress/bzip2", Go$Uint8, ""]]);
	huffmanSymbolLengthPairs.init(huffmanSymbolLengthPair);
	huffmanSymbolLengthPairs.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(huffmanSymbolLengthPairs)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	huffmanCode.init([["code", "compress/bzip2", Go$Uint32, ""], ["codeLen", "compress/bzip2", Go$Uint8, ""], ["value", "compress/bzip2", Go$Uint16, ""]]);
	huffmanCodes.init(huffmanCode);
	huffmanCodes.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	(go$ptrType(huffmanCodes)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
	moveToFrontDecoder.init([["symbols", "compress/bzip2", (go$arrayType(Go$Uint8, 256)), ""], ["next", "compress/bzip2", (go$arrayType(Go$Uint8, 256)), ""], ["prev", "compress/bzip2", (go$arrayType(Go$Uint8, 256)), ""], ["head", "compress/bzip2", Go$Uint8, ""], ["len", "compress/bzip2", Go$Int, ""]]);
	(go$ptrType(moveToFrontDecoder)).methods = [["Decode", "", [Go$Int], [Go$Uint8], false], ["First", "", [], [Go$Uint8], false], ["threadLinkedList", "compress/bzip2", [], [], false]];
K	var crctab = go$makeNativeArray("Uint32", 256, function() { return 0; });
0ÇÅã0ÇWnewBitReaderÇE	var newBitReader = function(r) {
		var _tuple, byter, ok;
		_tuple = (r !== null && io.ByteReader.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), byter = _tuple[0], ok = _tuple[1];
		if (!ok) {
			byter = bufio.NewReader(r);
		}
		return new bitReader.Ptr(byter, new Go$Uint64(0, 0), 0, null);
	};
0Çﬂ
ReadBits64Çœ	bitReader.Ptr.prototype.ReadBits64 = function(bits) {
		var n, br, _tuple, b, err, x, x$1, x$2, x$3, x$4;
		n = new Go$Uint64(0, 0);
		br = this;
		while (bits > br.bits) {
			_tuple = br.r.ReadByte(), b = _tuple[0], err = _tuple[1];
			if (go$interfaceIsEqual(err, io.EOF)) {
				err = io.ErrUnexpectedEOF;
			}
			if (!(go$interfaceIsEqual(err, null))) {
				br.err = err;
				n = new Go$Uint64(0, 0);
				return n;
			}
			br.n = go$shiftLeft64(br.n, 8);
			br.n = (x = br.n, x$1 = new Go$Uint64(0, b), new Go$Uint64(x.high | x$1.high, (x.low | x$1.low) >>> 0));
			br.bits = br.bits + 8 >>> 0;
		}
		n = (x$2 = go$shiftRightUint64(br.n, ((br.bits - bits >>> 0))), x$3 = (x$4 = go$shiftLeft64(new Go$Uint64(0, 1), bits), new Go$Uint64(x$4.high - 0, x$4.low - 1)), new Go$Uint64(x$2.high & x$3.high, (x$2.low & x$3.low) >>> 0));
		br.bits = br.bits - (bits) >>> 0;
		return n;
	};
	bitReader.prototype.ReadBits64 = function(bits) { return this.go$val.ReadBits64(bits); };
0ÇReadBitsÅ˜	bitReader.Ptr.prototype.ReadBits = function(bits) {
		var n, br, n64;
		n = 0;
		br = this;
		n64 = br.ReadBits64(bits);
		n = (n64.low >> 0);
		return n;
	};
	bitReader.prototype.ReadBits = function(bits) { return this.go$val.ReadBits(bits); };
0Å‘ReadBitÅ»	bitReader.Ptr.prototype.ReadBit = function() {
		var br, n;
		br = this;
		n = br.ReadBits(1);
		return !((n === 0));
	};
	bitReader.prototype.ReadBit = function() { return this.go$val.ReadBit(); };
0Ç˝
TryReadBitÇÌ	bitReader.Ptr.prototype.TryReadBit = function() {
		var bit, ok, br, _tuple, _tuple$1;
		bit = 0;
		ok = false;
		br = this;
		if (br.bits > 0) {
			br.bits = br.bits - 1 >>> 0;
			_tuple = [((go$shiftRightUint64(br.n, br.bits).low << 24 >>> 24) & 1) >>> 0, true], bit = _tuple[0], ok = _tuple[1];
			return [bit, ok];
		}
		_tuple$1 = [0, false], bit = _tuple$1[0], ok = _tuple$1[1];
		return [bit, ok];
	};
	bitReader.prototype.TryReadBit = function() { return this.go$val.TryReadBit(); };
0Å•ErrÅù	bitReader.Ptr.prototype.Err = function() {
		var br;
		br = this;
		return br.err;
	};
	bitReader.prototype.Err = function() { return this.go$val.Err(); };
0ÅÒErrorÅÁ	StructuralError.prototype.Error = function() {
		var s;
		s = this.go$val;
		return "bzip2 data invalid: " + s;
	};
	go$ptrType(StructuralError).prototype.Error = function() { return new StructuralError(this.go$get()).Error(); };
0ÅÏ	NewReaderÅﬁ	var NewReader = go$pkg.NewReader = function(r) {
		var bz2, _struct;
		bz2 = new reader.Ptr();
		bz2.br = (_struct = newBitReader(r), new bitReader.Ptr(_struct.r, _struct.n, _struct.bits, _struct.err));
		return bz2;
	};
0ÇtsetupÇi	reader.Ptr.prototype.setup = function(needMagic) {
		var bz2, br, magic, t, level, x, x$1;
		bz2 = this;
		br = bz2.br;
		if (needMagic) {
			magic = br.ReadBits(16);
			if (!((magic === 16986))) {
				return new StructuralError("bad magic value");
			}
		}
		t = br.ReadBits(8);
		if (!((t === 104))) {
			return new StructuralError("non-Huffman entropy encoding");
		}
		level = br.ReadBits(8);
		if (level < 49 || level > 57) {
			return new StructuralError("invalid compression level");
		}
		bz2.fileCRC = 0;
		bz2.blockSize = (x = 102400, x$1 = (level - 48 >> 0), (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
		if (bz2.blockSize > bz2.tt.length) {
			bz2.tt = (go$sliceType(Go$Uint32)).make(bz2.blockSize, 0, function() { return 0; });
		}
		return null;
	};
	reader.prototype.setup = function(needMagic) { return this.go$val.setup(needMagic); };
0Ç,ReadÇ"	reader.Ptr.prototype.Read = function(buf) {
		var n, err, bz2, _tuple, brErr, _tuple$1, _tuple$2, brErr$1;
		n = 0;
		err = null;
		bz2 = this;
		if (bz2.eof) {
			_tuple = [0, io.EOF], n = _tuple[0], err = _tuple[1];
			return [n, err];
		}
		if (!bz2.setupDone) {
			err = bz2.setup(true);
			brErr = bz2.br.Err();
			if (!(go$interfaceIsEqual(brErr, null))) {
				err = brErr;
			}
			if (!(go$interfaceIsEqual(err, null))) {
				_tuple$1 = [0, err], n = _tuple$1[0], err = _tuple$1[1];
				return [n, err];
			}
			bz2.setupDone = true;
		}
		_tuple$2 = bz2.read(buf), n = _tuple$2[0], err = _tuple$2[1];
		brErr$1 = bz2.br.Err();
		if (!(go$interfaceIsEqual(brErr$1, null))) {
			err = brErr$1;
		}
		return [n, err];
	};
	reader.prototype.Read = function(buf) { return this.go$val.Read(buf); };
0ÇÃreadFromBlockÇπ	reader.Ptr.prototype.readFromBlock = function(buf) {
		var bz2, n, _slice, _index, _slice$1, _index$1, b, _slice$2, _index$2;
		bz2 = this;
		n = 0;
		while ((bz2.repeats > 0 || bz2.preRLEUsed < bz2.preRLE.length) && n < buf.length) {
			if (bz2.repeats > 0) {
				_slice = buf, _index = n, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (bz2.lastByte << 24 >>> 24)) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
				bz2.repeats = bz2.repeats - 1 >>> 0;
				if (bz2.repeats === 0) {
					bz2.lastByte = -1;
				}
				continue;
			}
			bz2.tPos = (_slice$1 = bz2.preRLE, _index$1 = bz2.tPos, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			b = (bz2.tPos << 24 >>> 24);
			bz2.tPos = bz2.tPos >>> 8 >>> 0;
			bz2.preRLEUsed = bz2.preRLEUsed + 1 >> 0;
			if (bz2.byteRepeats === 3) {
				bz2.repeats = (b >>> 0);
				bz2.byteRepeats = 0;
				continue;
			}
			if (bz2.lastByte === (b >> 0)) {
				bz2.byteRepeats = bz2.byteRepeats + 1 >>> 0;
			} else {
				bz2.byteRepeats = 0;
			}
			bz2.lastByte = (b >> 0);
			_slice$2 = buf, _index$2 = n, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = b) : go$throwRuntimeError("index out of range");
			n = n + 1 >> 0;
		}
		return n;
	};
	reader.prototype.readFromBlock = function(buf) { return this.go$val.readFromBlock(buf); };
0ÇfreadÇ\	reader.Ptr.prototype.read = function(buf) {
		var bz2, n, br, _ref, err, wantFileCRC, _r, _r$1, _tuple, b, err$1, _tuple$1, z, err$2;
		bz2 = this;
		while (true) {
			n = bz2.readFromBlock(buf);
			if (n > 0) {
				bz2.blockCRC = updateCRC(bz2.blockCRC, go$subslice(buf, 0, n));
				return [n, null];
			}
			if (!((bz2.blockCRC === bz2.wantBlockCRC))) {
				bz2.br.err = new StructuralError("block checksum mismatch");
				return [0, bz2.br.err];
			}
			br = bz2.br;
			_ref = br.ReadBits64(48);
			if ((_ref.high === 12609 && _ref.low === 1495683929)) {
				err = bz2.readBlock();
				if (!(go$interfaceIsEqual(err, null))) {
					return [0, err];
				}
			} else if ((_ref.high === 6002 && _ref.low === 1161318544)) {
				wantFileCRC = (br.ReadBits64(32).low >>> 0);
				if (!(go$interfaceIsEqual(br.err, null))) {
					return [0, br.err];
				}
				if (!((bz2.fileCRC === wantFileCRC))) {
					br.err = new StructuralError("file checksum mismatch");
					return [0, br.err];
				}
				if (!(((_r = br.bits % 8, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0))) {
					br.ReadBits((_r$1 = br.bits % 8, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero")));
				}
				_tuple = br.r.ReadByte(), b = _tuple[0], err$1 = _tuple[1];
				if (go$interfaceIsEqual(err$1, io.EOF)) {
					br.err = io.EOF;
					bz2.eof = true;
					return [0, io.EOF];
				}
				if (!(go$interfaceIsEqual(err$1, null))) {
					br.err = err$1;
					return [0, err$1];
				}
				_tuple$1 = br.r.ReadByte(), z = _tuple$1[0], err$1 = _tuple$1[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					if (go$interfaceIsEqual(err$1, io.EOF)) {
						err$1 = io.ErrUnexpectedEOF;
					}
					br.err = err$1;
					return [0, err$1];
				}
				if (!((b === 66)) || !((z === 90))) {
					return [0, new StructuralError("bad magic value in continuation file")];
				}
				if (err$2 = bz2.setup(false), !(go$interfaceIsEqual(err$2, null))) {
					return [0, err$2];
				}
			} else {
				return [0, new StructuralError("bad magic value found")];
			}
		}
	};
	reader.prototype.read = function(buf) { return this.go$val.read(buf); };
0ÇU	readBlockÇF	reader.Ptr.prototype.readBlock = function() {
		var err, bz2, br, randomized, origPtr, symbolRangeUsedBitmap, symbolPresent, numSymbols, symRange, y, bits, symbol, y$1, _slice, _index, x, numHuffmanTrees, numSelectors, treeIndexes, mtfTreeDecoder, _ref, _i, i, c, inc, _slice$1, _index$1, symbols, nextSymbol, i$1, _slice$2, _index$2, _slice$3, _index$3, mtf, huffmanTrees, lengths, i$2, length, j, _slice$4, _index$4, _tuple, _struct, _slice$5, _index$5, selectorIndex, _slice$6, _index$6, _slice$7, _index$7, _struct$1, currentHuffmanTree, bufIndex, repeat, repeat_power, _ref$1, _i$1, i$3, decoded, _slice$8, _index$8, _slice$9, _index$9, _struct$2, v, y$2, i$4, b, _slice$10, _index$10, _lhs, _index$11, b$1, _slice$11, _index$12, _lhs$1, _index$13;
		err = null;
		bz2 = this;
		br = bz2.br;
		bz2.wantBlockCRC = (br.ReadBits64(32).low >>> 0);
		bz2.blockCRC = 0;
		bz2.fileCRC = (((((bz2.fileCRC << 1 >>> 0) | (bz2.fileCRC >>> 31 >>> 0)) >>> 0)) ^ bz2.wantBlockCRC) >>> 0;
		randomized = br.ReadBits(1);
		if (!((randomized === 0))) {
			err = new StructuralError("deprecated randomized files");
			return err;
		}
		origPtr = (br.ReadBits(24) >>> 0);
		symbolRangeUsedBitmap = br.ReadBits(16);
		symbolPresent = (go$sliceType(Go$Bool)).make(256, 0, function() { return false; });
		numSymbols = 0;
		symRange = 0;
		while (symRange < 16) {
			if (!(((symbolRangeUsedBitmap & (((y = ((15 - symRange >>> 0)), y < 32 ? (1 << y) : 0) >> 0))) === 0))) {
				bits = br.ReadBits(16);
				symbol = 0;
				while (symbol < 16) {
					if (!(((bits & (((y$1 = ((15 - symbol >>> 0)), y$1 < 32 ? (1 << y$1) : 0) >> 0))) === 0))) {
						_slice = symbolPresent, _index = (x = 16, (((x >>> 16 << 16) * symRange >>> 0) + (x << 16 >>> 16) * symRange) >>> 0) + symbol >>> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = true) : go$throwRuntimeError("index out of range");
						numSymbols = numSymbols + 1 >> 0;
					}
					symbol = symbol + 1 >>> 0;
				}
			}
			symRange = symRange + 1 >>> 0;
		}
		numHuffmanTrees = br.ReadBits(3);
		if (numHuffmanTrees < 2 || numHuffmanTrees > 6) {
			err = new StructuralError("invalid number of Huffman trees");
			return err;
		}
		numSelectors = br.ReadBits(15);
		treeIndexes = (go$sliceType(Go$Uint8)).make(numSelectors, 0, function() { return 0; });
		mtfTreeDecoder = newMTFDecoderWithRange(numHuffmanTrees);
		_ref = treeIndexes;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i = _i;
			c = 0;
			while (true) {
				inc = br.ReadBits(1);
				if (inc === 0) {
					break;
				}
				c = c + 1 >> 0;
			}
			if (c >= numHuffmanTrees) {
				err = new StructuralError("tree index too large");
				return err;
			}
			_slice$1 = treeIndexes, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = mtfTreeDecoder.Decode(c)) : go$throwRuntimeError("index out of range");
		}
		symbols = (go$sliceType(Go$Uint8)).make(numSymbols, 0, function() { return 0; });
		nextSymbol = 0;
		i$1 = 0;
		while (i$1 < 256) {
			if ((_slice$2 = symbolPresent, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))) {
				_slice$3 = symbols, _index$3 = nextSymbol, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (i$1 << 24 >>> 24)) : go$throwRuntimeError("index out of range");
				nextSymbol = nextSymbol + 1 >> 0;
			}
			i$1 = i$1 + 1 >> 0;
		}
		mtf = newMTFDecoder(symbols);
		numSymbols = numSymbols + 2 >> 0;
		huffmanTrees = (go$sliceType(huffmanTree)).make(numHuffmanTrees, 0, function() { return new huffmanTree.Ptr(); });
		lengths = (go$sliceType(Go$Uint8)).make(numSymbols, 0, function() { return 0; });
		i$2 = 0;
		while (i$2 < numHuffmanTrees) {
			length = br.ReadBits(5);
			j = 0;
			while (j < numSymbols) {
				while (true) {
					if (!br.ReadBit()) {
						break;
					}
					if (br.ReadBit()) {
						length = length - 1 >> 0;
					} else {
						length = length + 1 >> 0;
					}
				}
				if (length < 0 || length > 20) {
					err = new StructuralError("Huffman length out of range");
					return err;
				}
				_slice$4 = lengths, _index$4 = j, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = (length << 24 >>> 24)) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			_tuple = newHuffmanTree(lengths), _slice$5 = huffmanTrees, _index$5 = i$2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (_struct = _tuple[0], new huffmanTree.Ptr(_struct.nodes, _struct.nextNode))) : go$throwRuntimeError("index out of range"), err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				err = err;
				return err;
			}
			i$2 = i$2 + 1 >> 0;
		}
		selectorIndex = 1;
		currentHuffmanTree = (_struct$1 = (_slice$6 = huffmanTrees, _index$6 = (_slice$7 = treeIndexes, _index$7 = 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")), (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")), new huffmanTree.Ptr(_struct$1.nodes, _struct$1.nextNode));
		bufIndex = 0;
		repeat = 0;
		repeat_power = 0;
		_ref$1 = bz2.c;
		_i$1 = 0;
		for (; _i$1 < 256; _i$1 += 1) {
			i$3 = _i$1;
			bz2.c[i$3] = 0;
		}
		decoded = 0;
		while (true) {
			if (decoded === 50) {
				currentHuffmanTree = (_struct$2 = (_slice$8 = huffmanTrees, _index$8 = (_slice$9 = treeIndexes, _index$9 = selectorIndex, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")), (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")), new huffmanTree.Ptr(_struct$2.nodes, _struct$2.nextNode));
				selectorIndex = selectorIndex + 1 >> 0;
				decoded = 0;
			}
			v = currentHuffmanTree.Decode(br);
			decoded = decoded + 1 >> 0;
			if (v < 2) {
				if (repeat === 0) {
					repeat_power = 1;
				}
				repeat = repeat + (((y$2 = v, y$2 < 32 ? (repeat_power << y$2) : 0) >> 0)) >> 0;
				repeat_power = repeat_power << 1 >> 0;
				if (repeat > 2097152) {
					err = new StructuralError("repeat count too large");
					return err;
				}
				continue;
			}
			if (repeat > 0) {
				if (repeat > (bz2.blockSize - bufIndex >> 0)) {
					err = new StructuralError("repeats past end of block");
					return err;
				}
				i$4 = 0;
				while (i$4 < repeat) {
					b = mtf.First();
					_slice$10 = bz2.tt, _index$10 = bufIndex, (_index$10 >= 0 && _index$10 < _slice$10.length) ? (_slice$10.array[_slice$10.offset + _index$10] = (b >>> 0)) : go$throwRuntimeError("index out of range");
					_lhs = bz2.c, _index$11 = b, _lhs[_index$11] = _lhs[_index$11] + 1 >>> 0;
					bufIndex = bufIndex + 1 >> 0;
					i$4 = i$4 + 1 >> 0;
				}
				repeat = 0;
			}
			if ((v >> 0) === (numSymbols - 1 >> 0)) {
				break;
			}
			b$1 = mtf.Decode(((v - 1 << 16 >>> 16) >> 0));
			if (bufIndex >= bz2.blockSize) {
				err = new StructuralError("data exceeds block size");
				return err;
			}
			_slice$11 = bz2.tt, _index$12 = bufIndex, (_index$12 >= 0 && _index$12 < _slice$11.length) ? (_slice$11.array[_slice$11.offset + _index$12] = (b$1 >>> 0)) : go$throwRuntimeError("index out of range");
			_lhs$1 = bz2.c, _index$13 = b$1, _lhs$1[_index$13] = _lhs$1[_index$13] + 1 >>> 0;
			bufIndex = bufIndex + 1 >> 0;
		}
		if (origPtr >= (bufIndex >>> 0)) {
			err = new StructuralError("origPtr out of bounds");
			return err;
		}
		bz2.preRLE = go$subslice(bz2.tt, 0, bufIndex);
		bz2.preRLEUsed = 0;
		bz2.tPos = inverseBWT(bz2.preRLE, origPtr, new (go$sliceType(Go$Uint))(bz2.c));
		bz2.lastByte = -1;
		bz2.byteRepeats = 0;
		bz2.repeats = 0;
		err = null;
		return err;
	};
	reader.prototype.readBlock = function() { return this.go$val.readBlock(); };
0Ç	B
inverseBWTÇ	2	var inverseBWT = function(tt, origPtr, c) {
		var sum, i, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _ref, _i, i$1, _slice$3, _index$3, b, _lhs, _index$4, _slice$4, _index$5, _slice$5, _index$6, _slice$6, _index$7, _lhs$1, _index$8, _slice$7, _index$9, _slice$8, _index$10, _slice$9, _index$11;
		sum = 0;
		i = 0;
		while (i < 256) {
			sum = sum + ((_slice = c, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))) >>> 0;
			_slice$2 = c, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = sum - (_slice$1 = c, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >>> 0) : go$throwRuntimeError("index out of range");
			i = i + 1 >> 0;
		}
		_ref = tt;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			i$1 = _i;
			b = ((_slice$3 = tt, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) & 255) >>> 0;
			_lhs = tt, _index$4 = (_slice$4 = c, _index$5 = b, (_index$5 >= 0 && _index$5 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$5] : go$throwRuntimeError("index out of range")), _slice$6 = _lhs, _index$7 = _index$4, (_index$7 >= 0 && _index$7 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$7] = ((_slice$5 = _lhs, _index$6 = _index$4, (_index$6 >= 0 && _index$6 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$6] : go$throwRuntimeError("index out of range")) | (((i$1 >>> 0) << 8 >>> 0))) >>> 0) : go$throwRuntimeError("index out of range");
			_lhs$1 = c, _index$8 = b, _slice$8 = _lhs$1, _index$10 = _index$8, (_index$10 >= 0 && _index$10 < _slice$8.length) ? (_slice$8.array[_slice$8.offset + _index$10] = (_slice$7 = _lhs$1, _index$9 = _index$8, (_index$9 >= 0 && _index$9 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$9] : go$throwRuntimeError("index out of range")) + 1 >>> 0) : go$throwRuntimeError("index out of range");
		}
		return (_slice$9 = tt, _index$11 = origPtr, (_index$11 >= 0 && _index$11 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$11] : go$throwRuntimeError("index out of range")) >>> 8 >>> 0;
	};
0Ç–	updateCRCÇ¡	var updateCRC = function(val, b) {
		var crc, _ref, _i, _slice, _index, v;
		crc = ~val >>> 0;
		_ref = b;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			crc = (crctab[((((crc >>> 24 >>> 0) << 24 >>> 24) ^ v) << 24 >>> 24)] ^ ((crc << 8 >>> 0))) >>> 0;
		}
		return ~crc >>> 0;
	};
0Ç'DecodeÇ	huffmanTree.Ptr.prototype.Decode = function(br) {
		var v, t, nodeIndex, _slice, _index, node, _tuple, bit, ok;
		v = 0;
		t = this;
		nodeIndex = 0;
		while (true) {
			node = (_slice = t.nodes, _index = nodeIndex, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_tuple = br.TryReadBit(), bit = _tuple[0], ok = _tuple[1];
			if (!ok && br.ReadBit()) {
				bit = 1;
			}
			if (!((bit === 0))) {
				if (node.left === 65535) {
					v = node.leftValue;
					return v;
				}
				nodeIndex = node.left;
			} else {
				if (node.right === 65535) {
					v = node.rightValue;
					return v;
				}
				nodeIndex = node.right;
			}
		}
	};
	huffmanTree.prototype.Decode = function(br) { return this.go$val.Decode(br); };
0ÇnewHuffmanTreeÇ	var newHuffmanTree = function(lengths) {
		var t, x, pairs, _ref, _i, _slice, _index, length, i, _slice$1, _index$1, _slice$2, _index$2, code, length$1, x$1, codes, i$1, _slice$3, _index$3, y, _slice$4, _index$4, y$1, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7, _slice$8, _index$8, _slice$9, _index$9, _slice$10, _index$10, y$2, _tuple, err, _struct;
		if (lengths.length < 2) {
			throw go$panic(new Go$String("newHuffmanTree: too few symbols"));
		}
		t = new huffmanTree.Ptr();
		pairs = (x = (go$sliceType(huffmanSymbolLengthPair)).make(lengths.length, 0, function() { return new huffmanSymbolLengthPair.Ptr(); }), go$subslice(new huffmanSymbolLengthPairs(x.array), x.offset, x.offset + x.length));
		_ref = lengths;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			length = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			(_slice$1 = pairs, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).value = (i << 16 >>> 16);
			(_slice$2 = pairs, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).length = length;
		}
		sort.Sort(pairs);
		code = 0;
		length$1 = 32;
		codes = (x$1 = (go$sliceType(huffmanCode)).make(lengths.length, 0, function() { return new huffmanCode.Ptr(); }), go$subslice(new huffmanCodes(x$1.array), x$1.offset, x$1.offset + x$1.length));
		i$1 = pairs.length - 1 >> 0;
		while (i$1 >= 0) {
			if (length$1 > (_slice$3 = pairs, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).length) {
				length$1 = (y = ((32 - (_slice$4 = pairs, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).length << 24 >>> 24)), y < 32 ? (length$1 >>> y) : 0) << 24 >>> 24;
				length$1 = (y$1 = ((32 - (_slice$5 = pairs, _index$5 = i$1, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).length << 24 >>> 24)), y$1 < 32 ? (length$1 << y$1) : 0) << 24 >>> 24;
				length$1 = (_slice$6 = pairs, _index$6 = i$1, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).length;
			}
			(_slice$7 = codes, _index$7 = i$1, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")).code = code;
			(_slice$8 = codes, _index$8 = i$1, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")).codeLen = length$1;
			(_slice$10 = codes, _index$10 = i$1, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range")).value = (_slice$9 = pairs, _index$9 = i$1, (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")).value;
			code = code + (((y$2 = ((32 - length$1 << 24 >>> 24)), y$2 < 32 ? (1 << y$2) : 0) >>> 0)) >>> 0;
			i$1 = i$1 - 1 >> 0;
		}
		sort.Sort(codes);
		t.nodes = (go$sliceType(huffmanNode)).make(codes.length, 0, function() { return new huffmanNode.Ptr(); });
		_tuple = buildHuffmanNode(t, go$subslice(new (go$sliceType(huffmanCode))(codes.array), codes.offset, codes.offset + codes.length), 0), err = _tuple[1];
		return [(_struct = t, new huffmanTree.Ptr(_struct.nodes, _struct.nextNode)), err];
	};
0ÅÕLenÅ≈	huffmanSymbolLengthPairs.prototype.Len = function() {
		var h;
		h = this;
		return h.length;
	};
	go$ptrType(huffmanSymbolLengthPairs).prototype.Len = function() { return this.go$get().Len(); };
0Ç©LessÇü	huffmanSymbolLengthPairs.prototype.Less = function(i, j) {
		var h, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5;
		h = this;
		if ((_slice = h, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).length < (_slice$1 = h, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).length) {
			return true;
		}
		if ((_slice$2 = h, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).length > (_slice$3 = h, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).length) {
			return false;
		}
		if ((_slice$4 = h, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).value < (_slice$5 = h, _index$5 = j, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")).value) {
			return true;
		}
		return false;
	};
	go$ptrType(huffmanSymbolLengthPairs).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
0ÇÇSwapÇx	huffmanSymbolLengthPairs.prototype.Swap = function(i, j) {
		var h, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		h = this;
		_tuple = [(_struct = (_slice = h, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new huffmanSymbolLengthPair.Ptr(_struct.value, _struct.length)), (_struct$1 = (_slice$1 = h, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new huffmanSymbolLengthPair.Ptr(_struct$1.value, _struct$1.length))], _slice$2 = h, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = h, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(huffmanSymbolLengthPairs).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
0ÅµLenÅ≠	huffmanCodes.prototype.Len = function() {
		var n;
		n = this;
		return n.length;
	};
	go$ptrType(huffmanCodes).prototype.Len = function() { return this.go$get().Len(); };
0Ç)LessÇ	huffmanCodes.prototype.Less = function(i, j) {
		var n, _slice, _index, _slice$1, _index$1;
		n = this;
		return (_slice = n, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).code < (_slice$1 = n, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).code;
	};
	go$ptrType(huffmanCodes).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
0ÇrSwapÇh	huffmanCodes.prototype.Swap = function(i, j) {
		var n, _slice, _index, _struct, _slice$1, _index$1, _struct$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		n = this;
		_tuple = [(_struct = (_slice = n, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new huffmanCode.Ptr(_struct.code, _struct.codeLen, _struct.value)), (_struct$1 = (_slice$1 = n, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new huffmanCode.Ptr(_struct$1.code, _struct$1.codeLen, _struct$1.value))], _slice$2 = n, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = n, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(huffmanCodes).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
0Ç®buildHuffmanNodeÇí	var buildHuffmanNode = function(t, codes, level) {
		var nodeIndex, err, y, test, firstRightIndex, _ref, _i, _slice, _index, _struct, code, i, left, right, _tuple, _slice$1, _index$1, node, _slice$2, _index$2, _tuple$1, _slice$3, _index$3, _tuple$2;
		nodeIndex = 0;
		err = null;
		test = (y = ((31 - level >>> 0)), y < 32 ? (1 << y) : 0) >>> 0;
		firstRightIndex = codes.length;
		_ref = codes;
		_i = 0;
		for (; _i < _ref.length; _i += 1) {
			code = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new huffmanCode.Ptr(_struct.code, _struct.codeLen, _struct.value));
			i = _i;
			if (!((((code.code & test) >>> 0) === 0))) {
				firstRightIndex = i;
				break;
			}
		}
		left = go$subslice(codes, 0, firstRightIndex);
		right = go$subslice(codes, firstRightIndex);
		if ((left.length === 0) || (right.length === 0)) {
			_tuple = [0, new StructuralError("superfluous level in Huffman tree")], nodeIndex = _tuple[0], err = _tuple[1];
			return [nodeIndex, err];
		}
		nodeIndex = (t.nextNode << 16 >>> 16);
		node = (_slice$1 = t.nodes, _index$1 = t.nextNode, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
		t.nextNode = t.nextNode + 1 >> 0;
		if (left.length === 1) {
			node.left = 65535;
			node.leftValue = (_slice$2 = left, _index$2 = 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).value;
		} else {
			_tuple$1 = buildHuffmanNode(t, left, level + 1 >>> 0), node.left = _tuple$1[0], err = _tuple$1[1];
		}
		if (!(go$interfaceIsEqual(err, null))) {
			return [nodeIndex, err];
		}
		if (right.length === 1) {
			node.right = 65535;
			node.rightValue = (_slice$3 = right, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).value;
		} else {
			_tuple$2 = buildHuffmanNode(t, right, level + 1 >>> 0), node.right = _tuple$2[0], err = _tuple$2[1];
		}
		return [nodeIndex, err];
	};
0ÇEnewMTFDecoderÇ2	var newMTFDecoder = function(symbols) {
		var m;
		if (symbols.length > 256) {
			throw go$panic(new Go$String("too many symbols"));
		}
		m = new moveToFrontDecoder.Ptr();
		go$copySlice(new (go$sliceType(Go$Uint8))(m.symbols), symbols);
		m.len = symbols.length;
		m.threadLinkedList();
		return m;
	};
0Ç~newMTFDecoderWithRangeÇb	var newMTFDecoderWithRange = function(n) {
		var m, i;
		if (n > 256) {
			throw go$panic(new Go$String("newMTFDecoderWithRange: cannot have > 256 symbols"));
		}
		m = new moveToFrontDecoder.Ptr();
		i = 0;
		while (i < n) {
			m.symbols[(i << 24 >>> 24)] = (i << 24 >>> 24);
			i = i + 1 >> 0;
		}
		m.len = n;
		m.threadLinkedList();
		return m;
	};
0ÇÂthreadLinkedListÇœ	moveToFrontDecoder.Ptr.prototype.threadLinkedList = function() {
		var m, i;
		m = this;
		if (m.len === 0) {
			return;
		}
		m.prev[0] = ((m.len - 1 >> 0) << 24 >>> 24);
		i = 0;
		while ((i >> 0) < (m.len - 1 >> 0)) {
			m.next[i] = (i + 1 << 24 >>> 24);
			m.prev[i + 1 << 24 >>> 24] = i;
			i = i + 1 << 24 >>> 24;
		}
		m.next[m.len - 1 >> 0] = 0;
	};
	moveToFrontDecoder.prototype.threadLinkedList = function() { return this.go$val.threadLinkedList(); };
0Ç,DecodeÇ 	moveToFrontDecoder.Ptr.prototype.Decode = function(n) {
		var b, m, i, j;
		b = 0;
		m = this;
		if (n === 0) {
			b = m.symbols[m.head];
			return b;
		}
		i = m.head;
		j = 0;
		while (j < n) {
			i = m.next[i];
			j = j + 1 >> 0;
		}
		b = m.symbols[i];
		m.next[m.prev[i]] = m.next[i];
		m.prev[m.next[i]] = m.prev[i];
		m.next[i] = m.head;
		m.prev[i] = m.prev[m.head];
		m.next[m.prev[m.head]] = i;
		m.prev[m.head] = i;
		m.head = i;
		return b;
	};
	moveToFrontDecoder.prototype.Decode = function(n) { return this.go$val.Decode(n); };
0Å»FirstÅæ	moveToFrontDecoder.Ptr.prototype.First = function() {
		var m;
		m = this;
		return m.symbols[m.head];
	};
	moveToFrontDecoder.prototype.First = function() { return this.go$val.First(); };
0ÇàinitÇ~	go$pkg.init = function() {
		var _ref, _i, i, crc, j;
		_ref = crctab;
		_i = 0;
		for (; _i < 256; _i += 1) {
			i = _i;
			crc = (i >>> 0) << 24 >>> 0;
			j = 0;
			while (j < 8) {
				if (!((((crc & 2147483648) >>> 0) === 0))) {
					crc = (((crc << 1 >>> 0)) ^ 79764919) >>> 0;
				} else {
					crc = crc << 1 >>> 0;
				}
				j = j + 1 >> 0;
			}
			crctab[i] = crc;
		}
	};
