0ƒR•
image/jpeg‚'ípackage jpeg
import io "io"
import bufio "bufio"
import image "image"
import color "image/color"
import errors "errors"
func @"".Decode(@"".r @"io".Reader) (? @"image".Image, ? error)
func @"".DecodeConfig(@"".r @"io".Reader) (? @"image".Config, ? error)
const @"".DefaultQuality = 0x4b
func @"".Encode(@"".w @"io".Writer, @"".m @"image".Image, @"".o *@"".Options) (? error)
type @"".FormatError string
func (? @"".FormatError) @"".Error() (? string)
func (? *@"".FormatError) @"".Error() (? string)
type @"".Options struct { @"".Quality int }
type @"".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error); @"".ReadByte() (@"".c byte, @"".err error) }
type @"".UnsupportedError string
func (? @"".UnsupportedError) @"".Error() (? string)
func (? *@"".UnsupportedError) @"".Error() (? string)
type @"".bits struct { @"".a uint32; @"".m uint32; @"".n int }
type @"".block [64]int32
type @"".component struct { @"".h int; @"".v int; @"".c uint8; @"".tq uint8 }
type @"".decoder struct { @"".r @"".Reader; @"".b @"".bits; @"".width int; @"".height int; @"".img1 *@"image".Gray; @"".img3 *@"image".YCbCr; @"".ri int; @"".nComp int; @"".progressive bool; @"".eobRun uint16; @"".comp [3]@"".component; @"".progCoeffs [3][]@"".block; @"".huff [2][4]@"".huffman; @"".quant [4]@"".block; @"".tmp [1024]byte }
func (? *@"".decoder) @"".decode(@"".r @"io".Reader, @"".configOnly bool) (? @"image".Image, ? error)
func (? *@"".decoder) @"".decodeBit() (? bool, ? error)
func (? *@"".decoder) @"".decodeBits(@"".n int) (? uint32, ? error)
func (? *@"".decoder) @"".decodeHuffman(@"".h *@"".huffman) (? uint8, ? error)
func (? *@"".decoder) @"".ensureNBits(@"".n int) (? error)
func (? *@"".decoder) @"".ignore(@"".n int) (? error)
func (? *@"".decoder) @"".makeImg(@"".h0 int, @"".v0 int, @"".mxx int, @"".myy int) ()
func (? *@"".decoder) @"".processDHT(@"".n int) (? error)
func (? *@"".decoder) @"".processDQT(@"".n int) (? error)
func (? *@"".decoder) @"".processDRI(@"".n int) (? error)
func (? *@"".decoder) @"".processSOF(@"".n int) (? error)
func (? *@"".decoder) @"".processSOS(@"".n int) (? error)
func (? *@"".decoder) @"".receiveExtend(@"".t uint8) (? int32, ? error)
func (? *@"".decoder) @"".refine(@"".b *@"".block, @"".h *@"".huffman, @"".zigStart int32, @"".zigEnd int32, @"".delta int32) (? error)
func (? *@"".decoder) @"".refineNonZeroes(@"".b *@"".block, @"".zig int32, @"".zigEnd int32, @"".nz int32, @"".delta int32) (? int32, ? error)
type @"".encoder struct { @"".w @"".writer; @"".err error; @"".buf [16]byte; @"".bits uint32; @"".nBits uint32; @"".quant [2][64]byte }
func (? *@"".encoder) @"".emit(@"".bits uint32, @"".nBits uint32) ()
func (? *@"".encoder) @"".emitHuff(@"".h @"".huffIndex, @"".value int32) ()
func (? *@"".encoder) @"".emitHuffRLE(@"".h @"".huffIndex, @"".runLength int32, @"".value int32) ()
func (? *@"".encoder) @"".flush() ()
func (? *@"".encoder) @"".write(@"".p []byte) ()
func (? *@"".encoder) @"".writeBlock(@"".b *@"".block, @"".q @"".quantIndex, @"".prevDC int32) (? int32)
func (? *@"".encoder) @"".writeByte(@"".b byte) ()
func (? *@"".encoder) @"".writeDHT() ()
func (? *@"".encoder) @"".writeDQT() ()
func (? *@"".encoder) @"".writeMarkerHeader(@"".marker uint8, @"".markerlen int) ()
func (? *@"".encoder) @"".writeSOF0(@"".size @"image".Point) ()
func (? *@"".encoder) @"".writeSOS(@"".m @"image".Image) ()
type @"".huffIndex int
type @"".huffman struct { @"".l [16]int; @"".length int; @"".val [256]uint8; @"".size [256]int; @"".code [256]int; @"".minCode [16]int; @"".maxCode [16]int; @"".valIndex [16]int }
type @"".huffmanLUT []uint32
func (? *@"".huffmanLUT) @"".init(@"".s @"".huffmanSpec) ()
type @"".huffmanSpec struct { @"".count [16]byte; @"".value []byte }
type @"".quantIndex int
type @"".writer interface { @"".Flush() (? error); @"io".Write(@"".p []byte) (@"".n int, @"".err error); @"io".WriteByte(@"".c byte) (? error) }
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"image".Image interface { @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color); @"image".Bounds() (? @"image".Rectangle); @"image".ColorModel() (? @"image/color".Model) }
type @"image".Config struct { @"image".ColorModel @"image/color".Model; @"image".Width int; @"image".Height int }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
type @"image".Gray struct { @"image".Pix []uint8; @"image".Stride int; @"image".Rect @"image".Rectangle }
func (? *@"image".Gray) @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color)
func (? *@"image".Gray) @"image".Bounds() (? @"image".Rectangle)
func (? *@"image".Gray) @"image".ColorModel() (? @"image/color".Model)
func (? *@"image".Gray) @"image".Opaque() (? bool)
func (? *@"image".Gray) @"image".PixOffset(@"image".x int, @"image".y int) (? int)
func (? *@"image".Gray) @"image".Set(@"image".x int, @"image".y int, @"image".c @"image/color".Color) ()
func (? *@"image".Gray) @"image".SetGray(@"image".x int, @"image".y int, @"image".c @"image/color".Gray) ()
func (? *@"image".Gray) @"image".SubImage(@"image".r @"image".Rectangle) (? @"image".Image)
type @"image".YCbCr struct { @"image".Y []uint8; @"image".Cb []uint8; @"image".Cr []uint8; @"image".YStride int; @"image".CStride int; @"image".SubsampleRatio @"image".YCbCrSubsampleRatio; @"image".Rect @"image".Rectangle }
func (? *@"image".YCbCr) @"image".At(@"image".x int, @"image".y int) (? @"image/color".Color)
func (? *@"image".YCbCr) @"image".Bounds() (? @"image".Rectangle)
func (? *@"image".YCbCr) @"image".COffset(@"image".x int, @"image".y int) (? int)
func (? *@"image".YCbCr) @"image".ColorModel() (? @"image/color".Model)
func (? *@"image".YCbCr) @"image".Opaque() (? bool)
func (? *@"image".YCbCr) @"image".SubImage(@"image".r @"image".Rectangle) (? @"image".Image)
func (? *@"image".YCbCr) @"image".YOffset(@"image".x int, @"image".y int) (? int)
type @"image".Point struct { @"image".X int; @"image".Y int }
func (? @"image".Point) @"image".Add(@"image".q @"image".Point) (? @"image".Point)
func (? @"image".Point) @"image".Div(@"image".k int) (? @"image".Point)
func (? @"image".Point) @"image".Eq(@"image".q @"image".Point) (? bool)
func (? @"image".Point) @"image".In(@"image".r @"image".Rectangle) (? bool)
func (? @"image".Point) @"image".Mod(@"image".r @"image".Rectangle) (? @"image".Point)
func (? @"image".Point) @"image".Mul(@"image".k int) (? @"image".Point)
func (? @"image".Point) @"image".String() (? string)
func (? @"image".Point) @"image".Sub(@"image".q @"image".Point) (? @"image".Point)
func (? *@"image".Point) @"image".Add(@"image".q @"image".Point) (? @"image".Point)
func (? *@"image".Point) @"image".Div(@"image".k int) (? @"image".Point)
func (? *@"image".Point) @"image".Eq(@"image".q @"image".Point) (? bool)
func (? *@"image".Point) @"image".In(@"image".r @"image".Rectangle) (? bool)
func (? *@"image".Point) @"image".Mod(@"image".r @"image".Rectangle) (? @"image".Point)
func (? *@"image".Point) @"image".Mul(@"image".k int) (? @"image".Point)
func (? *@"image".Point) @"image".String() (? string)
func (? *@"image".Point) @"image".Sub(@"image".q @"image".Point) (? @"image".Point)
type @"image/color".Color interface { @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32) }
type @"image".Rectangle struct { @"image".Min @"image".Point; @"image".Max @"image".Point }
func (? @"image".Rectangle) @"image".Add(@"image".p @"image".Point) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Canon() (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Dx() (? int)
func (? @"image".Rectangle) @"image".Dy() (? int)
func (? @"image".Rectangle) @"image".Empty() (? bool)
func (? @"image".Rectangle) @"image".Eq(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".In(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".Inset(@"image".n int) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Intersect(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Overlaps(@"image".s @"image".Rectangle) (? bool)
func (? @"image".Rectangle) @"image".Size() (? @"image".Point)
func (? @"image".Rectangle) @"image".String() (? string)
func (? @"image".Rectangle) @"image".Sub(@"image".p @"image".Point) (? @"image".Rectangle)
func (? @"image".Rectangle) @"image".Union(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Add(@"image".p @"image".Point) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Canon() (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Dx() (? int)
func (? *@"image".Rectangle) @"image".Dy() (? int)
func (? *@"image".Rectangle) @"image".Empty() (? bool)
func (? *@"image".Rectangle) @"image".Eq(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".In(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".Inset(@"image".n int) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Intersect(@"image".s @"image".Rectangle) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Overlaps(@"image".s @"image".Rectangle) (? bool)
func (? *@"image".Rectangle) @"image".Size() (? @"image".Point)
func (? *@"image".Rectangle) @"image".String() (? string)
func (? *@"image".Rectangle) @"image".Sub(@"image".p @"image".Point) (? @"image".Rectangle)
func (? *@"image".Rectangle) @"image".Union(@"image".s @"image".Rectangle) (? @"image".Rectangle)
type @"image/color".Model interface { @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color) }
type @"image/color".Gray struct { @"image/color".Y uint8 }
func (? @"image/color".Gray) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".Gray) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image".YCbCrSubsampleRatio int
func (? @"image".YCbCrSubsampleRatio) @"image".String() (? string)
func (? *@"image".YCbCrSubsampleRatio) @"image".String() (? string)
$$
0|runtimeerrorssync/atomicsynciounicodeunicode/utf8bytesbufioimage/colormathstrconvimage
image/jpeg0R0ioio0bufiobufio0imageimage0image/colorcolor0errorserrors‚'“	var bits;
	bits = go$newType(0, "Struct", "jpeg.bits", "bits", "image/jpeg", function(a_, m_, n_) {
		this.go$val = this;
		this.a = a_ !== undefined ? a_ : 0;
		this.m = m_ !== undefined ? m_ : 0;
		this.n = n_ !== undefined ? n_ : 0;
	});
	go$pkg.bits = bits;
	var huffman;
	huffman = go$newType(0, "Struct", "jpeg.huffman", "huffman", "image/jpeg", function(l_, length_, val_, size_, code_, minCode_, maxCode_, valIndex_) {
		this.go$val = this;
		this.l = l_ !== undefined ? l_ : go$makeNativeArray("Int", 16, function() { return 0; });
		this.length = length_ !== undefined ? length_ : 0;
		this.val = val_ !== undefined ? val_ : go$makeNativeArray("Uint8", 256, function() { return 0; });
		this.size = size_ !== undefined ? size_ : go$makeNativeArray("Int", 256, function() { return 0; });
		this.code = code_ !== undefined ? code_ : go$makeNativeArray("Int", 256, function() { return 0; });
		this.minCode = minCode_ !== undefined ? minCode_ : go$makeNativeArray("Int", 16, function() { return 0; });
		this.maxCode = maxCode_ !== undefined ? maxCode_ : go$makeNativeArray("Int", 16, function() { return 0; });
		this.valIndex = valIndex_ !== undefined ? valIndex_ : go$makeNativeArray("Int", 16, function() { return 0; });
	});
	go$pkg.huffman = huffman;
	var block;
	block = go$newType(0, "Array", "jpeg.block", "block", "image/jpeg", null);
	go$pkg.block = block;
	var FormatError;
	FormatError = go$newType(0, "String", "jpeg.FormatError", "FormatError", "image/jpeg", null);
	go$pkg.FormatError = FormatError;
	var UnsupportedError;
	UnsupportedError = go$newType(0, "String", "jpeg.UnsupportedError", "UnsupportedError", "image/jpeg", null);
	go$pkg.UnsupportedError = UnsupportedError;
	var component;
	component = go$newType(0, "Struct", "jpeg.component", "component", "image/jpeg", function(h_, v_, c_, tq_) {
		this.go$val = this;
		this.h = h_ !== undefined ? h_ : 0;
		this.v = v_ !== undefined ? v_ : 0;
		this.c = c_ !== undefined ? c_ : 0;
		this.tq = tq_ !== undefined ? tq_ : 0;
	});
	go$pkg.component = component;
	var Reader;
	Reader = go$newType(0, "Interface", "jpeg.Reader", "Reader", "image/jpeg", null);
	go$pkg.Reader = Reader;
	var decoder;
	decoder = go$newType(0, "Struct", "jpeg.decoder", "decoder", "image/jpeg", function(r_, b_, width_, height_, img1_, img3_, ri_, nComp_, progressive_, eobRun_, comp_, progCoeffs_, huff_, quant_, tmp_) {
		this.go$val = this;
		this.r = r_ !== undefined ? r_ : null;
		this.b = b_ !== undefined ? b_ : new bits.Ptr();
		this.width = width_ !== undefined ? width_ : 0;
		this.height = height_ !== undefined ? height_ : 0;
		this.img1 = img1_ !== undefined ? img1_ : (go$ptrType(image.Gray)).nil;
		this.img3 = img3_ !== undefined ? img3_ : (go$ptrType(image.YCbCr)).nil;
		this.ri = ri_ !== undefined ? ri_ : 0;
		this.nComp = nComp_ !== undefined ? nComp_ : 0;
		this.progressive = progressive_ !== undefined ? progressive_ : false;
		this.eobRun = eobRun_ !== undefined ? eobRun_ : 0;
		this.comp = comp_ !== undefined ? comp_ : go$makeNativeArray("Struct", 3, function() { return new component.Ptr(); });
		this.progCoeffs = progCoeffs_ !== undefined ? progCoeffs_ : go$makeNativeArray("Slice", 3, function() { return (go$sliceType(block)).nil; });
		this.huff = huff_ !== undefined ? huff_ : go$makeNativeArray("Array", 2, function() { return go$makeNativeArray("Struct", 4, function() { return new huffman.Ptr(); }); });
		this.quant = quant_ !== undefined ? quant_ : go$makeNativeArray("Array", 4, function() { return go$makeNativeArray("Int32", 64, function() { return 0; }); });
		this.tmp = tmp_ !== undefined ? tmp_ : go$makeNativeArray("Uint8", 1024, function() { return 0; });
	});
	go$pkg.decoder = decoder;
	var quantIndex;
	quantIndex = go$newType(4, "Int", "jpeg.quantIndex", "quantIndex", "image/jpeg", null);
	go$pkg.quantIndex = quantIndex;
	var huffIndex;
	huffIndex = go$newType(4, "Int", "jpeg.huffIndex", "huffIndex", "image/jpeg", null);
	go$pkg.huffIndex = huffIndex;
	var huffmanSpec;
	huffmanSpec = go$newType(0, "Struct", "jpeg.huffmanSpec", "huffmanSpec", "image/jpeg", function(count_, value_) {
		this.go$val = this;
		this.count = count_ !== undefined ? count_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.value = value_ !== undefined ? value_ : (go$sliceType(Go$Uint8)).nil;
	});
	go$pkg.huffmanSpec = huffmanSpec;
	var huffmanLUT;
	huffmanLUT = go$newType(0, "Slice", "jpeg.huffmanLUT", "huffmanLUT", "image/jpeg", null);
	go$pkg.huffmanLUT = huffmanLUT;
	var writer;
	writer = go$newType(0, "Interface", "jpeg.writer", "writer", "image/jpeg", null);
	go$pkg.writer = writer;
	var encoder;
	encoder = go$newType(0, "Struct", "jpeg.encoder", "encoder", "image/jpeg", function(w_, err_, buf_, bits_, nBits_, quant_) {
		this.go$val = this;
		this.w = w_ !== undefined ? w_ : null;
		this.err = err_ !== undefined ? err_ : null;
		this.buf = buf_ !== undefined ? buf_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.bits = bits_ !== undefined ? bits_ : 0;
		this.nBits = nBits_ !== undefined ? nBits_ : 0;
		this.quant = quant_ !== undefined ? quant_ : go$makeNativeArray("Array", 2, function() { return go$makeNativeArray("Uint8", 64, function() { return 0; }); });
	});
	go$pkg.encoder = encoder;
	var Options;
	Options = go$newType(0, "Struct", "jpeg.Options", "Options", "image/jpeg", function(Quality_) {
		this.go$val = this;
		this.Quality = Quality_ !== undefined ? Quality_ : 0;
	});
	go$pkg.Options = Options;
	bits.init([["a", "image/jpeg", Go$Uint32, ""], ["m", "image/jpeg", Go$Uint32, ""], ["n", "image/jpeg", Go$Int, ""]]);
	huffman.init([["l", "image/jpeg", (go$arrayType(Go$Int, 16)), ""], ["length", "image/jpeg", Go$Int, ""], ["val", "image/jpeg", (go$arrayType(Go$Uint8, 256)), ""], ["size", "image/jpeg", (go$arrayType(Go$Int, 256)), ""], ["code", "image/jpeg", (go$arrayType(Go$Int, 256)), ""], ["minCode", "image/jpeg", (go$arrayType(Go$Int, 16)), ""], ["maxCode", "image/jpeg", (go$arrayType(Go$Int, 16)), ""], ["valIndex", "image/jpeg", (go$arrayType(Go$Int, 16)), ""]]);
	block.init(Go$Int32, 64);
	FormatError.methods = [["Error", "", [], [Go$String], false]];
	(go$ptrType(FormatError)).methods = [["Error", "", [], [Go$String], false]];
	UnsupportedError.methods = [["Error", "", [], [Go$String], false]];
	(go$ptrType(UnsupportedError)).methods = [["Error", "", [], [Go$String], false]];
	component.init([["h", "image/jpeg", Go$Int, ""], ["v", "image/jpeg", Go$Int, ""], ["c", "image/jpeg", Go$Uint8, ""], ["tq", "image/jpeg", Go$Uint8, ""]]);
	Reader.init([["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["ReadByte", "", (go$funcType([], [Go$Uint8, go$error], false))]]);
	decoder.init([["r", "image/jpeg", Reader, ""], ["b", "image/jpeg", bits, ""], ["width", "image/jpeg", Go$Int, ""], ["height", "image/jpeg", Go$Int, ""], ["img1", "image/jpeg", (go$ptrType(image.Gray)), ""], ["img3", "image/jpeg", (go$ptrType(image.YCbCr)), ""], ["ri", "image/jpeg", Go$Int, ""], ["nComp", "image/jpeg", Go$Int, ""], ["progressive", "image/jpeg", Go$Bool, ""], ["eobRun", "image/jpeg", Go$Uint16, ""], ["comp", "image/jpeg", (go$arrayType(component, 3)), ""], ["progCoeffs", "image/jpeg", (go$arrayType((go$sliceType(block)), 3)), ""], ["huff", "image/jpeg", (go$arrayType((go$arrayType(huffman, 4)), 2)), ""], ["quant", "image/jpeg", (go$arrayType(block, 4)), ""], ["tmp", "image/jpeg", (go$arrayType(Go$Uint8, 1024)), ""]]);
	(go$ptrType(decoder)).methods = [["decode", "image/jpeg", [io.Reader, Go$Bool], [image.Image, go$error], false], ["decodeBit", "image/jpeg", [], [Go$Bool, go$error], false], ["decodeBits", "image/jpeg", [Go$Int], [Go$Uint32, go$error], false], ["decodeHuffman", "image/jpeg", [(go$ptrType(huffman))], [Go$Uint8, go$error], false], ["ensureNBits", "image/jpeg", [Go$Int], [go$error], false], ["ignore", "image/jpeg", [Go$Int], [go$error], false], ["makeImg", "image/jpeg", [Go$Int, Go$Int, Go$Int, Go$Int], [], false], ["processDHT", "image/jpeg", [Go$Int], [go$error], false], ["processDQT", "image/jpeg", [Go$Int], [go$error], false], ["processDRI", "image/jpeg", [Go$Int], [go$error], false], ["processSOF", "image/jpeg", [Go$Int], [go$error], false], ["processSOS", "image/jpeg", [Go$Int], [go$error], false], ["receiveExtend", "image/jpeg", [Go$Uint8], [Go$Int32, go$error], false], ["refine", "image/jpeg", [(go$ptrType(block)), (go$ptrType(huffman)), Go$Int32, Go$Int32, Go$Int32], [go$error], false], ["refineNonZeroes", "image/jpeg", [(go$ptrType(block)), Go$Int32, Go$Int32, Go$Int32, Go$Int32], [Go$Int32, go$error], false]];
	huffmanSpec.init([["count", "image/jpeg", (go$arrayType(Go$Uint8, 16)), ""], ["value", "image/jpeg", (go$sliceType(Go$Uint8)), ""]]);
	huffmanLUT.init(Go$Uint32);
	(go$ptrType(huffmanLUT)).methods = [["init", "image/jpeg", [huffmanSpec], [], false]];
	writer.init([["Flush", "", (go$funcType([], [go$error], false))], ["Write", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))], ["WriteByte", "", (go$funcType([Go$Uint8], [go$error], false))]]);
	encoder.init([["w", "image/jpeg", writer, ""], ["err", "image/jpeg", go$error, ""], ["buf", "image/jpeg", (go$arrayType(Go$Uint8, 16)), ""], ["bits", "image/jpeg", Go$Uint32, ""], ["nBits", "image/jpeg", Go$Uint32, ""], ["quant", "image/jpeg", (go$arrayType((go$arrayType(Go$Uint8, 64)), 2)), ""]]);
	(go$ptrType(encoder)).methods = [["emit", "image/jpeg", [Go$Uint32, Go$Uint32], [], false], ["emitHuff", "image/jpeg", [huffIndex, Go$Int32], [], false], ["emitHuffRLE", "image/jpeg", [huffIndex, Go$Int32, Go$Int32], [], false], ["flush", "image/jpeg", [], [], false], ["write", "image/jpeg", [(go$sliceType(Go$Uint8))], [], false], ["writeBlock", "image/jpeg", [(go$ptrType(block)), quantIndex, Go$Int32], [Go$Int32], false], ["writeByte", "image/jpeg", [Go$Uint8], [], false], ["writeDHT", "image/jpeg", [], [], false], ["writeDQT", "image/jpeg", [], [], false], ["writeMarkerHeader", "image/jpeg", [Go$Uint8, Go$Int], [], false], ["writeSOF0", "image/jpeg", [image.Point], [], false], ["writeSOS", "image/jpeg", [image.Image], [], false]];
	Options.init([["Quality", "", Go$Int, ""]]);
0V0unzig0
bitCount0unscaledQuant0theHuffmanSpec0theHuffmanLUT0	sosHeader0ƒÒ0‚–fdct‚Œ	var fdct = function(b) {
		var y, x, x0, x$1, x1, x$2, x2, x$3, x3, x$4, x4, x$5, x5, x$6, x6, x$7, x7, tmp0, tmp1, tmp2, tmp3, tmp10, tmp12, tmp11, tmp13, x$8, x$9, x$10, z1, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$20, x$21, x$22, tmp0$1, tmp1$1, tmp2$1, tmp3$1, tmp10$1, tmp12$1, tmp11$1, tmp13$1, x$23, z1$1, x$24, x$25, x$26, x$27, x$28;
		y = 0;
		while (y < 8) {
			x0 = b[((x = 8, (((y >>> 16 << 16) * x >> 0) + (y << 16 >>> 16) * x) >> 0) + 0 >> 0)];
			x1 = b[((x$1 = 8, (((y >>> 16 << 16) * x$1 >> 0) + (y << 16 >>> 16) * x$1) >> 0) + 1 >> 0)];
			x2 = b[((x$2 = 8, (((y >>> 16 << 16) * x$2 >> 0) + (y << 16 >>> 16) * x$2) >> 0) + 2 >> 0)];
			x3 = b[((x$3 = 8, (((y >>> 16 << 16) * x$3 >> 0) + (y << 16 >>> 16) * x$3) >> 0) + 3 >> 0)];
			x4 = b[((x$4 = 8, (((y >>> 16 << 16) * x$4 >> 0) + (y << 16 >>> 16) * x$4) >> 0) + 4 >> 0)];
			x5 = b[((x$5 = 8, (((y >>> 16 << 16) * x$5 >> 0) + (y << 16 >>> 16) * x$5) >> 0) + 5 >> 0)];
			x6 = b[((x$6 = 8, (((y >>> 16 << 16) * x$6 >> 0) + (y << 16 >>> 16) * x$6) >> 0) + 6 >> 0)];
			x7 = b[((x$7 = 8, (((y >>> 16 << 16) * x$7 >> 0) + (y << 16 >>> 16) * x$7) >> 0) + 7 >> 0)];
			tmp0 = x0 + x7 >> 0;
			tmp1 = x1 + x6 >> 0;
			tmp2 = x2 + x5 >> 0;
			tmp3 = x3 + x4 >> 0;
			tmp10 = tmp0 + tmp3 >> 0;
			tmp12 = tmp0 - tmp3 >> 0;
			tmp11 = tmp1 + tmp2 >> 0;
			tmp13 = tmp1 - tmp2 >> 0;
			tmp0 = x0 - x7 >> 0;
			tmp1 = x1 - x6 >> 0;
			tmp2 = x2 - x5 >> 0;
			tmp3 = x3 - x4 >> 0;
			b[(x$8 = 8, (((y >>> 16 << 16) * x$8 >> 0) + (y << 16 >>> 16) * x$8) >> 0) + 0 >> 0] = (((tmp10 + tmp11 >> 0) - 1024 >> 0)) << 2 >> 0;
			b[(x$9 = 8, (((y >>> 16 << 16) * x$9 >> 0) + (y << 16 >>> 16) * x$9) >> 0) + 4 >> 0] = ((tmp10 - tmp11 >> 0)) << 2 >> 0;
			z1 = (x$10 = (tmp12 + tmp13 >> 0), (((x$10 >>> 16 << 16) * 4433 >> 0) + (x$10 << 16 >>> 16) * 4433) >> 0);
			z1 = z1 + 1024 >> 0;
			b[(x$11 = 8, (((y >>> 16 << 16) * x$11 >> 0) + (y << 16 >>> 16) * x$11) >> 0) + 2 >> 0] = ((z1 + ((((tmp12 >>> 16 << 16) * 6270 >> 0) + (tmp12 << 16 >>> 16) * 6270) >> 0) >> 0)) >> 11 >> 0;
			b[(x$12 = 8, (((y >>> 16 << 16) * x$12 >> 0) + (y << 16 >>> 16) * x$12) >> 0) + 6 >> 0] = ((z1 - ((((tmp13 >>> 16 << 16) * 15137 >> 0) + (tmp13 << 16 >>> 16) * 15137) >> 0) >> 0)) >> 11 >> 0;
			tmp10 = tmp0 + tmp3 >> 0;
			tmp11 = tmp1 + tmp2 >> 0;
			tmp12 = tmp0 + tmp2 >> 0;
			tmp13 = tmp1 + tmp3 >> 0;
			z1 = (x$13 = (tmp12 + tmp13 >> 0), (((x$13 >>> 16 << 16) * 9633 >> 0) + (x$13 << 16 >>> 16) * 9633) >> 0);
			z1 = z1 + 1024 >> 0;
			tmp0 = (((tmp0 >>> 16 << 16) * 12299 >> 0) + (tmp0 << 16 >>> 16) * 12299) >> 0;
			tmp1 = (((tmp1 >>> 16 << 16) * 25172 >> 0) + (tmp1 << 16 >>> 16) * 25172) >> 0;
			tmp2 = (((tmp2 >>> 16 << 16) * 16819 >> 0) + (tmp2 << 16 >>> 16) * 16819) >> 0;
			tmp3 = (((tmp3 >>> 16 << 16) * 2446 >> 0) + (tmp3 << 16 >>> 16) * 2446) >> 0;
			tmp10 = (x$14 = -7373, (((tmp10 >>> 16 << 16) * x$14 >> 0) + (tmp10 << 16 >>> 16) * x$14) >> 0);
			tmp11 = (x$15 = -20995, (((tmp11 >>> 16 << 16) * x$15 >> 0) + (tmp11 << 16 >>> 16) * x$15) >> 0);
			tmp12 = (x$16 = -3196, (((tmp12 >>> 16 << 16) * x$16 >> 0) + (tmp12 << 16 >>> 16) * x$16) >> 0);
			tmp13 = (x$17 = -16069, (((tmp13 >>> 16 << 16) * x$17 >> 0) + (tmp13 << 16 >>> 16) * x$17) >> 0);
			tmp12 = tmp12 + (z1) >> 0;
			tmp13 = tmp13 + (z1) >> 0;
			b[(x$18 = 8, (((y >>> 16 << 16) * x$18 >> 0) + (y << 16 >>> 16) * x$18) >> 0) + 1 >> 0] = (((tmp0 + tmp10 >> 0) + tmp12 >> 0)) >> 11 >> 0;
			b[(x$19 = 8, (((y >>> 16 << 16) * x$19 >> 0) + (y << 16 >>> 16) * x$19) >> 0) + 3 >> 0] = (((tmp1 + tmp11 >> 0) + tmp13 >> 0)) >> 11 >> 0;
			b[(x$20 = 8, (((y >>> 16 << 16) * x$20 >> 0) + (y << 16 >>> 16) * x$20) >> 0) + 5 >> 0] = (((tmp2 + tmp11 >> 0) + tmp12 >> 0)) >> 11 >> 0;
			b[(x$21 = 8, (((y >>> 16 << 16) * x$21 >> 0) + (y << 16 >>> 16) * x$21) >> 0) + 7 >> 0] = (((tmp3 + tmp10 >> 0) + tmp13 >> 0)) >> 11 >> 0;
			y = y + 1 >> 0;
		}
		x$22 = 0;
		while (x$22 < 8) {
			tmp0$1 = b[(0 + x$22 >> 0)] + b[(56 + x$22 >> 0)] >> 0;
			tmp1$1 = b[(8 + x$22 >> 0)] + b[(48 + x$22 >> 0)] >> 0;
			tmp2$1 = b[(16 + x$22 >> 0)] + b[(40 + x$22 >> 0)] >> 0;
			tmp3$1 = b[(24 + x$22 >> 0)] + b[(32 + x$22 >> 0)] >> 0;
			tmp10$1 = (tmp0$1 + tmp3$1 >> 0) + 2 >> 0;
			tmp12$1 = tmp0$1 - tmp3$1 >> 0;
			tmp11$1 = tmp1$1 + tmp2$1 >> 0;
			tmp13$1 = tmp1$1 - tmp2$1 >> 0;
			tmp0$1 = b[(0 + x$22 >> 0)] - b[(56 + x$22 >> 0)] >> 0;
			tmp1$1 = b[(8 + x$22 >> 0)] - b[(48 + x$22 >> 0)] >> 0;
			tmp2$1 = b[(16 + x$22 >> 0)] - b[(40 + x$22 >> 0)] >> 0;
			tmp3$1 = b[(24 + x$22 >> 0)] - b[(32 + x$22 >> 0)] >> 0;
			b[0 + x$22 >> 0] = ((tmp10$1 + tmp11$1 >> 0)) >> 2 >> 0;
			b[32 + x$22 >> 0] = ((tmp10$1 - tmp11$1 >> 0)) >> 2 >> 0;
			z1$1 = (x$23 = (tmp12$1 + tmp13$1 >> 0), (((x$23 >>> 16 << 16) * 4433 >> 0) + (x$23 << 16 >>> 16) * 4433) >> 0);
			z1$1 = z1$1 + 16384 >> 0;
			b[16 + x$22 >> 0] = ((z1$1 + ((((tmp12$1 >>> 16 << 16) * 6270 >> 0) + (tmp12$1 << 16 >>> 16) * 6270) >> 0) >> 0)) >> 15 >> 0;
			b[48 + x$22 >> 0] = ((z1$1 - ((((tmp13$1 >>> 16 << 16) * 15137 >> 0) + (tmp13$1 << 16 >>> 16) * 15137) >> 0) >> 0)) >> 15 >> 0;
			tmp10$1 = tmp0$1 + tmp3$1 >> 0;
			tmp11$1 = tmp1$1 + tmp2$1 >> 0;
			tmp12$1 = tmp0$1 + tmp2$1 >> 0;
			tmp13$1 = tmp1$1 + tmp3$1 >> 0;
			z1$1 = (x$24 = (tmp12$1 + tmp13$1 >> 0), (((x$24 >>> 16 << 16) * 9633 >> 0) + (x$24 << 16 >>> 16) * 9633) >> 0);
			z1$1 = z1$1 + 16384 >> 0;
			tmp0$1 = (((tmp0$1 >>> 16 << 16) * 12299 >> 0) + (tmp0$1 << 16 >>> 16) * 12299) >> 0;
			tmp1$1 = (((tmp1$1 >>> 16 << 16) * 25172 >> 0) + (tmp1$1 << 16 >>> 16) * 25172) >> 0;
			tmp2$1 = (((tmp2$1 >>> 16 << 16) * 16819 >> 0) + (tmp2$1 << 16 >>> 16) * 16819) >> 0;
			tmp3$1 = (((tmp3$1 >>> 16 << 16) * 2446 >> 0) + (tmp3$1 << 16 >>> 16) * 2446) >> 0;
			tmp10$1 = (x$25 = -7373, (((tmp10$1 >>> 16 << 16) * x$25 >> 0) + (tmp10$1 << 16 >>> 16) * x$25) >> 0);
			tmp11$1 = (x$26 = -20995, (((tmp11$1 >>> 16 << 16) * x$26 >> 0) + (tmp11$1 << 16 >>> 16) * x$26) >> 0);
			tmp12$1 = (x$27 = -3196, (((tmp12$1 >>> 16 << 16) * x$27 >> 0) + (tmp12$1 << 16 >>> 16) * x$27) >> 0);
			tmp13$1 = (x$28 = -16069, (((tmp13$1 >>> 16 << 16) * x$28 >> 0) + (tmp13$1 << 16 >>> 16) * x$28) >> 0);
			tmp12$1 = tmp12$1 + (z1$1) >> 0;
			tmp13$1 = tmp13$1 + (z1$1) >> 0;
			b[8 + x$22 >> 0] = (((tmp0$1 + tmp10$1 >> 0) + tmp12$1 >> 0)) >> 15 >> 0;
			b[24 + x$22 >> 0] = (((tmp1$1 + tmp11$1 >> 0) + tmp13$1 >> 0)) >> 15 >> 0;
			b[40 + x$22 >> 0] = (((tmp2$1 + tmp11$1 >> 0) + tmp12$1 >> 0)) >> 15 >> 0;
			b[56 + x$22 >> 0] = (((tmp3$1 + tmp10$1 >> 0) + tmp13$1 >> 0)) >> 15 >> 0;
			x$22 = x$22 + 1 >> 0;
		}
	};
0‚ensureNBits‚û	decoder.Ptr.prototype.ensureNBits = function(n) {
		var d, _tuple, c, err, _tuple$1;
		d = this;
		while (d.b.n < n) {
			_tuple = d.r.ReadByte(), c = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			d.b.a = ((d.b.a << 8 >>> 0) | (c >>> 0)) >>> 0;
			d.b.n = d.b.n + 8 >> 0;
			if (d.b.m === 0) {
				d.b.m = 128;
			} else {
				d.b.m = d.b.m << 8 >>> 0;
			}
			if (c === 255) {
				_tuple$1 = d.r.ReadByte(), c = _tuple$1[0], err = _tuple$1[1];
				if (!(go$interfaceIsEqual(err, null))) {
					return err;
				}
				if (!((c === 0))) {
					return new FormatError("missing 0xff00 sequence");
				}
			}
		}
		return null;
	};
	decoder.prototype.ensureNBits = function(n) { return this.go$val.ensureNBits(n); };
0‚ÉreceiveExtend‚¶	decoder.Ptr.prototype.receiveExtend = function(t) {
		var d, err, y, y$1, s, y$2, x, y$3;
		d = this;
		if (d.b.n < (t >> 0)) {
			if (err = d.ensureNBits((t >> 0)), !(go$interfaceIsEqual(err, null))) {
				return [0, err];
			}
		}
		d.b.n = d.b.n - ((t >> 0)) >> 0;
		d.b.m = (y = (t), y < 32 ? (d.b.m >>> y) : 0) >>> 0;
		s = (y$1 = t, y$1 < 32 ? (1 << y$1) : 0) >> 0;
		x = (((y$2 = (d.b.n << 24 >>> 24), y$2 < 32 ? (d.b.a >>> y$2) : 0) >>> 0) >> 0) & ((s - 1 >> 0));
		if (x < (s >> 1 >> 0)) {
			x = x + (((((y$3 = t, y$3 < 32 ? (-1 << y$3) : 0) >> 0)) + 1 >> 0)) >> 0;
		}
		return [x, null];
	};
	decoder.prototype.receiveExtend = function(t) { return this.go$val.receiveExtend(t); };
0‚	
processDHT‚			decoder.Ptr.prototype.processDHT = function(n) {
		var d, _tuple, err, tc, th, h, i, _tuple$1, k, i$1, j, code, size, i$2, y, index, i$3;
		d = this;
		while (n > 0) {
			if (n < 17) {
				return new FormatError("DHT has wrong length");
			}
			_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 17)), err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			tc = d.tmp[0] >>> 4 << 24 >>> 24;
			if (tc > 1) {
				return new FormatError("bad Tc value");
			}
			th = (d.tmp[0] & 15) >>> 0;
			if (th > 3 || !d.progressive && th > 1) {
				return new FormatError("bad Th value");
			}
			h = d.huff[tc][th];
			h.length = 0;
			i = 0;
			while (i < 16) {
				h.l[i] = (d.tmp[(i + 1 >> 0)] >> 0);
				h.length = h.length + (h.l[i]) >> 0;
				i = i + 1 >> 0;
			}
			if (h.length === 0) {
				return new FormatError("Huffman table has zero length");
			}
			if (h.length > 256) {
				return new FormatError("Huffman table has excessive length");
			}
			n = n - ((h.length + 17 >> 0)) >> 0;
			if (n < 0) {
				return new FormatError("DHT has wrong length");
			}
			_tuple$1 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(h.val), 0, h.length)), err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			k = 0;
			i$1 = 0;
			while (i$1 < 16) {
				j = 0;
				while (j < h.l[i$1]) {
					h.size[k] = i$1 + 1 >> 0;
					k = k + 1 >> 0;
					j = j + 1 >> 0;
				}
				i$1 = i$1 + 1 >> 0;
			}
			code = 0;
			size = h.size[0];
			i$2 = 0;
			while (i$2 < h.length) {
				if (!((size === h.size[i$2]))) {
					code = (y = (((h.size[i$2] - size >> 0) << 24 >>> 24)), y < 32 ? (code << y) : 0) >> 0;
					size = h.size[i$2];
				}
				h.code[i$2] = code;
				code = code + 1 >> 0;
				i$2 = i$2 + 1 >> 0;
			}
			k = 0;
			index = 0;
			i$3 = 0;
			while (i$3 < 16) {
				if (h.l[i$3] === 0) {
					h.minCode[i$3] = -1;
					h.maxCode[i$3] = -1;
					h.valIndex[i$3] = -1;
				} else {
					h.minCode[i$3] = k;
					h.maxCode[i$3] = (k + h.l[i$3] >> 0) - 1 >> 0;
					h.valIndex[i$3] = index;
					k = k + (h.l[i$3]) >> 0;
					index = index + (h.l[i$3]) >> 0;
				}
				k = k << 1 >> 0;
				i$3 = i$3 + 1 >> 0;
			}
		}
		return null;
	};
	decoder.prototype.processDHT = function(n) { return this.go$val.processDHT(n); };
0‚CdecodeHuffman‚0	decoder.Ptr.prototype.decodeHuffman = function(h) {
		var d, _tuple, i, code, err;
		d = this;
		if (h.length === 0) {
			return [0, new FormatError("uninitialized Huffman table")];
		}
		_tuple = [0, 0], i = _tuple[0], code = _tuple[1];
		while (i < 16) {
			if (d.b.n === 0) {
				if (err = d.ensureNBits(1), !(go$interfaceIsEqual(err, null))) {
					return [0, err];
				}
			}
			if (!((((d.b.a & d.b.m) >>> 0) === 0))) {
				code = code | 1;
			}
			d.b.n = d.b.n - 1 >> 0;
			d.b.m = d.b.m >>> 1 >>> 0;
			if (code <= h.maxCode[i]) {
				return [h.val[((h.valIndex[i] + code >> 0) - h.minCode[i] >> 0)], null];
			}
			code = code << 1 >> 0;
			i = i + 1 >> 0;
		}
		return [0, new FormatError("bad Huffman code")];
	};
	decoder.prototype.decodeHuffman = function(h) { return this.go$val.decodeHuffman(h); };
0‚¥	decodeBit‚–	decoder.Ptr.prototype.decodeBit = function() {
		var d, err, ret;
		d = this;
		if (d.b.n === 0) {
			if (err = d.ensureNBits(1), !(go$interfaceIsEqual(err, null))) {
				return [false, err];
			}
		}
		ret = !((((d.b.a & d.b.m) >>> 0) === 0));
		d.b.n = d.b.n - 1 >> 0;
		d.b.m = d.b.m >>> 1 >>> 0;
		return [ret, null];
	};
	decoder.prototype.decodeBit = function() { return this.go$val.decodeBit(); };
0‚W
decodeBits‚G	decoder.Ptr.prototype.decodeBits = function(n) {
		var d, err, y, ret, y$1, y$2;
		d = this;
		if (d.b.n < n) {
			if (err = d.ensureNBits(n), !(go$interfaceIsEqual(err, null))) {
				return [0, err];
			}
		}
		ret = (y = ((d.b.n - n >> 0) >>> 0), y < 32 ? (d.b.a >>> y) : 0) >>> 0;
		ret = (ret & (((((y$1 = (n >>> 0), y$1 < 32 ? (1 << y$1) : 0) >>> 0)) - 1 >>> 0))) >>> 0;
		d.b.n = d.b.n - (n) >> 0;
		d.b.m = (y$2 = ((n >>> 0)), y$2 < 32 ? (d.b.m >>> y$2) : 0) >>> 0;
		return [ret, null];
	};
	decoder.prototype.decodeBits = function(n) { return this.go$val.decodeBits(n); };
0‚xidct‚n	var idct = function(src) {
		var y, x, y8, dc, x0, x1, x2, x3, x4, x5, x6, x7, x$1, x8, x$2, x$3, x$4, x$5, x$6, y0, y1, y2, y3, y4, y5, y6, y7, x$7, y8$1, x$8, x$9, x$10, x$11;
		y = 0;
		while (y < 8) {
			y8 = (x = 8, (((y >>> 16 << 16) * x >> 0) + (y << 16 >>> 16) * x) >> 0);
			if ((src[(y8 + 1 >> 0)] === 0) && (src[(y8 + 2 >> 0)] === 0) && (src[(y8 + 3 >> 0)] === 0) && (src[(y8 + 4 >> 0)] === 0) && (src[(y8 + 5 >> 0)] === 0) && (src[(y8 + 6 >> 0)] === 0) && (src[(y8 + 7 >> 0)] === 0)) {
				dc = src[(y8 + 0 >> 0)] << 3 >> 0;
				src[y8 + 0 >> 0] = dc;
				src[y8 + 1 >> 0] = dc;
				src[y8 + 2 >> 0] = dc;
				src[y8 + 3 >> 0] = dc;
				src[y8 + 4 >> 0] = dc;
				src[y8 + 5 >> 0] = dc;
				src[y8 + 6 >> 0] = dc;
				src[y8 + 7 >> 0] = dc;
				y = y + 1 >> 0;
				continue;
			}
			x0 = ((src[(y8 + 0 >> 0)] << 11 >> 0)) + 128 >> 0;
			x1 = src[(y8 + 4 >> 0)] << 11 >> 0;
			x2 = src[(y8 + 6 >> 0)];
			x3 = src[(y8 + 2 >> 0)];
			x4 = src[(y8 + 1 >> 0)];
			x5 = src[(y8 + 7 >> 0)];
			x6 = src[(y8 + 5 >> 0)];
			x7 = src[(y8 + 3 >> 0)];
			x8 = (x$1 = (x4 + x5 >> 0), (((565 >>> 16 << 16) * x$1 >> 0) + (565 << 16 >>> 16) * x$1) >> 0);
			x4 = x8 + ((((2276 >>> 16 << 16) * x4 >> 0) + (2276 << 16 >>> 16) * x4) >> 0) >> 0;
			x5 = x8 - ((((3406 >>> 16 << 16) * x5 >> 0) + (3406 << 16 >>> 16) * x5) >> 0) >> 0;
			x8 = (x$2 = (x6 + x7 >> 0), (((2408 >>> 16 << 16) * x$2 >> 0) + (2408 << 16 >>> 16) * x$2) >> 0);
			x6 = x8 - ((((799 >>> 16 << 16) * x6 >> 0) + (799 << 16 >>> 16) * x6) >> 0) >> 0;
			x7 = x8 - ((((4017 >>> 16 << 16) * x7 >> 0) + (4017 << 16 >>> 16) * x7) >> 0) >> 0;
			x8 = x0 + x1 >> 0;
			x0 = x0 - (x1) >> 0;
			x1 = (x$3 = (x3 + x2 >> 0), (((1108 >>> 16 << 16) * x$3 >> 0) + (1108 << 16 >>> 16) * x$3) >> 0);
			x2 = x1 - ((((3784 >>> 16 << 16) * x2 >> 0) + (3784 << 16 >>> 16) * x2) >> 0) >> 0;
			x3 = x1 + ((((1568 >>> 16 << 16) * x3 >> 0) + (1568 << 16 >>> 16) * x3) >> 0) >> 0;
			x1 = x4 + x6 >> 0;
			x4 = x4 - (x6) >> 0;
			x6 = x5 + x7 >> 0;
			x5 = x5 - (x7) >> 0;
			x7 = x8 + x3 >> 0;
			x8 = x8 - (x3) >> 0;
			x3 = x0 + x2 >> 0;
			x0 = x0 - (x2) >> 0;
			x2 = (((x$4 = (x4 + x5 >> 0), (((181 >>> 16 << 16) * x$4 >> 0) + (181 << 16 >>> 16) * x$4) >> 0) + 128 >> 0)) >> 8 >> 0;
			x4 = (((x$5 = (x4 - x5 >> 0), (((181 >>> 16 << 16) * x$5 >> 0) + (181 << 16 >>> 16) * x$5) >> 0) + 128 >> 0)) >> 8 >> 0;
			src[y8 + 0 >> 0] = ((x7 + x1 >> 0)) >> 8 >> 0;
			src[y8 + 1 >> 0] = ((x3 + x2 >> 0)) >> 8 >> 0;
			src[y8 + 2 >> 0] = ((x0 + x4 >> 0)) >> 8 >> 0;
			src[y8 + 3 >> 0] = ((x8 + x6 >> 0)) >> 8 >> 0;
			src[y8 + 4 >> 0] = ((x8 - x6 >> 0)) >> 8 >> 0;
			src[y8 + 5 >> 0] = ((x0 - x4 >> 0)) >> 8 >> 0;
			src[y8 + 6 >> 0] = ((x3 - x2 >> 0)) >> 8 >> 0;
			src[y8 + 7 >> 0] = ((x7 - x1 >> 0)) >> 8 >> 0;
			y = y + 1 >> 0;
		}
		x$6 = 0;
		while (x$6 < 8) {
			y0 = ((src[(0 + x$6 >> 0)] << 8 >> 0)) + 8192 >> 0;
			y1 = src[(32 + x$6 >> 0)] << 8 >> 0;
			y2 = src[(48 + x$6 >> 0)];
			y3 = src[(16 + x$6 >> 0)];
			y4 = src[(8 + x$6 >> 0)];
			y5 = src[(56 + x$6 >> 0)];
			y6 = src[(40 + x$6 >> 0)];
			y7 = src[(24 + x$6 >> 0)];
			y8$1 = (x$7 = (y4 + y5 >> 0), (((565 >>> 16 << 16) * x$7 >> 0) + (565 << 16 >>> 16) * x$7) >> 0) + 4 >> 0;
			y4 = ((y8$1 + ((((2276 >>> 16 << 16) * y4 >> 0) + (2276 << 16 >>> 16) * y4) >> 0) >> 0)) >> 3 >> 0;
			y5 = ((y8$1 - ((((3406 >>> 16 << 16) * y5 >> 0) + (3406 << 16 >>> 16) * y5) >> 0) >> 0)) >> 3 >> 0;
			y8$1 = (x$8 = (y6 + y7 >> 0), (((2408 >>> 16 << 16) * x$8 >> 0) + (2408 << 16 >>> 16) * x$8) >> 0) + 4 >> 0;
			y6 = ((y8$1 - ((((799 >>> 16 << 16) * y6 >> 0) + (799 << 16 >>> 16) * y6) >> 0) >> 0)) >> 3 >> 0;
			y7 = ((y8$1 - ((((4017 >>> 16 << 16) * y7 >> 0) + (4017 << 16 >>> 16) * y7) >> 0) >> 0)) >> 3 >> 0;
			y8$1 = y0 + y1 >> 0;
			y0 = y0 - (y1) >> 0;
			y1 = (x$9 = (y3 + y2 >> 0), (((1108 >>> 16 << 16) * x$9 >> 0) + (1108 << 16 >>> 16) * x$9) >> 0) + 4 >> 0;
			y2 = ((y1 - ((((3784 >>> 16 << 16) * y2 >> 0) + (3784 << 16 >>> 16) * y2) >> 0) >> 0)) >> 3 >> 0;
			y3 = ((y1 + ((((1568 >>> 16 << 16) * y3 >> 0) + (1568 << 16 >>> 16) * y3) >> 0) >> 0)) >> 3 >> 0;
			y1 = y4 + y6 >> 0;
			y4 = y4 - (y6) >> 0;
			y6 = y5 + y7 >> 0;
			y5 = y5 - (y7) >> 0;
			y7 = y8$1 + y3 >> 0;
			y8$1 = y8$1 - (y3) >> 0;
			y3 = y0 + y2 >> 0;
			y0 = y0 - (y2) >> 0;
			y2 = (((x$10 = (y4 + y5 >> 0), (((181 >>> 16 << 16) * x$10 >> 0) + (181 << 16 >>> 16) * x$10) >> 0) + 128 >> 0)) >> 8 >> 0;
			y4 = (((x$11 = (y4 - y5 >> 0), (((181 >>> 16 << 16) * x$11 >> 0) + (181 << 16 >>> 16) * x$11) >> 0) + 128 >> 0)) >> 8 >> 0;
			src[0 + x$6 >> 0] = ((y7 + y1 >> 0)) >> 14 >> 0;
			src[8 + x$6 >> 0] = ((y3 + y2 >> 0)) >> 14 >> 0;
			src[16 + x$6 >> 0] = ((y0 + y4 >> 0)) >> 14 >> 0;
			src[24 + x$6 >> 0] = ((y8$1 + y6 >> 0)) >> 14 >> 0;
			src[32 + x$6 >> 0] = ((y8$1 - y6 >> 0)) >> 14 >> 0;
			src[40 + x$6 >> 0] = ((y0 - y4 >> 0)) >> 14 >> 0;
			src[48 + x$6 >> 0] = ((y3 - y2 >> 0)) >> 14 >> 0;
			src[56 + x$6 >> 0] = ((y7 - y1 >> 0)) >> 14 >> 0;
			x$6 = x$6 + 1 >> 0;
		}
	};
0æErrorÜ	FormatError.prototype.Error = function() {
		var e;
		e = this.go$val;
		return "invalid JPEG format: " + e;
	};
	go$ptrType(FormatError).prototype.Error = function() { return new FormatError(this.go$get()).Error(); };
0úErrorð	UnsupportedError.prototype.Error = function() {
		var e;
		e = this.go$val;
		return "unsupported JPEG feature: " + e;
	};
	go$ptrType(UnsupportedError).prototype.Error = function() { return new UnsupportedError(this.go$get()).Error(); };
0‚½ignore‚±	decoder.Ptr.prototype.ignore = function(n) {
		var d, m, _tuple, err;
		d = this;
		while (n > 0) {
			m = 1024;
			if (m > n) {
				m = n;
			}
			_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, m)), err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			n = n - (m) >> 0;
		}
		return null;
	};
	decoder.prototype.ignore = function(n) { return this.go$val.ignore(n); };
0‚º
processSOF‚ª	decoder.Ptr.prototype.processSOF = function(n) {
		var d, _ref, _tuple, err, i, x, x$1, x$2, hv;
		d = this;
		_ref = n;
		if (_ref === 9) {
			d.nComp = 1;
		} else if (_ref === 15) {
			d.nComp = 3;
		} else {
			return new UnsupportedError("SOF has wrong length");
		}
		_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, n)), err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		if (!((d.tmp[0] === 8))) {
			return new UnsupportedError("precision");
		}
		d.height = ((d.tmp[1] >> 0) << 8 >> 0) + (d.tmp[2] >> 0) >> 0;
		d.width = ((d.tmp[3] >> 0) << 8 >> 0) + (d.tmp[4] >> 0) >> 0;
		if (!(((d.tmp[5] >> 0) === d.nComp))) {
			return new UnsupportedError("SOF has wrong number of image components");
		}
		i = 0;
		while (i < d.nComp) {
			d.comp[i].c = d.tmp[(6 + (x = 3, (((x >>> 16 << 16) * i >> 0) + (x << 16 >>> 16) * i) >> 0) >> 0)];
			d.comp[i].tq = d.tmp[(8 + (x$1 = 3, (((x$1 >>> 16 << 16) * i >> 0) + (x$1 << 16 >>> 16) * i) >> 0) >> 0)];
			if (d.nComp === 1) {
				d.comp[i].h = 1;
				d.comp[i].v = 1;
				i = i + 1 >> 0;
				continue;
			}
			hv = d.tmp[(7 + (x$2 = 3, (((x$2 >>> 16 << 16) * i >> 0) + (x$2 << 16 >>> 16) * i) >> 0) >> 0)];
			d.comp[i].h = ((hv >>> 4 << 24 >>> 24) >> 0);
			d.comp[i].v = (((hv & 15) >>> 0) >> 0);
			if (i === 0) {
				if (!((hv === 17)) && !((hv === 33)) && !((hv === 34)) && !((hv === 18))) {
					return new UnsupportedError("luma/chroma downsample ratio");
				}
			} else if (!((hv === 17))) {
				return new UnsupportedError("luma/chroma downsample ratio");
			}
			i = i + 1 >> 0;
		}
		return null;
	};
	decoder.prototype.processSOF = function(n) { return this.go$val.processSOF(n); };
0‚X
processDQT‚H	decoder.Ptr.prototype.processDQT = function(n) {
		var d, _tuple, err, pq, tq, _ref, _i, i;
		d = this;
		while (n >= 65) {
			_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 65)), err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			pq = d.tmp[0] >>> 4 << 24 >>> 24;
			if (!((pq === 0))) {
				return new UnsupportedError("bad Pq value");
			}
			tq = (d.tmp[0] & 15) >>> 0;
			if (tq > 3) {
				return new FormatError("bad Tq value");
			}
			_ref = d.quant[tq];
			_i = 0;
			while (_i < 64) {
				i = _i;
				d.quant[tq][i] = (d.tmp[(i + 1 >> 0)] >> 0);
				_i++;
			}
			n = n - 65 >> 0;
		}
		if (!((n === 0))) {
			return new FormatError("DQT has wrong length");
		}
		return null;
	};
	decoder.prototype.processDQT = function(n) { return this.go$val.processDQT(n); };
0‚ø
processDRI‚è	decoder.Ptr.prototype.processDRI = function(n) {
		var d, _tuple, err;
		d = this;
		if (!((n === 2))) {
			return new FormatError("DRI has wrong length");
		}
		_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 2)), err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		d.ri = ((d.tmp[0] >> 0) << 8 >> 0) + (d.tmp[1] >> 0) >> 0;
		return null;
	};
	decoder.prototype.processDRI = function(n) { return this.go$val.processDRI(n); };
0‚
Òdecode‚
Æ	decoder.Ptr.prototype.decode = function(r, configOnly) {
		var d, ok, _tuple, rr, _tuple$1, err, _tuple$2, err$1, _tuple$3, marker, _tuple$4, _tuple$5, n;
		d = this;
		if (_tuple = (r !== null && Reader.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), rr = _tuple[0], ok = _tuple[1], ok) {
			d.r = rr;
		} else {
			d.r = bufio.NewReader(r);
		}
		_tuple$1 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 2)), err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [null, err];
		}
		if (!((d.tmp[0] === 255)) || !((d.tmp[1] === 216))) {
			return [null, new FormatError("missing SOI marker")];
		}
		while (true) {
			_tuple$2 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 2)), err$1 = _tuple$2[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				return [null, err$1];
			}
			while (!((d.tmp[0] === 255))) {
				d.tmp[0] = d.tmp[1];
				_tuple$3 = d.r.ReadByte(), d.tmp[1] = _tuple$3[0], err$1 = _tuple$3[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					return [null, err$1];
				}
			}
			marker = d.tmp[1];
			if (marker === 0) {
				continue;
			}
			while (marker === 255) {
				_tuple$4 = d.r.ReadByte(), marker = _tuple$4[0], err$1 = _tuple$4[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					return [null, err$1];
				}
			}
			if (marker === 217) {
				break;
			}
			if (208 <= marker && marker <= 215) {
				continue;
			}
			_tuple$5 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 2)), err$1 = _tuple$5[1];
			if (!(go$interfaceIsEqual(err$1, null))) {
				return [null, err$1];
			}
			n = (((d.tmp[0] >> 0) << 8 >> 0) + (d.tmp[1] >> 0) >> 0) - 2 >> 0;
			if (n < 0) {
				return [null, new FormatError("short segment length")];
			}
			if ((marker === 192) || (marker === 194)) {
				d.progressive = marker === 194;
				err$1 = d.processSOF(n);
				if (configOnly) {
					return [null, err$1];
				}
			} else if (marker === 196) {
				err$1 = d.processDHT(n);
			} else if (marker === 219) {
				err$1 = d.processDQT(n);
			} else if (marker === 218) {
				err$1 = d.processSOS(n);
			} else if (marker === 221) {
				err$1 = d.processDRI(n);
			} else if (224 <= marker && marker <= 239 || (marker === 254)) {
				err$1 = d.ignore(n);
			} else {
				err$1 = new UnsupportedError("unknown marker");
			}
			if (!(go$interfaceIsEqual(err$1, null))) {
				return [null, err$1];
			}
		}
		if (!(d.img1 === (go$ptrType(image.Gray)).nil)) {
			return [d.img1, null];
		}
		if (!(d.img3 === (go$ptrType(image.YCbCr)).nil)) {
			return [d.img3, null];
		}
		return [null, new FormatError("missing SOS marker")];
	};
	decoder.prototype.decode = function(r, configOnly) { return this.go$val.decode(r, configOnly); };
0yDecodeo	var Decode = go$pkg.Decode = function(r) {
		var d;
		d = new decoder.Ptr();
		return d.decode(r, false);
	};
0‚DDecodeConfig‚2	var DecodeConfig = go$pkg.DecodeConfig = function(r) {
		var d, err, _tuple, _ref;
		d = new decoder.Ptr();
		if (_tuple = d.decode(r, true), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return [new image.Config.Ptr(null, 0, 0), err];
		}
		_ref = d.nComp;
		if (_ref === 1) {
			return [new image.Config.Ptr(color.GrayModel, d.width, d.height), null];
		} else if (_ref === 3) {
			return [new image.Config.Ptr(color.YCbCrModel, d.width, d.height), null];
		}
		return [new image.Config.Ptr(null, 0, 0), new FormatError("missing SOF marker")];
	};
0‚	¿makeImg‚	²	decoder.Ptr.prototype.makeImg = function(h0, v0, mxx, myy) {
		var d, x, x$1, _struct, _struct$1, _struct$2, m, x$2, _struct$3, _struct$4, _struct$5, subsampleRatio, x$3, x$4, x$5, x$6, _struct$6, _struct$7, _struct$8, m$1, x$7, _struct$9, _struct$10, _struct$11;
		d = this;
		if (d.nComp === 1) {
			m = image.NewGray((_struct = image.Rect(0, 0, (x = 8, (((x >>> 16 << 16) * mxx >> 0) + (x << 16 >>> 16) * mxx) >> 0), (x$1 = 8, (((x$1 >>> 16 << 16) * myy >> 0) + (x$1 << 16 >>> 16) * myy) >> 0)), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y)))));
			d.img1 = (x$2 = m.SubImage((_struct$3 = image.Rect(0, 0, d.width, d.height), new image.Rectangle.Ptr((_struct$4 = _struct$3.Min, new image.Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new image.Point.Ptr(_struct$5.X, _struct$5.Y))))), (x$2 !== null && x$2.constructor === (go$ptrType(image.Gray)) ? x$2.go$val : go$typeAssertionFailed(x$2, (go$ptrType(image.Gray)))));
			return;
		}
		subsampleRatio = 0;
		if ((h0 === 1) && (v0 === 1)) {
			subsampleRatio = 0;
		} else if ((h0 === 1) && (v0 === 2)) {
			subsampleRatio = 3;
		} else if ((h0 === 2) && (v0 === 1)) {
			subsampleRatio = 1;
		} else if ((h0 === 2) && (v0 === 2)) {
			subsampleRatio = 2;
		} else {
			throw go$panic(new Go$String("unreachable"));
		}
		m$1 = image.NewYCbCr((_struct$6 = image.Rect(0, 0, (x$3 = (x$4 = 8, (((x$4 >>> 16 << 16) * h0 >> 0) + (x$4 << 16 >>> 16) * h0) >> 0), (((x$3 >>> 16 << 16) * mxx >> 0) + (x$3 << 16 >>> 16) * mxx) >> 0), (x$5 = (x$6 = 8, (((x$6 >>> 16 << 16) * v0 >> 0) + (x$6 << 16 >>> 16) * v0) >> 0), (((x$5 >>> 16 << 16) * myy >> 0) + (x$5 << 16 >>> 16) * myy) >> 0)), new image.Rectangle.Ptr((_struct$7 = _struct$6.Min, new image.Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new image.Point.Ptr(_struct$8.X, _struct$8.Y)))), subsampleRatio);
		d.img3 = (x$7 = m$1.SubImage((_struct$9 = image.Rect(0, 0, d.width, d.height), new image.Rectangle.Ptr((_struct$10 = _struct$9.Min, new image.Point.Ptr(_struct$10.X, _struct$10.Y)), (_struct$11 = _struct$9.Max, new image.Point.Ptr(_struct$11.X, _struct$11.Y))))), (x$7 !== null && x$7.constructor === (go$ptrType(image.YCbCr)) ? x$7.go$val : go$typeAssertionFailed(x$7, (go$ptrType(image.YCbCr)))));
	};
	decoder.prototype.makeImg = function(h0, v0, mxx, myy) { return this.go$val.makeImg(h0, v0, mxx, myy); };
0‚7È
processSOS‚7¸	decoder.Ptr.prototype.processSOS = function(n) {
		var d, x, x$1, _r, _tuple, err, nComp, x$2, scan, i, x$3, cs, compIndex, _ref, _i, _struct, comp, j, x$4, x$5, _tuple$1, zigStart, zigEnd, ah, al, x$6, x$7, x$8, x$9, _tuple$2, h0, v0, _q, x$10, x$11, mxx, _q$1, x$12, x$13, myy, i$1, compIndex$1, x$14, x$15, x$16, x$17, _tuple$3, mcu, expectedRST, b, dc, _tuple$4, mx0, my0, blockCount, my, mx, i$2, compIndex$2, qt, j$1, x$18, x$19, x$20, x$21, _tuple$5, _r$1, _q$2, x$22, q, _r$2, _q$3, x$23, x$24, _slice, _index, x$25, x$26, err$1, y, zig, _tuple$6, value, err$2, _tuple$7, dcDelta, _lhs, _index$1, y$1, _tuple$8, value$1, err$3, val0, val1, _tuple$9, ac, err$4, y$2, y$3, _tuple$10, bits$1, err$5, _slice$1, _index$2, x$27, x$28, zig$1, _lhs$1, _index$3, x$29, x$30, _tuple$11, dst, stride, x$31, x$32, x$33, _tuple$12, _ref$1, x$34, x$35, x$36, _tuple$13, x$37, x$38, x$39, _tuple$14, x$40, x$41, x$42, _tuple$15, y$4, x$43, y8, yStride, x$44, c, _slice$2, _index$4, _r$3, _tuple$16, err$6;
		d = this;
		if (d.nComp === 0) {
			return new FormatError("missing SOF marker");
		}
		if (n < 6 || (4 + (x = 2, x$1 = d.nComp, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) >> 0) < n || !(((_r = n % 2, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0))) {
			return new FormatError("SOS has wrong length");
		}
		_tuple = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, n)), err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return err;
		}
		nComp = (d.tmp[0] >> 0);
		if (!((n === (4 + (x$2 = 2, (((x$2 >>> 16 << 16) * nComp >> 0) + (x$2 << 16 >>> 16) * nComp) >> 0) >> 0)))) {
			return new FormatError("SOS length inconsistent with number of components");
		}
		scan = go$makeNativeArray("Struct", 3, function() { return new (go$structType([["compIndex", "image/jpeg", Go$Uint8, ""], ["td", "image/jpeg", Go$Uint8, ""], ["ta", "image/jpeg", Go$Uint8, ""]])).Ptr(0, 0, 0); });
		i = 0;
		while (i < nComp) {
			cs = d.tmp[(1 + (x$3 = 2, (((x$3 >>> 16 << 16) * i >> 0) + (x$3 << 16 >>> 16) * i) >> 0) >> 0)];
			compIndex = -1;
			_ref = d.comp;
			_i = 0;
			while (_i < 3) {
				comp = (_struct = _ref[_i], new component.Ptr(_struct.h, _struct.v, _struct.c, _struct.tq));
				j = _i;
				if (cs === comp.c) {
					compIndex = j;
				}
				_i++;
			}
			if (compIndex < 0) {
				return new FormatError("unknown component selector");
			}
			scan[i].compIndex = (compIndex << 24 >>> 24);
			scan[i].td = d.tmp[(2 + (x$4 = 2, (((x$4 >>> 16 << 16) * i >> 0) + (x$4 << 16 >>> 16) * i) >> 0) >> 0)] >>> 4 << 24 >>> 24;
			scan[i].ta = (d.tmp[(2 + (x$5 = 2, (((x$5 >>> 16 << 16) * i >> 0) + (x$5 << 16 >>> 16) * i) >> 0) >> 0)] & 15) >>> 0;
			i = i + 1 >> 0;
		}
		_tuple$1 = [0, 63, 0, 0], zigStart = _tuple$1[0], zigEnd = _tuple$1[1], ah = _tuple$1[2], al = _tuple$1[3];
		if (d.progressive) {
			zigStart = (d.tmp[(1 + (x$6 = 2, (((x$6 >>> 16 << 16) * nComp >> 0) + (x$6 << 16 >>> 16) * nComp) >> 0) >> 0)] >> 0);
			zigEnd = (d.tmp[(2 + (x$7 = 2, (((x$7 >>> 16 << 16) * nComp >> 0) + (x$7 << 16 >>> 16) * nComp) >> 0) >> 0)] >> 0);
			ah = ((d.tmp[(3 + (x$8 = 2, (((x$8 >>> 16 << 16) * nComp >> 0) + (x$8 << 16 >>> 16) * nComp) >> 0) >> 0)] >>> 4 << 24 >>> 24) >>> 0);
			al = (((d.tmp[(3 + (x$9 = 2, (((x$9 >>> 16 << 16) * nComp >> 0) + (x$9 << 16 >>> 16) * nComp) >> 0) >> 0)] & 15) >>> 0) >>> 0);
			if (((zigStart === 0) && !((zigEnd === 0))) || zigStart > zigEnd || 64 <= zigEnd) {
				return new FormatError("bad spectral selection bounds");
			}
			if (!((zigStart === 0)) && !((nComp === 1))) {
				return new FormatError("progressive AC coefficients for more than one component");
			}
			if (!((ah === 0)) && !((ah === (al + 1 >>> 0)))) {
				return new FormatError("bad successive approximation values");
			}
		}
		_tuple$2 = [d.comp[0].h, d.comp[0].v], h0 = _tuple$2[0], v0 = _tuple$2[1];
		mxx = (_q = (((d.width + (x$10 = 8, (((x$10 >>> 16 << 16) * h0 >> 0) + (x$10 << 16 >>> 16) * h0) >> 0) >> 0) - 1 >> 0)) / ((x$11 = 8, (((x$11 >>> 16 << 16) * h0 >> 0) + (x$11 << 16 >>> 16) * h0) >> 0)), (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		myy = (_q$1 = (((d.height + (x$12 = 8, (((x$12 >>> 16 << 16) * v0 >> 0) + (x$12 << 16 >>> 16) * v0) >> 0) >> 0) - 1 >> 0)) / ((x$13 = 8, (((x$13 >>> 16 << 16) * v0 >> 0) + (x$13 << 16 >>> 16) * v0) >> 0)), (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
		if (d.img1 === (go$ptrType(image.Gray)).nil && d.img3 === (go$ptrType(image.YCbCr)).nil) {
			d.makeImg(h0, v0, mxx, myy);
		}
		if (d.progressive) {
			i$1 = 0;
			while (i$1 < nComp) {
				compIndex$1 = scan[i$1].compIndex;
				if (d.progCoeffs[compIndex$1] === (go$sliceType(block)).nil) {
					d.progCoeffs[compIndex$1] = (go$sliceType(block)).make((x$14 = (x$15 = (((mxx >>> 16 << 16) * myy >> 0) + (mxx << 16 >>> 16) * myy) >> 0, x$16 = d.comp[compIndex$1].h, (((x$15 >>> 16 << 16) * x$16 >> 0) + (x$15 << 16 >>> 16) * x$16) >> 0), x$17 = d.comp[compIndex$1].v, (((x$14 >>> 16 << 16) * x$17 >> 0) + (x$14 << 16 >>> 16) * x$17) >> 0), 0, function() { return go$makeNativeArray("Int32", 64, function() { return 0; }); });
				}
				i$1 = i$1 + 1 >> 0;
			}
		}
		d.b = new bits.Ptr(0, 0, 0);
		_tuple$3 = [0, 208], mcu = _tuple$3[0], expectedRST = _tuple$3[1];
		b = go$makeNativeArray("Int32", 64, function() { return 0; }), dc = go$makeNativeArray("Int32", 3, function() { return 0; }), _tuple$4 = [0, 0], mx0 = _tuple$4[0], my0 = _tuple$4[1], blockCount = 0;
		my = 0;
		while (my < myy) {
			mx = 0;
			while (mx < mxx) {
				i$2 = 0;
				while (i$2 < nComp) {
					compIndex$2 = scan[i$2].compIndex;
					qt = d.quant[d.comp[compIndex$2].tq];
					j$1 = 0;
					while (j$1 < (x$18 = d.comp[compIndex$2].h, x$19 = d.comp[compIndex$2].v, (((x$18 >>> 16 << 16) * x$19 >> 0) + (x$18 << 16 >>> 16) * x$19) >> 0)) {
						if (zigStart === 0) {
							_tuple$5 = [(x$20 = d.comp[compIndex$2].h, (((x$20 >>> 16 << 16) * mx >> 0) + (x$20 << 16 >>> 16) * mx) >> 0), (x$21 = d.comp[compIndex$2].v, (((x$21 >>> 16 << 16) * my >> 0) + (x$21 << 16 >>> 16) * my) >> 0)], mx0 = _tuple$5[0], my0 = _tuple$5[1];
							if (h0 === 1) {
								my0 = my0 + (j$1) >> 0;
							} else {
								mx0 = mx0 + ((_r$1 = j$1 % 2, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero"))) >> 0;
								my0 = my0 + ((_q$2 = j$1 / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero"))) >> 0;
							}
						} else {
							q = (x$22 = d.comp[compIndex$2].h, (((mxx >>> 16 << 16) * x$22 >> 0) + (mxx << 16 >>> 16) * x$22) >> 0);
							mx0 = (_r$2 = blockCount % q, _r$2 === _r$2 ? _r$2 : go$throwRuntimeError("integer divide by zero"));
							my0 = (_q$3 = blockCount / q, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : go$throwRuntimeError("integer divide by zero"));
							blockCount = blockCount + 1 >> 0;
							if ((x$23 = 8, (((mx0 >>> 16 << 16) * x$23 >> 0) + (mx0 << 16 >>> 16) * x$23) >> 0) >= d.width || (x$24 = 8, (((my0 >>> 16 << 16) * x$24 >> 0) + (my0 << 16 >>> 16) * x$24) >> 0) >= d.height) {
								j$1 = j$1 + 1 >> 0;
								continue;
							}
						}
						if (d.progressive) {
							b = go$mapArray((_slice = d.progCoeffs[compIndex$2], _index = ((x$25 = (((my0 >>> 16 << 16) * mxx >> 0) + (my0 << 16 >>> 16) * mxx) >> 0, x$26 = d.comp[compIndex$2].h, (((x$25 >>> 16 << 16) * x$26 >> 0) + (x$25 << 16 >>> 16) * x$26) >> 0) + mx0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), function(entry) { return entry; });
						} else {
							b = go$makeNativeArray("Int32", 64, function() { return 0; });
						}
						if (!((ah === 0))) {
							if (err$1 = d.refine(b, d.huff[1][scan[i$2].ta], zigStart, zigEnd, (y = al, y < 32 ? (1 << y) : 0) >> 0), !(go$interfaceIsEqual(err$1, null))) {
								return err$1;
							}
						} else {
							zig = zigStart;
							if (zig === 0) {
								zig = zig + 1 >> 0;
								_tuple$6 = d.decodeHuffman(d.huff[0][scan[i$2].td]), value = _tuple$6[0], err$2 = _tuple$6[1];
								if (!(go$interfaceIsEqual(err$2, null))) {
									return err$2;
								}
								if (value > 16) {
									return new UnsupportedError("excessive DC component");
								}
								_tuple$7 = d.receiveExtend(value), dcDelta = _tuple$7[0], err$2 = _tuple$7[1];
								if (!(go$interfaceIsEqual(err$2, null))) {
									return err$2;
								}
								_lhs = dc, _index$1 = compIndex$2, _lhs[_index$1] = _lhs[_index$1] + (dcDelta) >> 0;
								b[0] = (y$1 = al, y$1 < 32 ? (dc[compIndex$2] << y$1) : 0) >> 0;
							}
							if (zig <= zigEnd && d.eobRun > 0) {
								d.eobRun = d.eobRun - 1 << 16 >>> 16;
							} else {
								while (zig <= zigEnd) {
									_tuple$8 = d.decodeHuffman(d.huff[1][scan[i$2].ta]), value$1 = _tuple$8[0], err$3 = _tuple$8[1];
									if (!(go$interfaceIsEqual(err$3, null))) {
										return err$3;
									}
									val0 = value$1 >>> 4 << 24 >>> 24;
									val1 = (value$1 & 15) >>> 0;
									if (!((val1 === 0))) {
										zig = zig + ((val0 >> 0)) >> 0;
										if (zig > zigEnd) {
											break;
										}
										_tuple$9 = d.receiveExtend(val1), ac = _tuple$9[0], err$4 = _tuple$9[1];
										if (!(go$interfaceIsEqual(err$4, null))) {
											return err$4;
										}
										b[unzig[zig]] = (y$2 = al, y$2 < 32 ? (ac << y$2) : 0) >> 0;
									} else {
										if (!((val0 === 15))) {
											d.eobRun = ((y$3 = val0, y$3 < 32 ? (1 << y$3) : 0) << 16 >>> 16);
											if (!((val0 === 0))) {
												_tuple$10 = d.decodeBits((val0 >> 0)), bits$1 = _tuple$10[0], err$5 = _tuple$10[1];
												if (!(go$interfaceIsEqual(err$5, null))) {
													return err$5;
												}
												d.eobRun = (d.eobRun | ((bits$1 << 16 >>> 16))) >>> 0;
											}
											d.eobRun = d.eobRun - 1 << 16 >>> 16;
											break;
										}
										zig = zig + 15 >> 0;
									}
									zig = zig + 1 >> 0;
								}
							}
						}
						if (d.progressive) {
							if (!((zigEnd === 63)) || !((al === 0))) {
								_slice$1 = d.progCoeffs[compIndex$2], _index$2 = (x$27 = (((my0 >>> 16 << 16) * mxx >> 0) + (my0 << 16 >>> 16) * mxx) >> 0, x$28 = d.comp[compIndex$2].h, (((x$27 >>> 16 << 16) * x$28 >> 0) + (x$27 << 16 >>> 16) * x$28) >> 0) + mx0 >> 0, (_index$2 >= 0 && _index$2 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$2] = go$mapArray(b, function(entry) { return entry; })) : go$throwRuntimeError("index out of range");
								j$1 = j$1 + 1 >> 0;
								continue;
							}
						}
						zig$1 = 0;
						while (zig$1 < 64) {
							_lhs$1 = b, _index$3 = unzig[zig$1], _lhs$1[_index$3] = (x$29 = _lhs$1[_index$3], x$30 = qt[zig$1], (((x$29 >>> 16 << 16) * x$30 >> 0) + (x$29 << 16 >>> 16) * x$30) >> 0);
							zig$1 = zig$1 + 1 >> 0;
						}
						idct(b);
						_tuple$11 = [(go$sliceType(Go$Uint8)).nil, 0], dst = _tuple$11[0], stride = _tuple$11[1];
						if (d.nComp === 1) {
							_tuple$12 = [go$subslice(d.img1.Pix, (x$31 = 8, x$32 = ((x$33 = d.img1.Stride, (((my0 >>> 16 << 16) * x$33 >> 0) + (my0 << 16 >>> 16) * x$33) >> 0) + mx0 >> 0), (((x$31 >>> 16 << 16) * x$32 >> 0) + (x$31 << 16 >>> 16) * x$32) >> 0)), d.img1.Stride], dst = _tuple$12[0], stride = _tuple$12[1];
						} else {
							_ref$1 = compIndex$2;
							if (_ref$1 === 0) {
								_tuple$13 = [go$subslice(d.img3.Y, (x$34 = 8, x$35 = ((x$36 = d.img3.YStride, (((my0 >>> 16 << 16) * x$36 >> 0) + (my0 << 16 >>> 16) * x$36) >> 0) + mx0 >> 0), (((x$34 >>> 16 << 16) * x$35 >> 0) + (x$34 << 16 >>> 16) * x$35) >> 0)), d.img3.YStride], dst = _tuple$13[0], stride = _tuple$13[1];
							} else if (_ref$1 === 1) {
								_tuple$14 = [go$subslice(d.img3.Cb, (x$37 = 8, x$38 = ((x$39 = d.img3.CStride, (((my0 >>> 16 << 16) * x$39 >> 0) + (my0 << 16 >>> 16) * x$39) >> 0) + mx0 >> 0), (((x$37 >>> 16 << 16) * x$38 >> 0) + (x$37 << 16 >>> 16) * x$38) >> 0)), d.img3.CStride], dst = _tuple$14[0], stride = _tuple$14[1];
							} else if (_ref$1 === 2) {
								_tuple$15 = [go$subslice(d.img3.Cr, (x$40 = 8, x$41 = ((x$42 = d.img3.CStride, (((my0 >>> 16 << 16) * x$42 >> 0) + (my0 << 16 >>> 16) * x$42) >> 0) + mx0 >> 0), (((x$40 >>> 16 << 16) * x$41 >> 0) + (x$40 << 16 >>> 16) * x$41) >> 0)), d.img3.CStride], dst = _tuple$15[0], stride = _tuple$15[1];
							} else {
								return new UnsupportedError("too many components");
							}
						}
						y$4 = 0;
						while (y$4 < 8) {
							y8 = (x$43 = 8, (((y$4 >>> 16 << 16) * x$43 >> 0) + (y$4 << 16 >>> 16) * x$43) >> 0);
							yStride = (((y$4 >>> 16 << 16) * stride >> 0) + (y$4 << 16 >>> 16) * stride) >> 0;
							x$44 = 0;
							while (x$44 < 8) {
								c = b[(y8 + x$44 >> 0)];
								if (c < -128) {
									c = 0;
								} else if (c > 127) {
									c = 255;
								} else {
									c = c + 128 >> 0;
								}
								_slice$2 = dst, _index$4 = yStride + x$44 >> 0, (_index$4 >= 0 && _index$4 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$4] = (c << 24 >>> 24)) : go$throwRuntimeError("index out of range");
								x$44 = x$44 + 1 >> 0;
							}
							y$4 = y$4 + 1 >> 0;
						}
						j$1 = j$1 + 1 >> 0;
					}
					i$2 = i$2 + 1 >> 0;
				}
				mcu = mcu + 1 >> 0;
				if (d.ri > 0 && ((_r$3 = mcu % d.ri, _r$3 === _r$3 ? _r$3 : go$throwRuntimeError("integer divide by zero")) === 0) && mcu < ((((mxx >>> 16 << 16) * myy >> 0) + (mxx << 16 >>> 16) * myy) >> 0)) {
					_tuple$16 = io.ReadFull(d.r, go$subslice(new (go$sliceType(Go$Uint8))(d.tmp), 0, 2)), err$6 = _tuple$16[1];
					if (!(go$interfaceIsEqual(err$6, null))) {
						return err$6;
					}
					if (!((d.tmp[0] === 255)) || !((d.tmp[1] === expectedRST))) {
						return new FormatError("bad RST marker");
					}
					expectedRST = expectedRST + 1 << 24 >>> 24;
					if (expectedRST === 216) {
						expectedRST = 208;
					}
					d.b = new bits.Ptr(0, 0, 0);
					dc = go$makeNativeArray("Int32", 3, function() { return 0; });
					d.eobRun = 0;
				}
				mx = mx + 1 >> 0;
			}
			my = my + 1 >> 0;
		}
		return null;
	};
	decoder.prototype.processSOS = function(n) { return this.go$val.processSOS(n); };
0‚	9refine‚	-	decoder.Ptr.prototype.refine = function(b, h, zigStart, zigEnd, delta) {
		var d, _tuple, bit, err, _lhs, _index, zig, z, _tuple$1, value, err$1, val0, val1, _ref, y, _tuple$2, bits$1, err$2, _tuple$3, bit$1, err$3, _tuple$4, err$4, _tuple$5;
		d = this;
		if (zigStart === 0) {
			if (!((zigEnd === 0))) {
				throw go$panic(new Go$String("unreachable"));
			}
			_tuple = d.decodeBit(), bit = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return err;
			}
			if (bit) {
				_lhs = b, _index = 0, _lhs[_index] = _lhs[_index] | (delta);
			}
			return null;
		}
		zig = zigStart;
		if (d.eobRun === 0) {
			loop: while (zig <= zigEnd) {
				z = 0;
				_tuple$1 = d.decodeHuffman(h), value = _tuple$1[0], err$1 = _tuple$1[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					return err$1;
				}
				val0 = value >>> 4 << 24 >>> 24;
				val1 = (value & 15) >>> 0;
				_ref = val1;
				if (_ref === 0) {
					if (!((val0 === 15))) {
						d.eobRun = ((y = val0, y < 32 ? (1 << y) : 0) << 16 >>> 16);
						if (!((val0 === 0))) {
							_tuple$2 = d.decodeBits((val0 >> 0)), bits$1 = _tuple$2[0], err$2 = _tuple$2[1];
							if (!(go$interfaceIsEqual(err$2, null))) {
								return err$2;
							}
							d.eobRun = (d.eobRun | ((bits$1 << 16 >>> 16))) >>> 0;
						}
						break loop;
					}
				} else if (_ref === 1) {
					z = delta;
					_tuple$3 = d.decodeBit(), bit$1 = _tuple$3[0], err$3 = _tuple$3[1];
					if (!(go$interfaceIsEqual(err$3, null))) {
						return err$3;
					}
					if (!bit$1) {
						z = -z;
					}
				} else {
					return new FormatError("unexpected Huffman code");
				}
				_tuple$4 = d.refineNonZeroes(b, zig, zigEnd, (val0 >> 0), delta), zig = _tuple$4[0], err$1 = _tuple$4[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					return err$1;
				}
				if (zig > zigEnd) {
					return new FormatError("too many coefficients");
				}
				if (!((z === 0))) {
					b[unzig[zig]] = z;
				}
				zig = zig + 1 >> 0;
			}
		}
		if (d.eobRun > 0) {
			d.eobRun = d.eobRun - 1 << 16 >>> 16;
			if (_tuple$5 = d.refineNonZeroes(b, zig, zigEnd, -1, delta), err$4 = _tuple$5[1], !(go$interfaceIsEqual(err$4, null))) {
				return err$4;
			}
		}
		return null;
	};
	decoder.prototype.refine = function(b, h, zigStart, zigEnd, delta) { return this.go$val.refine(b, h, zigStart, zigEnd, delta); };
0‚“refineNonZeroes‚~	decoder.Ptr.prototype.refineNonZeroes = function(b, zig, zigEnd, nz, delta) {
		var d, u, _tuple, bit, err, _lhs, _index, _lhs$1, _index$1;
		d = this;
		while (zig <= zigEnd) {
			u = unzig[zig];
			if (b[u] === 0) {
				if (nz === 0) {
					break;
				}
				nz = nz - 1 >> 0;
				zig = zig + 1 >> 0;
				continue;
			}
			_tuple = d.decodeBit(), bit = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [0, err];
			}
			if (!bit) {
				zig = zig + 1 >> 0;
				continue;
			}
			if (b[u] >= 0) {
				_lhs = b, _index = u, _lhs[_index] = _lhs[_index] + (delta) >> 0;
			} else {
				_lhs$1 = b, _index$1 = u, _lhs$1[_index$1] = _lhs$1[_index$1] - (delta) >> 0;
			}
			zig = zig + 1 >> 0;
		}
		return [zig, null];
	};
	decoder.prototype.refineNonZeroes = function(b, zig, zigEnd, nz, delta) { return this.go$val.refineNonZeroes(b, zig, zigEnd, nz, delta); };
0SminL	var min = function(x, y) {
		if (x < y) {
			return x;
		}
		return y;
	};
0‚Œdiv‚ƒ	var div = function(a, b) {
		var _q, _q$1;
		if (a >= 0) {
			return (_q = ((a + ((b >> 1 >> 0)) >> 0)) / b, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		}
		return -((_q$1 = ((-a + ((b >> 1 >> 0)) >> 0)) / b, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")));
	};
0‚Îinit‚Ä	go$ptrType(huffmanLUT).prototype.init = function(s) {
		var h, maxValue, _ref, _i, _slice, _index, v, x, _tuple, code, k, i, nBits, j, _slice$1, _index$1, _slice$2, _index$2;
		h = this;
		maxValue = 0;
		_ref = s.value;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if ((v >> 0) > maxValue) {
				maxValue = (v >> 0);
			}
			_i++;
		}
		h.go$set((x = (go$sliceType(Go$Uint32)).make(maxValue + 1 >> 0, 0, function() { return 0; }), go$subslice(new huffmanLUT(x.array), x.offset, x.offset + x.length)));
		_tuple = [0, 0], code = _tuple[0], k = _tuple[1];
		i = 0;
		while (i < 16) {
			nBits = ((i + 1 >> 0) >>> 0) << 24 >>> 0;
			j = 0;
			while (j < s.count[i]) {
				_slice$1 = h.go$get(), _index$1 = (_slice$2 = s.value, _index$2 = k, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (nBits | code) >>> 0) : go$throwRuntimeError("index out of range");
				code = code + 1 >>> 0;
				k = k + 1 >> 0;
				j = j + 1 << 24 >>> 24;
			}
			code = code << 1 >>> 0;
			i = i + 1 >> 0;
		}
	};
	huffmanLUT.prototype.init = function(s) { var obj = this; return (new (go$ptrType(huffmanLUT))(function() { return obj; }, null)).init(s); };
0éflushß	encoder.Ptr.prototype.flush = function() {
		var e;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		e.err = e.w.Flush();
	};
	encoder.prototype.flush = function() { return this.go$val.flush(); };
0‚	writeÿ	encoder.Ptr.prototype.write = function(p) {
		var e, _tuple;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		_tuple = e.w.Write(p), e.err = _tuple[1];
	};
	encoder.prototype.write = function(p) { return this.go$val.write(p); };
0‚	writeByteó	encoder.Ptr.prototype.writeByte = function(b) {
		var e;
		e = this;
		if (!(go$interfaceIsEqual(e.err, null))) {
			return;
		}
		e.err = e.w.WriteByte(b);
	};
	encoder.prototype.writeByte = function(b) { return this.go$val.writeByte(b); };
0‚bemit‚X	encoder.Ptr.prototype.emit = function(bits$1, nBits) {
		var e, y, b, _tuple;
		e = this;
		nBits = nBits + (e.nBits) >>> 0;
		bits$1 = (y = ((32 - nBits >>> 0)), y < 32 ? (bits$1 << y) : 0) >>> 0;
		bits$1 = (bits$1 | (e.bits)) >>> 0;
		while (nBits >= 8) {
			b = ((bits$1 >>> 24 >>> 0) << 24 >>> 24);
			e.writeByte(b);
			if (b === 255) {
				e.writeByte(0);
			}
			bits$1 = bits$1 << 8 >>> 0;
			nBits = nBits - 8 >>> 0;
		}
		_tuple = [bits$1, nBits], e.bits = _tuple[0], e.nBits = _tuple[1];
	};
	encoder.prototype.emit = function(bits$1, nBits) { return this.go$val.emit(bits$1, nBits); };
0‚®emitHuff‚ 	encoder.Ptr.prototype.emitHuff = function(h, value) {
		var e, _slice, _index, x;
		e = this;
		x = (_slice = theHuffmanLUT[h], _index = value, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		e.emit((x & 16777215) >>> 0, x >>> 24 >>> 0);
	};
	encoder.prototype.emitHuff = function(h, value) { return this.go$val.emitHuff(h, value); };
0‚ÑemitHuffRLE‚À	encoder.Ptr.prototype.emitHuffRLE = function(h, runLength, value) {
		var e, _tuple, a, b, _tuple$1, nBits, y;
		e = this;
		_tuple = [value, value], a = _tuple[0], b = _tuple[1];
		if (a < 0) {
			_tuple$1 = [-value, value - 1 >> 0], a = _tuple$1[0], b = _tuple$1[1];
		}
		nBits = 0;
		if (a < 256) {
			nBits = (bitCount[a] >>> 0);
		} else {
			nBits = 8 + (bitCount[(a >> 8 >> 0)] >>> 0) >>> 0;
		}
		e.emitHuff(h, (runLength << 4 >> 0) | (nBits >> 0));
		if (nBits > 0) {
			e.emit(((b >>> 0) & ((((y = nBits, y < 32 ? (1 << y) : 0) >>> 0) - 1 >>> 0))) >>> 0, nBits);
		}
	};
	encoder.prototype.emitHuffRLE = function(h, runLength, value) { return this.go$val.emitHuffRLE(h, runLength, value); };
0‚ÆwriteMarkerHeader‚¯	encoder.Ptr.prototype.writeMarkerHeader = function(marker, markerlen) {
		var e;
		e = this;
		e.buf[0] = 255;
		e.buf[1] = marker;
		e.buf[2] = ((markerlen >> 8 >> 0) << 24 >>> 24);
		e.buf[3] = ((markerlen & 255) << 24 >>> 24);
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 4));
	};
	encoder.prototype.writeMarkerHeader = function(marker, markerlen) { return this.go$val.writeMarkerHeader(marker, markerlen); };
0‚pwriteDQT‚b	encoder.Ptr.prototype.writeDQT = function() {
		var e, _ref, _i, i;
		e = this;
		e.writeMarkerHeader(219, 132);
		_ref = e.quant;
		_i = 0;
		while (_i < 2) {
			i = _i;
			e.writeByte((i << 24 >>> 24));
			e.write(new (go$sliceType(Go$Uint8))(e.quant[i]));
			_i++;
		}
	};
	encoder.prototype.writeDQT = function() { return this.go$val.writeDQT(); };
0‚œ	writeSOF0‚	encoder.Ptr.prototype.writeSOF0 = function(size) {
		var e, i, x, x$1, x$2;
		e = this;
		e.writeMarkerHeader(192, 17);
		e.buf[0] = 8;
		e.buf[1] = ((size.Y >> 8 >> 0) << 24 >>> 24);
		e.buf[2] = ((size.Y & 255) << 24 >>> 24);
		e.buf[3] = ((size.X >> 8 >> 0) << 24 >>> 24);
		e.buf[4] = ((size.X & 255) << 24 >>> 24);
		e.buf[5] = 3;
		i = 0;
		while (i < 3) {
			e.buf[(x = 3, (((x >>> 16 << 16) * i >> 0) + (x << 16 >>> 16) * i) >> 0) + 6 >> 0] = ((i + 1 >> 0) << 24 >>> 24);
			e.buf[(x$1 = 3, (((x$1 >>> 16 << 16) * i >> 0) + (x$1 << 16 >>> 16) * i) >> 0) + 7 >> 0] = "\"\x11\x11".charCodeAt(i);
			e.buf[(x$2 = 3, (((x$2 >>> 16 << 16) * i >> 0) + (x$2 << 16 >>> 16) * i) >> 0) + 8 >> 0] = "\x00\x01\x01".charCodeAt(i);
			i = i + 1 >> 0;
		}
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 15));
	};
	encoder.prototype.writeSOF0 = function(size) { return this.go$val.writeSOF0(size); };
0‚€writeDHT‚r	encoder.Ptr.prototype.writeDHT = function() {
		var e, markerlen, _ref, _i, _struct, s, _ref$1, _i$1, _struct$1, s$1, i;
		e = this;
		markerlen = 2;
		_ref = theHuffmanSpec;
		_i = 0;
		while (_i < 4) {
			s = (_struct = _ref[_i], new huffmanSpec.Ptr(go$mapArray(_struct.count, function(entry) { return entry; }), _struct.value));
			markerlen = markerlen + ((17 + s.value.length >> 0)) >> 0;
			_i++;
		}
		e.writeMarkerHeader(196, markerlen);
		_ref$1 = theHuffmanSpec;
		_i$1 = 0;
		while (_i$1 < 4) {
			s$1 = (_struct$1 = _ref$1[_i$1], new huffmanSpec.Ptr(go$mapArray(_struct$1.count, function(entry) { return entry; }), _struct$1.value));
			i = _i$1;
			e.writeByte("\x00\x10\x01\x11".charCodeAt(i));
			e.write(new (go$sliceType(Go$Uint8))(s$1.count));
			e.write(s$1.value);
			_i$1++;
		}
	};
	encoder.prototype.writeDHT = function() { return this.go$val.writeDHT(); };
0‚…
writeBlock‚u	encoder.Ptr.prototype.writeBlock = function(b, q, prevDC) {
		var e, x, x$1, dc, x$2, x$3, _tuple, h, runLength, zig, x$4, x$5, ac;
		e = this;
		fdct(b);
		dc = div(b[0], (x = 8, x$1 = (e.quant[q][0] >> 0), (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0));
		e.emitHuffRLE((((x$2 = 2, (((x$2 >>> 16 << 16) * q >> 0) + (x$2 << 16 >>> 16) * q) >> 0) + 0 >> 0) >> 0), 0, dc - prevDC >> 0);
		_tuple = [(((x$3 = 2, (((x$3 >>> 16 << 16) * q >> 0) + (x$3 << 16 >>> 16) * q) >> 0) + 1 >> 0) >> 0), 0], h = _tuple[0], runLength = _tuple[1];
		zig = 1;
		while (zig < 64) {
			ac = div(b[unzig[zig]], (x$4 = 8, x$5 = (e.quant[q][zig] >> 0), (((x$4 >>> 16 << 16) * x$5 >> 0) + (x$4 << 16 >>> 16) * x$5) >> 0));
			if (ac === 0) {
				runLength = runLength + 1 >> 0;
			} else {
				while (runLength > 15) {
					e.emitHuff(h, 240);
					runLength = runLength - 16 >> 0;
				}
				e.emitHuffRLE(h, runLength, ac);
				runLength = 0;
			}
			zig = zig + 1 >> 0;
		}
		if (runLength > 0) {
			e.emitHuff(h, 0);
		}
		return dc;
	};
	encoder.prototype.writeBlock = function(b, q, prevDC) { return this.go$val.writeBlock(b, q, prevDC); };
0‚•toYCbCr‚ˆ	var toYCbCr = function(m, p, yBlock, cbBlock, crBlock) {
		var _struct, _struct$1, _struct$2, b, xmax, ymax, j, i, _tuple, r, g, b$1, _tuple$1, yy, cb, cr, x, x$1, x$2;
		b = (_struct = m.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		xmax = b.Max.X - 1 >> 0;
		ymax = b.Max.Y - 1 >> 0;
		j = 0;
		while (j < 8) {
			i = 0;
			while (i < 8) {
				_tuple = m.At(min(p.X + i >> 0, xmax), min(p.Y + j >> 0, ymax)).RGBA(), r = _tuple[0], g = _tuple[1], b$1 = _tuple[2];
				_tuple$1 = color.RGBToYCbCr(((r >>> 8 >>> 0) << 24 >>> 24), ((g >>> 8 >>> 0) << 24 >>> 24), ((b$1 >>> 8 >>> 0) << 24 >>> 24)), yy = _tuple$1[0], cb = _tuple$1[1], cr = _tuple$1[2];
				yBlock[(x = 8, (((x >>> 16 << 16) * j >> 0) + (x << 16 >>> 16) * j) >> 0) + i >> 0] = (yy >> 0);
				cbBlock[(x$1 = 8, (((x$1 >>> 16 << 16) * j >> 0) + (x$1 << 16 >>> 16) * j) >> 0) + i >> 0] = (cb >> 0);
				crBlock[(x$2 = 8, (((x$2 >>> 16 << 16) * j >> 0) + (x$2 << 16 >>> 16) * j) >> 0) + i >> 0] = (cr >> 0);
				i = i + 1 >> 0;
			}
			j = j + 1 >> 0;
		}
	};
0‚ÍrgbaToYCbCr‚¼	var rgbaToYCbCr = function(m, p, yBlock, cbBlock, crBlock) {
		var _struct, _struct$1, _struct$2, b, xmax, ymax, j, sj, x, x$1, x$2, x$3, offset, i, sx, x$4, pix, _tuple, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, yy, cb, cr, x$5, x$6, x$7;
		b = (_struct = m.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		xmax = b.Max.X - 1 >> 0;
		ymax = b.Max.Y - 1 >> 0;
		j = 0;
		while (j < 8) {
			sj = p.Y + j >> 0;
			if (sj > ymax) {
				sj = ymax;
			}
			offset = (x = (sj - b.Min.Y >> 0), x$1 = m.Stride, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0) - (x$2 = b.Min.X, x$3 = 4, (((x$2 >>> 16 << 16) * x$3 >> 0) + (x$2 << 16 >>> 16) * x$3) >> 0) >> 0;
			i = 0;
			while (i < 8) {
				sx = p.X + i >> 0;
				if (sx > xmax) {
					sx = xmax;
				}
				pix = go$subslice(m.Pix, (offset + (x$4 = 4, (((sx >>> 16 << 16) * x$4 >> 0) + (sx << 16 >>> 16) * x$4) >> 0) >> 0));
				_tuple = color.RGBToYCbCr((_slice = pix, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = pix, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = pix, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))), yy = _tuple[0], cb = _tuple[1], cr = _tuple[2];
				yBlock[(x$5 = 8, (((x$5 >>> 16 << 16) * j >> 0) + (x$5 << 16 >>> 16) * j) >> 0) + i >> 0] = (yy >> 0);
				cbBlock[(x$6 = 8, (((x$6 >>> 16 << 16) * j >> 0) + (x$6 << 16 >>> 16) * j) >> 0) + i >> 0] = (cb >> 0);
				crBlock[(x$7 = 8, (((x$7 >>> 16 << 16) * j >> 0) + (x$7 << 16 >>> 16) * j) >> 0) + i >> 0] = (cr >> 0);
				i = i + 1 >> 0;
			}
			j = j + 1 >> 0;
		}
	};
0‚Øscale‚Í	var scale = function(dst, src) {
		var i, dstOff, y, x, x$1, x$2, j, sum, x$3;
		i = 0;
		while (i < 4) {
			dstOff = (((i & 2)) << 4 >> 0) | (((i & 1)) << 2 >> 0);
			y = 0;
			while (y < 4) {
				x = 0;
				while (x < 4) {
					j = (x$1 = 16, (((x$1 >>> 16 << 16) * y >> 0) + (x$1 << 16 >>> 16) * y) >> 0) + (x$2 = 2, (((x$2 >>> 16 << 16) * x >> 0) + (x$2 << 16 >>> 16) * x) >> 0) >> 0;
					sum = ((src[i][j] + src[i][(j + 1 >> 0)] >> 0) + src[i][(j + 8 >> 0)] >> 0) + src[i][(j + 9 >> 0)] >> 0;
					dst[((x$3 = 8, (((x$3 >>> 16 << 16) * y >> 0) + (x$3 << 16 >>> 16) * y) >> 0) + x >> 0) + dstOff >> 0] = ((sum + 2 >> 0)) >> 2 >> 0;
					x = x + 1 >> 0;
				}
				y = y + 1 >> 0;
			}
			i = i + 1 >> 0;
		}
	};
0‚rwriteSOS‚d	encoder.Ptr.prototype.writeSOS = function(m) {
		var e, b, _tuple, cb, cr, _tuple$1, prevDCY, prevDCCb, prevDCCr, _struct, _struct$1, _struct$2, bounds, _tuple$2, rgba, y, x, i, x$1, x$2, xOff, x$3, x$4, yOff, _struct$3, p, _struct$4, _struct$5;
		e = this;
		e.write(sosHeader);
		b = go$makeNativeArray("Int32", 64, function() { return 0; }), _tuple = [go$makeNativeArray("Array", 4, function() { return go$makeNativeArray("Int32", 64, function() { return 0; }); }), go$makeNativeArray("Array", 4, function() { return go$makeNativeArray("Int32", 64, function() { return 0; }); })], cb = _tuple[0], cr = _tuple[1], _tuple$1 = [0, 0, 0], prevDCY = _tuple$1[0], prevDCCb = _tuple$1[1], prevDCCr = _tuple$1[2];
		bounds = (_struct = m.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		_tuple$2 = (m !== null && m.constructor === (go$ptrType(image.RGBA)) ? [m.go$val, true] : [(go$ptrType(image.RGBA)).nil, false]), rgba = _tuple$2[0];
		y = bounds.Min.Y;
		while (y < bounds.Max.Y) {
			x = bounds.Min.X;
			while (x < bounds.Max.X) {
				i = 0;
				while (i < 4) {
					xOff = (x$1 = (i & 1), x$2 = 8, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0);
					yOff = (x$3 = (i & 2), x$4 = 4, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0);
					p = (_struct$3 = image.Pt(x + xOff >> 0, y + yOff >> 0), new image.Point.Ptr(_struct$3.X, _struct$3.Y));
					if (!(rgba === (go$ptrType(image.RGBA)).nil)) {
						rgbaToYCbCr(rgba, (_struct$4 = p, new image.Point.Ptr(_struct$4.X, _struct$4.Y)), b, cb[i], cr[i]);
					} else {
						toYCbCr(m, (_struct$5 = p, new image.Point.Ptr(_struct$5.X, _struct$5.Y)), b, cb[i], cr[i]);
					}
					prevDCY = e.writeBlock(b, 0, prevDCY);
					i = i + 1 >> 0;
				}
				scale(b, cb);
				prevDCCb = e.writeBlock(b, 1, prevDCCb);
				scale(b, cr);
				prevDCCr = e.writeBlock(b, 1, prevDCCr);
				x = x + 16 >> 0;
			}
			y = y + 16 >> 0;
		}
		e.emit(127, 7);
	};
	encoder.prototype.writeSOS = function(m) { return this.go$val.writeSOS(m); };
0‚[Encode‚O	var Encode = go$pkg.Encode = function(w, m, o) {
		var _struct, _struct$1, _struct$2, b, e, ok, _tuple, ww, quality, scale$1, _q, x, _ref, _i, i, _ref$1, _i$1, j, x$1, _q$1, _struct$3;
		b = (_struct = m.Bounds(), new image.Rectangle.Ptr((_struct$1 = _struct.Min, new image.Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new image.Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (b.Dx() >= 65536 || b.Dy() >= 65536) {
			return errors.New("jpeg: image is too large to encode");
		}
		e = new encoder.Ptr();
		if (_tuple = (w !== null && writer.implementedBy.indexOf(w.constructor) !== -1 ? [w, true] : [null, false]), ww = _tuple[0], ok = _tuple[1], ok) {
			e.w = ww;
		} else {
			e.w = bufio.NewWriter(w);
		}
		quality = 75;
		if (!(o === (go$ptrType(Options)).nil)) {
			quality = o.Quality;
			if (quality < 1) {
				quality = 1;
			} else if (quality > 100) {
				quality = 100;
			}
		}
		scale$1 = 0;
		if (quality < 50) {
			scale$1 = (_q = 5000 / quality, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
		} else {
			scale$1 = 200 - (x = 2, (((quality >>> 16 << 16) * x >> 0) + (quality << 16 >>> 16) * x) >> 0) >> 0;
		}
		_ref = e.quant;
		_i = 0;
		while (_i < 2) {
			i = _i;
			_ref$1 = e.quant[i];
			_i$1 = 0;
			while (_i$1 < 64) {
				j = _i$1;
				x$1 = (unscaledQuant[i][j] >> 0);
				x$1 = (_q$1 = ((((((x$1 >>> 16 << 16) * scale$1 >> 0) + (x$1 << 16 >>> 16) * scale$1) >> 0) + 50 >> 0)) / 100, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
				if (x$1 < 1) {
					x$1 = 1;
				} else if (x$1 > 255) {
					x$1 = 255;
				}
				e.quant[i][j] = (x$1 << 24 >>> 24);
				_i$1++;
			}
			_i++;
		}
		e.buf[0] = 255;
		e.buf[1] = 216;
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 2));
		e.writeDQT();
		e.writeSOF0((_struct$3 = b.Size(), new image.Point.Ptr(_struct$3.X, _struct$3.Y)));
		e.writeDHT();
		e.writeSOS(m);
		e.buf[0] = 255;
		e.buf[1] = 217;
		e.write(go$subslice(new (go$sliceType(Go$Uint8))(e.buf), 0, 2));
		e.flush();
		return e.err;
	};
0‚init‚	go$pkg.init = function() {
		theHuffmanLUT = go$makeNativeArray("Slice", 4, function() { return huffmanLUT.nil; });
		var _ref, _i, _struct, s, i, v, _struct$1;
		unzig = go$toNativeArray("Int", [0, 1, 8, 16, 9, 2, 3, 10, 17, 24, 32, 25, 18, 11, 4, 5, 12, 19, 26, 33, 40, 48, 41, 34, 27, 20, 13, 6, 7, 14, 21, 28, 35, 42, 49, 56, 57, 50, 43, 36, 29, 22, 15, 23, 30, 37, 44, 51, 58, 59, 52, 45, 38, 31, 39, 46, 53, 60, 61, 54, 47, 55, 62, 63]);
		bitCount = go$toNativeArray("Uint8", [0, 1, 2, 2, 3, 3, 3, 3, 4, 4, 4, 4, 4, 4, 4, 4, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 5, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 6, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8, 8]);
		unscaledQuant = go$toNativeArray("Array", [go$toNativeArray("Uint8", [16, 11, 12, 14, 12, 10, 16, 14, 13, 14, 18, 17, 16, 19, 24, 40, 26, 24, 22, 22, 24, 49, 35, 37, 29, 40, 58, 51, 61, 60, 57, 51, 56, 55, 64, 72, 92, 78, 64, 68, 87, 69, 55, 56, 80, 109, 81, 87, 95, 98, 103, 104, 103, 62, 77, 113, 121, 112, 100, 120, 92, 101, 103, 99]), go$toNativeArray("Uint8", [17, 18, 18, 24, 21, 24, 47, 26, 26, 47, 99, 66, 56, 66, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99, 99])]);
		theHuffmanSpec = go$toNativeArray("Struct", [new huffmanSpec.Ptr(go$toNativeArray("Uint8", [0, 1, 5, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0, 0]), new (go$sliceType(Go$Uint8))([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])), new huffmanSpec.Ptr(go$toNativeArray("Uint8", [0, 2, 1, 3, 3, 2, 4, 3, 5, 5, 4, 4, 0, 0, 1, 125]), new (go$sliceType(Go$Uint8))([1, 2, 3, 0, 4, 17, 5, 18, 33, 49, 65, 6, 19, 81, 97, 7, 34, 113, 20, 50, 129, 145, 161, 8, 35, 66, 177, 193, 21, 82, 209, 240, 36, 51, 98, 114, 130, 9, 10, 22, 23, 24, 25, 26, 37, 38, 39, 40, 41, 42, 52, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 225, 226, 227, 228, 229, 230, 231, 232, 233, 234, 241, 242, 243, 244, 245, 246, 247, 248, 249, 250])), new huffmanSpec.Ptr(go$toNativeArray("Uint8", [0, 3, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0]), new (go$sliceType(Go$Uint8))([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11])), new huffmanSpec.Ptr(go$toNativeArray("Uint8", [0, 2, 1, 2, 4, 4, 3, 4, 7, 5, 4, 4, 0, 1, 2, 119]), new (go$sliceType(Go$Uint8))([0, 1, 2, 3, 17, 4, 5, 33, 49, 6, 18, 65, 81, 7, 97, 113, 19, 34, 50, 129, 8, 20, 66, 145, 161, 177, 193, 9, 35, 51, 82, 240, 21, 98, 114, 209, 10, 22, 36, 52, 225, 37, 241, 23, 24, 25, 26, 38, 39, 40, 41, 42, 53, 54, 55, 56, 57, 58, 67, 68, 69, 70, 71, 72, 73, 74, 83, 84, 85, 86, 87, 88, 89, 90, 99, 100, 101, 102, 103, 104, 105, 106, 115, 116, 117, 118, 119, 120, 121, 122, 130, 131, 132, 133, 134, 135, 136, 137, 138, 146, 147, 148, 149, 150, 151, 152, 153, 154, 162, 163, 164, 165, 166, 167, 168, 169, 170, 178, 179, 180, 181, 182, 183, 184, 185, 186, 194, 195, 196, 197, 198, 199, 200, 201, 202, 210, 211, 212, 213, 214, 215, 216, 217, 218, 226, 227, 228, 229, 230, 231, 232, 233, 234, 242, 243, 244, 245, 246, 247, 248, 249, 250]))]);
		sosHeader = new (go$sliceType(Go$Uint8))([255, 218, 0, 12, 3, 1, 0, 2, 17, 3, 17, 0, 63, 0]);
		image.RegisterFormat("jpeg", "\xFF\xD8", Decode, DecodeConfig);
		_ref = theHuffmanSpec;
		_i = 0;
		while (_i < 4) {
			s = (_struct = _ref[_i], new huffmanSpec.Ptr(go$mapArray(_struct.count, function(entry) { return entry; }), _struct.value));
			i = _i;
			(new (go$ptrType(huffmanLUT))(function() { return theHuffmanLUT[i]; }, function(v) { theHuffmanLUT[i] = v; })).init((_struct$1 = s, new huffmanSpec.Ptr(go$mapArray(_struct$1.count, function(entry) { return entry; }), _struct$1.value)));
			_i++;
		}
	};
