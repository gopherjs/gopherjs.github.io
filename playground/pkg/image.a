0ÉnimageÇ>√package image
import bufio "bufio"
import errors "errors"
import io "io"
import strconv "strconv"
import color "image/color"
type @"".Alpha struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".Alpha) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Alpha) @"".Bounds() (? @"".Rectangle)
func (? *@"".Alpha) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Alpha) @"".Opaque() (? bool)
func (? *@"".Alpha) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".Alpha) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".Alpha) @"".SetAlpha(@"".x int, @"".y int, @"".c @"image/color".Alpha) ()
func (? *@"".Alpha) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".Alpha16 struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".Alpha16) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Alpha16) @"".Bounds() (? @"".Rectangle)
func (? *@"".Alpha16) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Alpha16) @"".Opaque() (? bool)
func (? *@"".Alpha16) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".Alpha16) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".Alpha16) @"".SetAlpha16(@"".x int, @"".y int, @"".c @"image/color".Alpha16) ()
func (? *@"".Alpha16) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
var @"".Black *@"".Uniform
type @"".Config struct { @"".ColorModel @"image/color".Model; @"".Width int; @"".Height int }
func @"".Decode(@"".r @"io".Reader) (? @"".Image, ? string, ? error)
func @"".DecodeConfig(@"".r @"io".Reader) (? @"".Config, ? string, ? error)
var @"".ErrFormat error
type @"".Gray struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".Gray) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Gray) @"".Bounds() (? @"".Rectangle)
func (? *@"".Gray) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Gray) @"".Opaque() (? bool)
func (? *@"".Gray) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".Gray) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".Gray) @"".SetGray(@"".x int, @"".y int, @"".c @"image/color".Gray) ()
func (? *@"".Gray) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".Gray16 struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".Gray16) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Gray16) @"".Bounds() (? @"".Rectangle)
func (? *@"".Gray16) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Gray16) @"".Opaque() (? bool)
func (? *@"".Gray16) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".Gray16) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".Gray16) @"".SetGray16(@"".x int, @"".y int, @"".c @"image/color".Gray16) ()
func (? *@"".Gray16) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".Image interface { @"".At(@"".x int, @"".y int) (? @"image/color".Color); @"".Bounds() (? @"".Rectangle); @"".ColorModel() (? @"image/color".Model) }
type @"".NRGBA struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".NRGBA) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".NRGBA) @"".Bounds() (? @"".Rectangle)
func (? *@"".NRGBA) @"".ColorModel() (? @"image/color".Model)
func (? *@"".NRGBA) @"".Opaque() (? bool)
func (? *@"".NRGBA) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".NRGBA) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".NRGBA) @"".SetNRGBA(@"".x int, @"".y int, @"".c @"image/color".NRGBA) ()
func (? *@"".NRGBA) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".NRGBA64 struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".NRGBA64) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".NRGBA64) @"".Bounds() (? @"".Rectangle)
func (? *@"".NRGBA64) @"".ColorModel() (? @"image/color".Model)
func (? *@"".NRGBA64) @"".Opaque() (? bool)
func (? *@"".NRGBA64) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".NRGBA64) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".NRGBA64) @"".SetNRGBA64(@"".x int, @"".y int, @"".c @"image/color".NRGBA64) ()
func (? *@"".NRGBA64) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
func @"".NewAlpha(@"".r @"".Rectangle) (? *@"".Alpha)
func @"".NewAlpha16(@"".r @"".Rectangle) (? *@"".Alpha16)
func @"".NewGray(@"".r @"".Rectangle) (? *@"".Gray)
func @"".NewGray16(@"".r @"".Rectangle) (? *@"".Gray16)
func @"".NewNRGBA(@"".r @"".Rectangle) (? *@"".NRGBA)
func @"".NewNRGBA64(@"".r @"".Rectangle) (? *@"".NRGBA64)
func @"".NewPaletted(@"".r @"".Rectangle, @"".p @"image/color".Palette) (? *@"".Paletted)
func @"".NewRGBA(@"".r @"".Rectangle) (? *@"".RGBA)
func @"".NewRGBA64(@"".r @"".Rectangle) (? *@"".RGBA64)
func @"".NewUniform(@"".c @"image/color".Color) (? *@"".Uniform)
func @"".NewYCbCr(@"".r @"".Rectangle, @"".subsampleRatio @"".YCbCrSubsampleRatio) (? *@"".YCbCr)
var @"".Opaque *@"".Uniform
type @"".Paletted struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle; @"".Palette @"image/color".Palette }
func (? *@"".Paletted) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Paletted) @"".Bounds() (? @"".Rectangle)
func (? *@"".Paletted) @"".ColorIndexAt(@"".x int, @"".y int) (? uint8)
func (? *@"".Paletted) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Paletted) @"".Opaque() (? bool)
func (? *@"".Paletted) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".Paletted) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".Paletted) @"".SetColorIndex(@"".x int, @"".y int, @"".index uint8) ()
func (? *@"".Paletted) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".PalettedImage interface { @"".At(@"".x int, @"".y int) (? @"image/color".Color); @"".Bounds() (? @"".Rectangle); @"".ColorIndexAt(@"".x int, @"".y int) (? uint8); @"".ColorModel() (? @"image/color".Model) }
type @"".Point struct { @"".X int; @"".Y int }
func (? @"".Point) @"".Add(@"".q @"".Point) (? @"".Point)
func (? @"".Point) @"".Div(@"".k int) (? @"".Point)
func (? @"".Point) @"".Eq(@"".q @"".Point) (? bool)
func (? @"".Point) @"".In(@"".r @"".Rectangle) (? bool)
func (? @"".Point) @"".Mod(@"".r @"".Rectangle) (? @"".Point)
func (? @"".Point) @"".Mul(@"".k int) (? @"".Point)
func (? @"".Point) @"".String() (? string)
func (? @"".Point) @"".Sub(@"".q @"".Point) (? @"".Point)
func (? *@"".Point) @"".Add(@"".q @"".Point) (? @"".Point)
func (? *@"".Point) @"".Div(@"".k int) (? @"".Point)
func (? *@"".Point) @"".Eq(@"".q @"".Point) (? bool)
func (? *@"".Point) @"".In(@"".r @"".Rectangle) (? bool)
func (? *@"".Point) @"".Mod(@"".r @"".Rectangle) (? @"".Point)
func (? *@"".Point) @"".Mul(@"".k int) (? @"".Point)
func (? *@"".Point) @"".String() (? string)
func (? *@"".Point) @"".Sub(@"".q @"".Point) (? @"".Point)
func @"".Pt(@"".X int, @"".Y int) (? @"".Point)
type @"".RGBA struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".RGBA) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".RGBA) @"".Bounds() (? @"".Rectangle)
func (? *@"".RGBA) @"".ColorModel() (? @"image/color".Model)
func (? *@"".RGBA) @"".Opaque() (? bool)
func (? *@"".RGBA) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".RGBA) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".RGBA) @"".SetRGBA(@"".x int, @"".y int, @"".c @"image/color".RGBA) ()
func (? *@"".RGBA) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
type @"".RGBA64 struct { @"".Pix []uint8; @"".Stride int; @"".Rect @"".Rectangle }
func (? *@"".RGBA64) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".RGBA64) @"".Bounds() (? @"".Rectangle)
func (? *@"".RGBA64) @"".ColorModel() (? @"image/color".Model)
func (? *@"".RGBA64) @"".Opaque() (? bool)
func (? *@"".RGBA64) @"".PixOffset(@"".x int, @"".y int) (? int)
func (? *@"".RGBA64) @"".Set(@"".x int, @"".y int, @"".c @"image/color".Color) ()
func (? *@"".RGBA64) @"".SetRGBA64(@"".x int, @"".y int, @"".c @"image/color".RGBA64) ()
func (? *@"".RGBA64) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
func @"".Rect(@"".x0 int, @"".y0 int, @"".x1 int, @"".y1 int) (? @"".Rectangle)
type @"".Rectangle struct { @"".Min @"".Point; @"".Max @"".Point }
func (? @"".Rectangle) @"".Add(@"".p @"".Point) (? @"".Rectangle)
func (? @"".Rectangle) @"".Canon() (? @"".Rectangle)
func (? @"".Rectangle) @"".Dx() (? int)
func (? @"".Rectangle) @"".Dy() (? int)
func (? @"".Rectangle) @"".Empty() (? bool)
func (? @"".Rectangle) @"".Eq(@"".s @"".Rectangle) (? bool)
func (? @"".Rectangle) @"".In(@"".s @"".Rectangle) (? bool)
func (? @"".Rectangle) @"".Inset(@"".n int) (? @"".Rectangle)
func (? @"".Rectangle) @"".Intersect(@"".s @"".Rectangle) (? @"".Rectangle)
func (? @"".Rectangle) @"".Overlaps(@"".s @"".Rectangle) (? bool)
func (? @"".Rectangle) @"".Size() (? @"".Point)
func (? @"".Rectangle) @"".String() (? string)
func (? @"".Rectangle) @"".Sub(@"".p @"".Point) (? @"".Rectangle)
func (? @"".Rectangle) @"".Union(@"".s @"".Rectangle) (? @"".Rectangle)
func (? *@"".Rectangle) @"".Add(@"".p @"".Point) (? @"".Rectangle)
func (? *@"".Rectangle) @"".Canon() (? @"".Rectangle)
func (? *@"".Rectangle) @"".Dx() (? int)
func (? *@"".Rectangle) @"".Dy() (? int)
func (? *@"".Rectangle) @"".Empty() (? bool)
func (? *@"".Rectangle) @"".Eq(@"".s @"".Rectangle) (? bool)
func (? *@"".Rectangle) @"".In(@"".s @"".Rectangle) (? bool)
func (? *@"".Rectangle) @"".Inset(@"".n int) (? @"".Rectangle)
func (? *@"".Rectangle) @"".Intersect(@"".s @"".Rectangle) (? @"".Rectangle)
func (? *@"".Rectangle) @"".Overlaps(@"".s @"".Rectangle) (? bool)
func (? *@"".Rectangle) @"".Size() (? @"".Point)
func (? *@"".Rectangle) @"".String() (? string)
func (? *@"".Rectangle) @"".Sub(@"".p @"".Point) (? @"".Rectangle)
func (? *@"".Rectangle) @"".Union(@"".s @"".Rectangle) (? @"".Rectangle)
func @"".RegisterFormat(@"".name string, @"".magic string, @"".decode func (? @"io".Reader) (? @"".Image, ? error), @"".decodeConfig func (? @"io".Reader) (? @"".Config, ? error)) ()
var @"".Transparent *@"".Uniform
type @"".Uniform struct { @"".C @"image/color".Color }
func (? *@"".Uniform) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".Uniform) @"".Bounds() (? @"".Rectangle)
func (? *@"".Uniform) @"".ColorModel() (? @"image/color".Model)
func (? *@"".Uniform) @"".Convert(? @"image/color".Color) (? @"image/color".Color)
func (? *@"".Uniform) @"".Opaque() (? bool)
func (? *@"".Uniform) @"".RGBA() (@"".r uint32, @"".g uint32, @"".b uint32, @"".a uint32)
var @"".White *@"".Uniform
type @"".YCbCr struct { @"".Y []uint8; @"".Cb []uint8; @"".Cr []uint8; @"".YStride int; @"".CStride int; @"".SubsampleRatio @"".YCbCrSubsampleRatio; @"".Rect @"".Rectangle }
func (? *@"".YCbCr) @"".At(@"".x int, @"".y int) (? @"image/color".Color)
func (? *@"".YCbCr) @"".Bounds() (? @"".Rectangle)
func (? *@"".YCbCr) @"".COffset(@"".x int, @"".y int) (? int)
func (? *@"".YCbCr) @"".ColorModel() (? @"image/color".Model)
func (? *@"".YCbCr) @"".Opaque() (? bool)
func (? *@"".YCbCr) @"".SubImage(@"".r @"".Rectangle) (? @"".Image)
func (? *@"".YCbCr) @"".YOffset(@"".x int, @"".y int) (? int)
type @"".YCbCrSubsampleRatio int
func (? @"".YCbCrSubsampleRatio) @"".String() (? string)
func (? *@"".YCbCrSubsampleRatio) @"".String() (? string)
const @"".YCbCrSubsampleRatio420 @"".YCbCrSubsampleRatio = 0x2
const @"".YCbCrSubsampleRatio422 @"".YCbCrSubsampleRatio = 0x1
const @"".YCbCrSubsampleRatio440 @"".YCbCrSubsampleRatio = 0x3
const @"".YCbCrSubsampleRatio444 @"".YCbCrSubsampleRatio = 0x0
var @"".ZP @"".Point
var @"".ZR @"".Rectangle
type @"".format struct { @"".name string; @"".magic string; @"".decode func (? @"io".Reader) (? @"".Image, ? error); @"".decodeConfig func (? @"io".Reader) (? @"".Config, ? error) }
type @"".reader interface { @"".Peek(? int) (? []byte, ? error); @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"image/color".Color interface { @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32) }
type @"image/color".Model interface { @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color) }
type @"image/color".Alpha struct { @"image/color".A uint8 }
func (? @"image/color".Alpha) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".Alpha) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".Alpha16 struct { @"image/color".A uint16 }
func (? @"image/color".Alpha16) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".Alpha16) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"image/color".Gray struct { @"image/color".Y uint8 }
func (? @"image/color".Gray) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".Gray) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".Gray16 struct { @"image/color".Y uint16 }
func (? @"image/color".Gray16) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".Gray16) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".NRGBA struct { @"image/color".R uint8; @"image/color".G uint8; @"image/color".B uint8; @"image/color".A uint8 }
func (? @"image/color".NRGBA) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".NRGBA) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".NRGBA64 struct { @"image/color".R uint16; @"image/color".G uint16; @"image/color".B uint16; @"image/color".A uint16 }
func (? @"image/color".NRGBA64) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".NRGBA64) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".Palette []@"image/color".Color
func (? @"image/color".Palette) @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color)
func (? @"image/color".Palette) @"image/color".Index(@"image/color".c @"image/color".Color) (? int)
func (? *@"image/color".Palette) @"image/color".Convert(@"image/color".c @"image/color".Color) (? @"image/color".Color)
func (? *@"image/color".Palette) @"image/color".Index(@"image/color".c @"image/color".Color) (? int)
type @"image/color".RGBA struct { @"image/color".R uint8; @"image/color".G uint8; @"image/color".B uint8; @"image/color".A uint8 }
func (? @"image/color".RGBA) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".RGBA) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
type @"image/color".RGBA64 struct { @"image/color".R uint16; @"image/color".G uint16; @"image/color".B uint16; @"image/color".A uint16 }
func (? @"image/color".RGBA64) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
func (? *@"image/color".RGBA64) @"image/color".RGBA() (@"image/color".r uint32, @"image/color".g uint32, @"image/color".b uint32, @"image/color".a uint32)
$$
0pruntimeerrorssync/atomicsynciounicodeunicode/utf8bytesbufioimage/colormathstrconvimage0V0bufiobufio0errorserrors0ioio0strconvstrconv0image/colorcolor0ÉÀœ0ÇformatÇ≠	format = go$pkg.format = go$newType(0, "Struct", "image.format", "format", "image", function(name_, magic_, decode_, decodeConfig_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : "";
		this.magic = magic_ !== undefined ? magic_ : "";
		this.decode = decode_ !== undefined ? decode_ : go$throwNilPointerError;
		this.decodeConfig = decodeConfig_ !== undefined ? decodeConfig_ : go$throwNilPointerError;
	});
Ç&		format.init([["name", "name", "image", Go$String, ""], ["magic", "magic", "image", Go$String, ""], ["decode", "decode", "image", (go$funcType([io.Reader], [Image, go$error], false)), ""], ["decodeConfig", "decodeConfig", "image", (go$funcType([io.Reader], [Config, go$error], false)), ""]]);
0format0&image:Configimage:Image	io:Reader0Ç1reader_	reader = go$pkg.reader = go$newType(0, "Interface", "image.reader", "reader", "image", null);
Åπ		reader.init([["Peek", "", (go$funcType([Go$Int], [(go$sliceType(Go$Uint8)), go$error], false))], ["Read", "", (go$funcType([(go$sliceType(Go$Uint8))], [Go$Int, go$error], false))]]);
0reader0 0Ç/PointÅÀ	Point = go$pkg.Point = go$newType(0, "Struct", "image.Point", "Point", "image", function(X_, Y_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : 0;
		this.Y = Y_ !== undefined ? Y_ : 0;
	});
Ç:		Point.methods = [["Add", "", [Point], [Point], false, -1], ["Div", "", [Go$Int], [Point], false, -1], ["Eq", "", [Point], [Go$Bool], false, -1], ["In", "", [Rectangle], [Go$Bool], false, -1], ["Mod", "", [Rectangle], [Point], false, -1], ["Mul", "", [Go$Int], [Point], false, -1], ["String", "", [], [Go$String], false, -1], ["Sub", "", [Point], [Point], false, -1]];
		(go$ptrType(Point)).methods = [["Add", "", [Point], [Point], false, -1], ["Div", "", [Go$Int], [Point], false, -1], ["Eq", "", [Point], [Go$Bool], false, -1], ["In", "", [Rectangle], [Go$Bool], false, -1], ["Mod", "", [Rectangle], [Point], false, -1], ["Mul", "", [Go$Int], [Point], false, -1], ["String", "", [], [Go$String], false, -1], ["Sub", "", [Point], [Point], false, -1]];
		Point.init([["X", "X", "", Go$Int, ""], ["Y", "Y", "", Go$Int, ""]]);
0Point0image:Rectangle0Çæ	RectangleÇ	Rectangle = go$pkg.Rectangle = go$newType(0, "Struct", "image.Rectangle", "Rectangle", "image", function(Min_, Max_) {
		this.go$val = this;
		this.Min = Min_ !== undefined ? Min_ : new Point.Ptr();
		this.Max = Max_ !== undefined ? Max_ : new Point.Ptr();
	});
Çà		Rectangle.methods = [["Add", "", [Point], [Rectangle], false, -1], ["Canon", "", [], [Rectangle], false, -1], ["Dx", "", [], [Go$Int], false, -1], ["Dy", "", [], [Go$Int], false, -1], ["Empty", "", [], [Go$Bool], false, -1], ["Eq", "", [Rectangle], [Go$Bool], false, -1], ["In", "", [Rectangle], [Go$Bool], false, -1], ["Inset", "", [Go$Int], [Rectangle], false, -1], ["Intersect", "", [Rectangle], [Rectangle], false, -1], ["Overlaps", "", [Rectangle], [Go$Bool], false, -1], ["Size", "", [], [Point], false, -1], ["String", "", [], [Go$String], false, -1], ["Sub", "", [Point], [Rectangle], false, -1], ["Union", "", [Rectangle], [Rectangle], false, -1]];
		(go$ptrType(Rectangle)).methods = [["Add", "", [Point], [Rectangle], false, -1], ["Canon", "", [], [Rectangle], false, -1], ["Dx", "", [], [Go$Int], false, -1], ["Dy", "", [], [Go$Int], false, -1], ["Empty", "", [], [Go$Bool], false, -1], ["Eq", "", [Rectangle], [Go$Bool], false, -1], ["In", "", [Rectangle], [Go$Bool], false, -1], ["Inset", "", [Go$Int], [Rectangle], false, -1], ["Intersect", "", [Rectangle], [Rectangle], false, -1], ["Overlaps", "", [Rectangle], [Go$Bool], false, -1], ["Size", "", [], [Point], false, -1], ["String", "", [], [Go$String], false, -1], ["Sub", "", [Point], [Rectangle], false, -1], ["Union", "", [Rectangle], [Rectangle], false, -1]];
		Rectangle.init([["Min", "Min", "", Point, ""], ["Max", "Max", "", Point, ""]]);
0	Rectangle0image:Point0Ç ConfigÇD	Config = go$pkg.Config = go$newType(0, "Struct", "image.Config", "Config", "image", function(ColorModel_, Width_, Height_) {
		this.go$val = this;
		this.ColorModel = ColorModel_ !== undefined ? ColorModel_ : null;
		this.Width = Width_ !== undefined ? Width_ : 0;
		this.Height = Height_ !== undefined ? Height_ : 0;
	});
Åé		Config.init([["ColorModel", "ColorModel", "", color.Model, ""], ["Width", "Width", "", Go$Int, ""], ["Height", "Height", "", Go$Int, ""]]);
0Config0image/color:Model0ÇpImage[	Image = go$pkg.Image = go$newType(0, "Interface", "image.Image", "Image", "image", null);
Å«		Image.init([["At", "", (go$funcType([Go$Int, Go$Int], [color.Color], false))], ["Bounds", "", (go$funcType([], [Rectangle], false))], ["ColorModel", "", (go$funcType([], [color.Model], false))]]);
0Image07image/color:Colorimage/color:Modelimage:Rectangle0ÇÛPalettedImage{	PalettedImage = go$pkg.PalettedImage = go$newType(0, "Interface", "image.PalettedImage", "PalettedImage", "image", null);
Ç		PalettedImage.init([["At", "", (go$funcType([Go$Int, Go$Int], [color.Color], false))], ["Bounds", "", (go$funcType([], [Rectangle], false))], ["ColorIndexAt", "", (go$funcType([Go$Int, Go$Int], [Go$Uint8], false))], ["ColorModel", "", (go$funcType([], [color.Model], false))]]);
0PalettedImage07image/color:Colorimage/color:Modelimage:Rectangle0ÇRGBAÇF	RGBA = go$pkg.RGBA = go$newType(0, "Struct", "image.RGBA", "RGBA", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
ÇS		(go$ptrType(RGBA)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetRGBA", "", [Go$Int, Go$Int, color.RGBA], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		RGBA.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0RGBA0Vimage/color:Colorimage/color:Modelimage/color:RGBAimage:Imageimage:Rectangle0ÇRGBA64ÇN	RGBA64 = go$pkg.RGBA64 = go$newType(0, "Struct", "image.RGBA64", "RGBA64", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
Ç[		(go$ptrType(RGBA64)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetRGBA64", "", [Go$Int, Go$Int, color.RGBA64], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		RGBA64.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0RGBA640Ximage/color:Colorimage/color:Modelimage/color:RGBA64image:Imageimage:Rectangle0ÇNRGBAÇJ	NRGBA = go$pkg.NRGBA = go$newType(0, "Struct", "image.NRGBA", "NRGBA", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
ÇW		(go$ptrType(NRGBA)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetNRGBA", "", [Go$Int, Go$Int, color.NRGBA], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		NRGBA.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0NRGBA0Wimage/color:Colorimage/color:Modelimage/color:NRGBAimage:Imageimage:Rectangle0Ç(NRGBA64ÇR	NRGBA64 = go$pkg.NRGBA64 = go$newType(0, "Struct", "image.NRGBA64", "NRGBA64", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
Ç_		(go$ptrType(NRGBA64)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetNRGBA64", "", [Go$Int, Go$Int, color.NRGBA64], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		NRGBA64.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0	NRGBA640Yimage/color:Colorimage/color:Modelimage/color:NRGBA64image:Imageimage:Rectangle0ÇAlphaÇJ	Alpha = go$pkg.Alpha = go$newType(0, "Struct", "image.Alpha", "Alpha", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
ÇW		(go$ptrType(Alpha)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetAlpha", "", [Go$Int, Go$Int, color.Alpha], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		Alpha.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0Alpha0Wimage/color:Alphaimage/color:Colorimage/color:Modelimage:Imageimage:Rectangle0Ç(Alpha16ÇR	Alpha16 = go$pkg.Alpha16 = go$newType(0, "Struct", "image.Alpha16", "Alpha16", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
Ç_		(go$ptrType(Alpha16)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetAlpha16", "", [Go$Int, Go$Int, color.Alpha16], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		Alpha16.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0	Alpha160Yimage/color:Alpha16image/color:Colorimage/color:Modelimage:Imageimage:Rectangle0ÇGrayÇF	Gray = go$pkg.Gray = go$newType(0, "Struct", "image.Gray", "Gray", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
ÇS		(go$ptrType(Gray)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetGray", "", [Go$Int, Go$Int, color.Gray], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		Gray.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0Gray0Vimage/color:Colorimage/color:Grayimage/color:Modelimage:Imageimage:Rectangle0ÇGray16ÇN	Gray16 = go$pkg.Gray16 = go$newType(0, "Struct", "image.Gray16", "Gray16", "image", function(Pix_, Stride_, Rect_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
Ç[		(go$ptrType(Gray16)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetGray16", "", [Go$Int, Go$Int, color.Gray16], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		Gray16.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0Gray160Ximage/color:Colorimage/color:Gray16image/color:Modelimage:Imageimage:Rectangle0ÇÓPalettedÇ®	Paletted = go$pkg.Paletted = go$newType(0, "Struct", "image.Paletted", "Paletted", "image", function(Pix_, Stride_, Rect_, Palette_) {
		this.go$val = this;
		this.Pix = Pix_ !== undefined ? Pix_ : (go$sliceType(Go$Uint8)).nil;
		this.Stride = Stride_ !== undefined ? Stride_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
		this.Palette = Palette_ !== undefined ? Palette_ : color.Palette.nil;
	});
ÇÕ		(go$ptrType(Paletted)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorIndexAt", "", [Go$Int, Go$Int], [Go$Uint8], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["PixOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["Set", "", [Go$Int, Go$Int, color.Color], [], false, -1], ["SetColorIndex", "", [Go$Int, Go$Int, Go$Uint8], [], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1]];
		Paletted.init([["Pix", "Pix", "", (go$sliceType(Go$Uint8)), ""], ["Stride", "Stride", "", Go$Int, ""], ["Rect", "Rect", "", Rectangle, ""], ["Palette", "Palette", "", color.Palette, ""]]);
0
Paletted0Yimage/color:Colorimage/color:Modelimage/color:Paletteimage:Imageimage:Rectangle0ÇúUniformÅ¨	Uniform = go$pkg.Uniform = go$newType(0, "Struct", "image.Uniform", "Uniform", "image", function(C_) {
		this.go$val = this;
		this.C = C_ !== undefined ? C_ : null;
	});
Çú		(go$ptrType(Uniform)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Convert", "", [color.Color], [color.Color], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["RGBA", "", [], [Go$Uint32, Go$Uint32, Go$Uint32, Go$Uint32], false, -1]];
		Uniform.init([["C", "C", "", color.Color, ""]]);
0	Uniform07image/color:Colorimage/color:Modelimage:Rectangle0ÇkYCbCrSubsampleRatioÅç	YCbCrSubsampleRatio = go$pkg.YCbCrSubsampleRatio = go$newType(4, "Int", "image.YCbCrSubsampleRatio", "YCbCrSubsampleRatio", "image", null);
Å™		YCbCrSubsampleRatio.methods = [["String", "", [], [Go$String], false, -1]];
		(go$ptrType(YCbCrSubsampleRatio)).methods = [["String", "", [], [Go$String], false, -1]];
0YCbCrSubsampleRatio0 0ÇÃYCbCrÇx	YCbCr = go$pkg.YCbCr = go$newType(0, "Struct", "image.YCbCr", "YCbCr", "image", function(Y_, Cb_, Cr_, YStride_, CStride_, SubsampleRatio_, Rect_) {
		this.go$val = this;
		this.Y = Y_ !== undefined ? Y_ : (go$sliceType(Go$Uint8)).nil;
		this.Cb = Cb_ !== undefined ? Cb_ : (go$sliceType(Go$Uint8)).nil;
		this.Cr = Cr_ !== undefined ? Cr_ : (go$sliceType(Go$Uint8)).nil;
		this.YStride = YStride_ !== undefined ? YStride_ : 0;
		this.CStride = CStride_ !== undefined ? CStride_ : 0;
		this.SubsampleRatio = SubsampleRatio_ !== undefined ? SubsampleRatio_ : 0;
		this.Rect = Rect_ !== undefined ? Rect_ : new Rectangle.Ptr();
	});
Ç€		(go$ptrType(YCbCr)).methods = [["At", "", [Go$Int, Go$Int], [color.Color], false, -1], ["Bounds", "", [], [Rectangle], false, -1], ["COffset", "", [Go$Int, Go$Int], [Go$Int], false, -1], ["ColorModel", "", [], [color.Model], false, -1], ["Opaque", "", [], [Go$Bool], false, -1], ["SubImage", "", [Rectangle], [Image], false, -1], ["YOffset", "", [Go$Int, Go$Int], [Go$Int], false, -1]];
		YCbCr.init([["Y", "Y", "", (go$sliceType(Go$Uint8)), ""], ["Cb", "Cb", "", (go$sliceType(Go$Uint8)), ""], ["Cr", "Cr", "", (go$sliceType(Go$Uint8)), ""], ["YStride", "YStride", "", Go$Int, ""], ["CStride", "CStride", "", Go$Int, ""], ["SubsampleRatio", "SubsampleRatio", "", YCbCrSubsampleRatio, ""], ["Rect", "Rect", "", Rectangle, ""]]);
0YCbCr0_image/color:Colorimage/color:Modelimage:Imageimage:Rectangleimage:YCbCrSubsampleRatio0ÅıRegisterFormatÅØ	RegisterFormat = go$pkg.RegisterFormat = function(name, magic, decode, decodeConfig) {
		formats = go$append(formats, new format.Ptr(name, magic, decode, decodeConfig));
	};
 0RegisterFormat0image:formatimage:formats0Ç4asReaderÅ¯	asReader = function(r) {
		var ok, _tuple, rr;
		if (_tuple = (r !== null && reader.implementedBy.indexOf(r.constructor) !== -1 ? [r, true] : [null, false]), rr = _tuple[0], ok = _tuple[1], ok) {
			return rr;
		}
		return bufio.NewReader(r);
	};
 0
asReader0bufio:NewReaderimage:reader0Ç¸matchÇ‰	match = function(magic, b) {
		var _ref, _i, _slice, _index, c, i;
		if (!((magic.length === b.length))) {
			return false;
		}
		_ref = b;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (!((magic.charCodeAt(i) === c)) && !((magic.charCodeAt(i) === 63))) {
				return false;
			}
			_i++;
		}
		return true;
	};
 0match0 0Ç<sniffÇ˙	sniff = function(r) {
		var _ref, _i, _slice, _index, _struct, f, _tuple, b, err, _struct$1;
		_ref = formats;
		_i = 0;
		while (_i < _ref.length) {
			f = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new format.Ptr(_struct.name, _struct.magic, _struct.decode, _struct.decodeConfig));
			_tuple = r.Peek(f.magic.length), b = _tuple[0], err = _tuple[1];
			if (go$interfaceIsEqual(err, null) && match(f.magic, b)) {
				return (_struct$1 = f, new format.Ptr(_struct$1.name, _struct$1.magic, _struct$1.decode, _struct$1.decodeConfig));
			}
			_i++;
		}
		return new format.Ptr("", "", go$throwNilPointerError, go$throwNilPointerError);
	};
 0sniff0*image:formatimage:formatsimage:match0Ç⁄DecodeÇÑ	Decode = go$pkg.Decode = function(r) {
		var rr, _struct, f, _tuple, m, err;
		rr = asReader(r);
		f = (_struct = sniff(rr), new format.Ptr(_struct.name, _struct.magic, _struct.decode, _struct.decodeConfig));
		if (f.decode === go$throwNilPointerError) {
			return [null, "", go$pkg.ErrFormat];
		}
		_tuple = f.decode(rr), m = _tuple[0], err = _tuple[1];
		return [m, f.name, err];
	};
 0Decode0<image:ErrFormatimage:asReaderimage:formatimage:sniff0ÇÊDecodeConfigÇv	DecodeConfig = go$pkg.DecodeConfig = function(r) {
		var rr, _struct, f, _tuple, _struct$1, c, err, _struct$2;
		rr = asReader(r);
		f = (_struct = sniff(rr), new format.Ptr(_struct.name, _struct.magic, _struct.decode, _struct.decodeConfig));
		if (f.decodeConfig === go$throwNilPointerError) {
			return [new Config.Ptr(null, 0, 0), "", go$pkg.ErrFormat];
		}
		_tuple = f.decodeConfig(rr), c = (_struct$1 = _tuple[0], new Config.Ptr(_struct$1.ColorModel, _struct$1.Width, _struct$1.Height)), err = _tuple[1];
		return [(_struct$2 = c, new Config.Ptr(_struct$2.ColorModel, _struct$2.Width, _struct$2.Height)), f.name, err];
	};
 0DecodeConfig0Jimage:Configimage:ErrFormatimage:asReaderimage:formatimage:sniff0Ç5 Ç	Point.Ptr.prototype.String = function() {
		var _struct, p;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return "(" + strconv.Itoa(p.X) + "," + strconv.Itoa(p.Y) + ")";
	};
	Point.prototype.String = function() { return this.go$val.String(); };
 0Point0image:Pointstrconv:Itoa0Ç Å˜	Point.Ptr.prototype.Add = function(q) {
		var _struct, p;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return new Point.Ptr(p.X + q.X >> 0, p.Y + q.Y >> 0);
	};
	Point.prototype.Add = function(q) { return this.go$val.Add(q); };
 0Point0image:Point0Ç Å˜	Point.Ptr.prototype.Sub = function(q) {
		var _struct, p;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return new Point.Ptr(p.X - q.X >> 0, p.Y - q.Y >> 0);
	};
	Point.prototype.Sub = function(q) { return this.go$val.Sub(q); };
 0Point0image:Point0Çë Çq	Point.Ptr.prototype.Mul = function(k) {
		var _struct, p, x, x$1;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return new Point.Ptr((x = p.X, (((x >>> 16 << 16) * k >> 0) + (x << 16 >>> 16) * k) >> 0), (x$1 = p.Y, (((x$1 >>> 16 << 16) * k >> 0) + (x$1 << 16 >>> 16) * k) >> 0));
	};
	Point.prototype.Mul = function(k) { return this.go$val.Mul(k); };
 0Point0image:Point0Ç˜ Ç◊	Point.Ptr.prototype.Div = function(k) {
		var _struct, p, _q, _q$1;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return new Point.Ptr((_q = p.X / k, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")), (_q$1 = p.Y / k, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")));
	};
	Point.prototype.Div = function(k) { return this.go$val.Div(k); };
 0Point0image:Point0Ç) Ç		Point.Ptr.prototype.In = function(r) {
		var _struct, p;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return r.Min.X <= p.X && p.X < r.Max.X && r.Min.Y <= p.Y && p.Y < r.Max.Y;
	};
	Point.prototype.In = function(r) { return this.go$val.In(r); };
 0Point0image:Point0Ç{ Ç[	Point.Ptr.prototype.Mod = function(r) {
		var _struct, p, _tuple, w, h, _struct$1, _struct$2, _r, _r$1, _struct$3, _struct$4;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		p = (_struct$2 = p.Sub((_struct$1 = r.Min, new Point.Ptr(_struct$1.X, _struct$1.Y))), new Point.Ptr(_struct$2.X, _struct$2.Y));
		p.X = (_r = p.X % w, _r === _r ? _r : go$throwRuntimeError("integer divide by zero"));
		if (p.X < 0) {
			p.X = p.X + (w) >> 0;
		}
		p.Y = (_r$1 = p.Y % h, _r$1 === _r$1 ? _r$1 : go$throwRuntimeError("integer divide by zero"));
		if (p.Y < 0) {
			p.Y = p.Y + (h) >> 0;
		}
		return (_struct$4 = p.Add((_struct$3 = r.Min, new Point.Ptr(_struct$3.X, _struct$3.Y))), new Point.Ptr(_struct$4.X, _struct$4.Y));
	};
	Point.prototype.Mod = function(r) { return this.go$val.Mod(r); };
 0Point0image:Point0Ç ÅÂ	Point.Ptr.prototype.Eq = function(q) {
		var _struct, p;
		p = (_struct = this, new Point.Ptr(_struct.X, _struct.Y));
		return (p.X === q.X) && (p.Y === q.Y);
	};
	Point.prototype.Eq = function(q) { return this.go$val.Eq(q); };
 0Point0image:Point0bPtE	Pt = go$pkg.Pt = function(X, Y) {
		return new Point.Ptr(X, Y);
	};
 0Pt0image:Point0Çæ Çâ	Rectangle.Ptr.prototype.String = function() {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return r.Min.String() + "-" + r.Max.String();
	};
	Rectangle.prototype.String = function() { return this.go$val.String(); };
 0	Rectangle0image:Pointimage:Rectangle0Ç£ Çn	Rectangle.Ptr.prototype.Dx = function() {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return r.Max.X - r.Min.X >> 0;
	};
	Rectangle.prototype.Dx = function() { return this.go$val.Dx(); };
 0	Rectangle0image:Pointimage:Rectangle0Ç£ Çn	Rectangle.Ptr.prototype.Dy = function() {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return r.Max.Y - r.Min.Y >> 0;
	};
	Rectangle.prototype.Dy = function() { return this.go$val.Dy(); };
 0	Rectangle0image:Pointimage:Rectangle0Ç– Çõ	Rectangle.Ptr.prototype.Size = function() {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return new Point.Ptr(r.Max.X - r.Min.X >> 0, r.Max.Y - r.Min.Y >> 0);
	};
	Rectangle.prototype.Size = function() { return this.go$val.Size(); };
 0	Rectangle0image:Pointimage:Rectangle0Ç Ç›	Rectangle.Ptr.prototype.Add = function(p) {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return new Rectangle.Ptr(new Point.Ptr(r.Min.X + p.X >> 0, r.Min.Y + p.Y >> 0), new Point.Ptr(r.Max.X + p.X >> 0, r.Max.Y + p.Y >> 0));
	};
	Rectangle.prototype.Add = function(p) { return this.go$val.Add(p); };
 0	Rectangle0image:Pointimage:Rectangle0Ç Ç›	Rectangle.Ptr.prototype.Sub = function(p) {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return new Rectangle.Ptr(new Point.Ptr(r.Min.X - p.X >> 0, r.Min.Y - p.Y >> 0), new Point.Ptr(r.Max.X - p.X >> 0, r.Max.Y - p.Y >> 0));
	};
	Rectangle.prototype.Sub = function(p) { return this.go$val.Sub(p); };
 0	Rectangle0image:Pointimage:Rectangle0Ç6 Ç	Rectangle.Ptr.prototype.Inset = function(n) {
		var _struct, _struct$1, _struct$2, r, x, _q, x$1, _q$1, _struct$3, _struct$4, _struct$5;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (r.Dx() < (x = 2, (((x >>> 16 << 16) * n >> 0) + (x << 16 >>> 16) * n) >> 0)) {
			r.Min.X = (_q = ((r.Min.X + r.Max.X >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"));
			r.Max.X = r.Min.X;
		} else {
			r.Min.X = r.Min.X + (n) >> 0;
			r.Max.X = r.Max.X - (n) >> 0;
		}
		if (r.Dy() < (x$1 = 2, (((x$1 >>> 16 << 16) * n >> 0) + (x$1 << 16 >>> 16) * n) >> 0)) {
			r.Min.Y = (_q$1 = ((r.Min.Y + r.Max.Y >> 0)) / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"));
			r.Max.Y = r.Min.Y;
		} else {
			r.Min.Y = r.Min.Y + (n) >> 0;
			r.Max.Y = r.Max.Y - (n) >> 0;
		}
		return (_struct$3 = r, new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
	};
	Rectangle.prototype.Inset = function(n) { return this.go$val.Inset(n); };
 0	Rectangle0image:Pointimage:Rectangle0Çi Ç*	Rectangle.Ptr.prototype.Intersect = function(s) {
		var _struct, _struct$1, _struct$2, r, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (r.Min.X < s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y < s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X > s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y > s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		if (r.Min.X > r.Max.X || r.Min.Y > r.Max.Y) {
			return (_struct$3 = go$pkg.ZR, new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		}
		return (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y))));
	};
	Rectangle.prototype.Intersect = function(s) { return this.go$val.Intersect(s); };
 0	Rectangle0(image:Pointimage:Rectangleimage:ZR0Ç< Ç	Rectangle.Ptr.prototype.Union = function(s) {
		var _struct, _struct$1, _struct$2, r, _struct$3, _struct$4, _struct$5;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (r.Min.X > s.Min.X) {
			r.Min.X = s.Min.X;
		}
		if (r.Min.Y > s.Min.Y) {
			r.Min.Y = s.Min.Y;
		}
		if (r.Max.X < s.Max.X) {
			r.Max.X = s.Max.X;
		}
		if (r.Max.Y < s.Max.Y) {
			r.Max.Y = s.Max.Y;
		}
		return (_struct$3 = r, new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
	};
	Rectangle.prototype.Union = function(s) { return this.go$val.Union(s); };
 0	Rectangle0image:Pointimage:Rectangle0Çæ Çâ	Rectangle.Ptr.prototype.Empty = function() {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return r.Min.X >= r.Max.X || r.Min.Y >= r.Max.Y;
	};
	Rectangle.prototype.Empty = function() { return this.go$val.Empty(); };
 0	Rectangle0image:Pointimage:Rectangle0Ç Çª	Rectangle.Ptr.prototype.Eq = function(s) {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return (r.Min.X === s.Min.X) && (r.Min.Y === s.Min.Y) && (r.Max.X === s.Max.X) && (r.Max.Y === s.Max.Y);
	};
	Rectangle.prototype.Eq = function(s) { return this.go$val.Eq(s); };
 0	Rectangle0image:Pointimage:Rectangle0ÇÚ ÇΩ	Rectangle.Ptr.prototype.Overlaps = function(s) {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		return r.Min.X < s.Max.X && s.Min.X < r.Max.X && r.Min.Y < s.Max.Y && s.Min.Y < r.Max.Y;
	};
	Rectangle.prototype.Overlaps = function(s) { return this.go$val.Overlaps(s); };
 0	Rectangle0image:Pointimage:Rectangle0Ç Ç÷	Rectangle.Ptr.prototype.In = function(s) {
		var _struct, _struct$1, _struct$2, r;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (r.Empty()) {
			return true;
		}
		return s.Min.X <= r.Min.X && r.Max.X <= s.Max.X && s.Min.Y <= r.Min.Y && r.Max.Y <= s.Max.Y;
	};
	Rectangle.prototype.In = function(s) { return this.go$val.In(s); };
 0	Rectangle0image:Pointimage:Rectangle0ÇO Ç	Rectangle.Ptr.prototype.Canon = function() {
		var _struct, _struct$1, _struct$2, r, _tuple, _tuple$1, _struct$3, _struct$4, _struct$5;
		r = (_struct = this, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
		if (r.Max.X < r.Min.X) {
			_tuple = [r.Max.X, r.Min.X], r.Min.X = _tuple[0], r.Max.X = _tuple[1];
		}
		if (r.Max.Y < r.Min.Y) {
			_tuple$1 = [r.Max.Y, r.Min.Y], r.Min.Y = _tuple$1[0], r.Max.Y = _tuple$1[1];
		}
		return (_struct$3 = r, new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
	};
	Rectangle.prototype.Canon = function() { return this.go$val.Canon(); };
 0	Rectangle0image:Pointimage:Rectangle0ÇgRectÇ3	Rect = go$pkg.Rect = function(x0, y0, x1, y1) {
		var _tuple, _tuple$1;
		if (x0 > x1) {
			_tuple = [x1, x0], x0 = _tuple[0], x1 = _tuple[1];
		}
		if (y0 > y1) {
			_tuple$1 = [y1, y0], y0 = _tuple$1[0], y1 = _tuple$1[1];
		}
		return new Rectangle.Ptr(new Point.Ptr(x0, y0), new Point.Ptr(x1, y1));
	};
 0Rect0image:Pointimage:Rectangle0Å„ ÅØ	RGBA.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.RGBAModel;
	};
	RGBA.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0RGBA0#image/color:RGBAModel
image:RGBA0Çú Ç`	RGBA.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	RGBA.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0RGBA0*image:Point
image:RGBAimage:Rectangle0Çü ÇQ	RGBA.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.RGBA.Ptr(0, 0, 0, 0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.RGBA.Ptr((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = p.Pix, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), (_slice$3 = p.Pix, _index$3 = (i + 3 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))), new x$2.constructor.Struct(x$2));
	};
	RGBA.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0RGBA0<image/color:RGBAimage:Point
image:RGBAimage:Rectangle0Ç¿ Ç¢	RGBA.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 4, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	RGBA.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0RGBA0
image:RGBA0ÇD Çﬂ	RGBA.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.RGBAModel.Convert(c), (x$1 !== null && x$1.constructor === color.RGBA ? x$1.go$val : go$typeAssertionFailed(x$1, color.RGBA))), new color.RGBA.Ptr(_struct$3.R, _struct$3.G, _struct$3.B, _struct$3.A));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c1.R) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = c1.G) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = c1.B) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = c1.A) : go$throwRuntimeError("index out of range");
	};
	RGBA.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0RGBA0Simage/color:RGBAimage/color:RGBAModelimage:Point
image:RGBAimage:Rectangle0Ç% ÇÈ	RGBA.Ptr.prototype.SetRGBA = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c.R) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = c.G) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = c.B) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = c.A) : go$throwRuntimeError("index out of range");
	};
	RGBA.prototype.SetRGBA = function(x, y, c) { return this.go$val.SetRGBA(x, y, c); };
 0RGBA0*image:Point
image:RGBAimage:Rectangle0Ç Ç◊	RGBA.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new RGBA.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new RGBA.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	RGBA.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0RGBA0*image:Point
image:RGBAimage:Rectangle0Ç" Ç	RGBA.Ptr.prototype.Opaque = function() {
		var p, x, x$1, _tuple, i0, i1, y, i, _slice, _index;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [3, (x = p.Rect.Dx(), x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 4 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	RGBA.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0RGBA0
image:RGBA0Ç”NewRGBAÇç	NewRGBA = go$pkg.NewRGBA = function(r) {
		var _tuple, w, h, x, x$1, buf, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		buf = (go$sliceType(Go$Uint8)).make((x = (x$1 = 4, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new RGBA.Ptr(buf, (x$2 = 4, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0	NewRGBA0*image:Point
image:RGBAimage:Rectangle0ÅÔ Åµ	RGBA64.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.RGBA64Model;
	};
	RGBA64.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0RGBA640'image/color:RGBA64Modelimage:RGBA640Ç§ Çd	RGBA64.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	RGBA64.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0RGBA640,image:Pointimage:RGBA64image:Rectangle0Ç	¡ Ç	m	RGBA64.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.RGBA64.Ptr(0, 0, 0, 0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.RGBA64.Ptr(((((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$2 = p.Pix, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$3 = p.Pix, _index$3 = (i + 3 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$4 = p.Pix, _index$4 = (i + 4 >> 0), (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$5 = p.Pix, _index$5 = (i + 5 >> 0), (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$6 = p.Pix, _index$6 = (i + 6 >> 0), (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$7 = p.Pix, _index$7 = (i + 7 >> 0), (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0), new x$2.constructor.Struct(x$2));
	};
	RGBA64.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0RGBA640@image/color:RGBA64image:Pointimage:RGBA64image:Rectangle0Ç» Ç¶	RGBA64.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 8, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	RGBA64.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0RGBA640image:RGBA640Ç
h Ç	˚	RGBA64.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.RGBA64Model.Convert(c), (x$1 !== null && x$1.constructor === color.RGBA64 ? x$1.go$val : go$typeAssertionFailed(x$1, color.RGBA64))), new color.RGBA64.Ptr(_struct$3.R, _struct$3.G, _struct$3.B, _struct$3.A));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c1.R >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c1.R << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((c1.G >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (c1.G << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$4 = p.Pix, _index$4 = i + 4 >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = ((c1.B >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$5 = p.Pix, _index$5 = i + 5 >> 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (c1.B << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$6 = p.Pix, _index$6 = i + 6 >> 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = ((c1.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$7 = p.Pix, _index$7 = i + 7 >> 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (c1.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	RGBA64.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0RGBA640Yimage/color:RGBA64image/color:RGBA64Modelimage:Pointimage:RGBA64image:Rectangle0Ç	? Çˇ	RGBA64.Ptr.prototype.SetRGBA64 = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c.R >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c.R << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((c.G >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (c.G << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$4 = p.Pix, _index$4 = i + 4 >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = ((c.B >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$5 = p.Pix, _index$5 = i + 5 >> 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (c.B << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$6 = p.Pix, _index$6 = i + 6 >> 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = ((c.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$7 = p.Pix, _index$7 = i + 7 >> 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (c.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	RGBA64.prototype.SetRGBA64 = function(x, y, c) { return this.go$val.SetRGBA64(x, y, c); };
 0RGBA640,image:Pointimage:RGBA64image:Rectangle0Ç Çﬂ	RGBA64.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new RGBA64.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new RGBA64.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	RGBA64.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0RGBA640,image:Pointimage:RGBA64image:Rectangle0Ç ÇÏ	RGBA64.Ptr.prototype.Opaque = function() {
		var p, x, x$1, _tuple, i0, i1, y, i, _slice, _index, _slice$1, _index$1;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [6, (x = p.Rect.Dx(), x$1 = 8, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255)) || !(((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 8 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	RGBA64.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0RGBA640image:RGBA640Çﬂ	NewRGBA64Çì	NewRGBA64 = go$pkg.NewRGBA64 = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 8, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new RGBA64.Ptr(pix, (x$2 = 8, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0	NewRGBA640,image:Pointimage:RGBA64image:Rectangle0ÅÈ Å≤	NRGBA.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.NRGBAModel;
	};
	NRGBA.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0NRGBA0%image/color:NRGBAModelimage:NRGBA0Ç† Çb	NRGBA.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	NRGBA.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0NRGBA0+image:NRGBAimage:Pointimage:Rectangle0Ç¶ ÇU	NRGBA.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.NRGBA.Ptr(0, 0, 0, 0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.NRGBA.Ptr((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = p.Pix, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), (_slice$3 = p.Pix, _index$3 = (i + 3 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))), new x$2.constructor.Struct(x$2));
	};
	NRGBA.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0NRGBA0>image/color:NRGBAimage:NRGBAimage:Pointimage:Rectangle0Çƒ Ç§	NRGBA.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 4, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	NRGBA.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0NRGBA0image:NRGBA0ÇN ÇÂ	NRGBA.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.NRGBAModel.Convert(c), (x$1 !== null && x$1.constructor === color.NRGBA ? x$1.go$val : go$typeAssertionFailed(x$1, color.NRGBA))), new color.NRGBA.Ptr(_struct$3.R, _struct$3.G, _struct$3.B, _struct$3.A));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c1.R) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = c1.G) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = c1.B) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = c1.A) : go$throwRuntimeError("index out of range");
	};
	NRGBA.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0NRGBA0Vimage/color:NRGBAimage/color:NRGBAModelimage:NRGBAimage:Pointimage:Rectangle0Ç, ÇÓ	NRGBA.Ptr.prototype.SetNRGBA = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c.R) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = c.G) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = c.B) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = c.A) : go$throwRuntimeError("index out of range");
	};
	NRGBA.prototype.SetNRGBA = function(x, y, c) { return this.go$val.SetNRGBA(x, y, c); };
 0NRGBA0+image:NRGBAimage:Pointimage:Rectangle0Ç Ç€	NRGBA.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new NRGBA.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new NRGBA.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	NRGBA.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0NRGBA0+image:NRGBAimage:Pointimage:Rectangle0Ç& Ç	NRGBA.Ptr.prototype.Opaque = function() {
		var p, x, x$1, _tuple, i0, i1, y, i, _slice, _index;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [3, (x = p.Rect.Dx(), x$1 = 4, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 4 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	NRGBA.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0NRGBA0image:NRGBA0ÇŸNewNRGBAÇê	NewNRGBA = go$pkg.NewNRGBA = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 4, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new NRGBA.Ptr(pix, (x$2 = 4, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0
NewNRGBA0+image:NRGBAimage:Pointimage:Rectangle0Åı Å∏	NRGBA64.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.NRGBA64Model;
	};
	NRGBA64.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0	NRGBA640)image/color:NRGBA64Modelimage:NRGBA640Ç® Çf	NRGBA64.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	NRGBA64.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0	NRGBA640-image:NRGBA64image:Pointimage:Rectangle0Ç	» Ç	q	NRGBA64.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.NRGBA64.Ptr(0, 0, 0, 0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.NRGBA64.Ptr(((((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$2 = p.Pix, _index$2 = (i + 2 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$3 = p.Pix, _index$3 = (i + 3 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$4 = p.Pix, _index$4 = (i + 4 >> 0), (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$5 = p.Pix, _index$5 = (i + 5 >> 0), (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0, ((((_slice$6 = p.Pix, _index$6 = (i + 6 >> 0), (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$7 = p.Pix, _index$7 = (i + 7 >> 0), (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0), new x$2.constructor.Struct(x$2));
	};
	NRGBA64.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0	NRGBA640Bimage/color:NRGBA64image:NRGBA64image:Pointimage:Rectangle0ÇÃ Ç®	NRGBA64.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 8, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	NRGBA64.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0	NRGBA640image:NRGBA640Ç
r Ç
	NRGBA64.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.NRGBA64Model.Convert(c), (x$1 !== null && x$1.constructor === color.NRGBA64 ? x$1.go$val : go$typeAssertionFailed(x$1, color.NRGBA64))), new color.NRGBA64.Ptr(_struct$3.R, _struct$3.G, _struct$3.B, _struct$3.A));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c1.R >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c1.R << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((c1.G >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (c1.G << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$4 = p.Pix, _index$4 = i + 4 >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = ((c1.B >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$5 = p.Pix, _index$5 = i + 5 >> 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (c1.B << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$6 = p.Pix, _index$6 = i + 6 >> 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = ((c1.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$7 = p.Pix, _index$7 = i + 7 >> 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (c1.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	NRGBA64.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0	NRGBA640\image/color:NRGBA64image/color:NRGBA64Modelimage:NRGBA64image:Pointimage:Rectangle0Ç	F Ç		NRGBA64.Ptr.prototype.SetNRGBA64 = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c.R >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c.R << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$2 = p.Pix, _index$2 = i + 2 >> 0, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ((c.G >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$3 = p.Pix, _index$3 = i + 3 >> 0, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (c.G << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$4 = p.Pix, _index$4 = i + 4 >> 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = ((c.B >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$5 = p.Pix, _index$5 = i + 5 >> 0, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (c.B << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$6 = p.Pix, _index$6 = i + 6 >> 0, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = ((c.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$7 = p.Pix, _index$7 = i + 7 >> 0, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (c.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	NRGBA64.prototype.SetNRGBA64 = function(x, y, c) { return this.go$val.SetNRGBA64(x, y, c); };
 0	NRGBA640-image:NRGBA64image:Pointimage:Rectangle0Ç% Ç„	NRGBA64.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new NRGBA64.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new NRGBA64.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	NRGBA64.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0	NRGBA640-image:NRGBA64image:Pointimage:Rectangle0Ç ÇÓ	NRGBA64.Ptr.prototype.Opaque = function() {
		var p, x, x$1, _tuple, i0, i1, y, i, _slice, _index, _slice$1, _index$1;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [6, (x = p.Rect.Dx(), x$1 = 8, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255)) || !(((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 8 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	NRGBA64.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0	NRGBA640image:NRGBA640ÇÂ
NewNRGBA64Çñ	NewNRGBA64 = go$pkg.NewNRGBA64 = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 8, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new NRGBA64.Ptr(pix, (x$2 = 8, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0
NewNRGBA640-image:NRGBA64image:Pointimage:Rectangle0ÅÈ Å≤	Alpha.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.AlphaModel;
	};
	Alpha.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0Alpha0%image/color:AlphaModelimage:Alpha0Ç† Çb	Alpha.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	Alpha.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0Alpha0+image:Alphaimage:Pointimage:Rectangle0Ç4 Ç„	Alpha.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.Alpha.Ptr(0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.Alpha.Ptr((_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))), new x$2.constructor.Struct(x$2));
	};
	Alpha.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0Alpha0>image/color:Alphaimage:Alphaimage:Pointimage:Rectangle0Çƒ Ç§	Alpha.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 1, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	Alpha.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0Alpha0image:Alpha0Ça Ç¯	Alpha.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (x$1 = color.AlphaModel.Convert(c), (x$1 !== null && x$1.constructor === color.Alpha ? x$1.go$val : go$typeAssertionFailed(x$1, color.Alpha))).A) : go$throwRuntimeError("index out of range");
	};
	Alpha.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0Alpha0Vimage/color:Alphaimage/color:AlphaModelimage:Alphaimage:Pointimage:Rectangle0Ç≥ Çu	Alpha.Ptr.prototype.SetAlpha = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c.A) : go$throwRuntimeError("index out of range");
	};
	Alpha.prototype.SetAlpha = function(x, y, c) { return this.go$val.SetAlpha(x, y, c); };
 0Alpha0+image:Alphaimage:Pointimage:Rectangle0Ç Ç€	Alpha.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new Alpha.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Alpha.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	Alpha.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0Alpha0+image:Alphaimage:Pointimage:Rectangle0Ç– Ç∞	Alpha.Ptr.prototype.Opaque = function() {
		var p, _tuple, i0, i1, y, i, _slice, _index;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [0, p.Rect.Dx()], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 1 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	Alpha.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0Alpha0image:Alpha0ÇŸNewAlphaÇê	NewAlpha = go$pkg.NewAlpha = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 1, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new Alpha.Ptr(pix, (x$2 = 1, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0
NewAlpha0+image:Alphaimage:Pointimage:Rectangle0Åı Å∏	Alpha16.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.Alpha16Model;
	};
	Alpha16.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0	Alpha160)image/color:Alpha16Modelimage:Alpha160Ç® Çf	Alpha16.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	Alpha16.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0	Alpha160-image:Alpha16image:Pointimage:Rectangle0ÇR Ç˚	Alpha16.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.Alpha16.Ptr(0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.Alpha16.Ptr(((((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0), new x$2.constructor.Struct(x$2));
	};
	Alpha16.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0	Alpha160Bimage/color:Alpha16image:Alpha16image:Pointimage:Rectangle0ÇÃ Ç®	Alpha16.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 2, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	Alpha16.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0	Alpha160image:Alpha160ÇÃ Ç[	Alpha16.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.Alpha16Model.Convert(c), (x$1 !== null && x$1.constructor === color.Alpha16 ? x$1.go$val : go$typeAssertionFailed(x$1, color.Alpha16))), new color.Alpha16.Ptr(_struct$3.A));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c1.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c1.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	Alpha16.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0	Alpha160\image/color:Alpha16image/color:Alpha16Modelimage:Alpha16image:Pointimage:Rectangle0ÇÕ Çã	Alpha16.Ptr.prototype.SetAlpha16 = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c.A >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c.A << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	Alpha16.prototype.SetAlpha16 = function(x, y, c) { return this.go$val.SetAlpha16(x, y, c); };
 0	Alpha160-image:Alpha16image:Pointimage:Rectangle0Ç% Ç„	Alpha16.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new Alpha16.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Alpha16.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	Alpha16.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0	Alpha160-image:Alpha16image:Pointimage:Rectangle0Ç ÇÓ	Alpha16.Ptr.prototype.Opaque = function() {
		var p, x, x$1, _tuple, i0, i1, y, i, _slice, _index, _slice$1, _index$1;
		p = this;
		if (p.Rect.Empty()) {
			return true;
		}
		_tuple = [0, (x = p.Rect.Dx(), x$1 = 2, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0)], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			i = i0;
			while (i < i1) {
				if (!(((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 255)) || !(((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) === 255))) {
					return false;
				}
				i = i + 2 >> 0;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		return true;
	};
	Alpha16.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0	Alpha160image:Alpha160ÇÂ
NewAlpha16Çñ	NewAlpha16 = go$pkg.NewAlpha16 = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 2, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new Alpha16.Ptr(pix, (x$2 = 2, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0
NewAlpha160-image:Alpha16image:Pointimage:Rectangle0Å„ ÅØ	Gray.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.GrayModel;
	};
	Gray.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0Gray0#image/color:GrayModel
image:Gray0Çú Ç`	Gray.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	Gray.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0Gray0*
image:Grayimage:Pointimage:Rectangle0Ç- Çﬂ	Gray.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.Gray.Ptr(0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.Gray.Ptr((_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))), new x$2.constructor.Struct(x$2));
	};
	Gray.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0Gray0<image/color:Gray
image:Grayimage:Pointimage:Rectangle0Ç¿ Ç¢	Gray.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 1, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	Gray.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0Gray0
image:Gray0ÇX ÇÛ	Gray.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (x$1 = color.GrayModel.Convert(c), (x$1 !== null && x$1.constructor === color.Gray ? x$1.go$val : go$typeAssertionFailed(x$1, color.Gray))).Y) : go$throwRuntimeError("index out of range");
	};
	Gray.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0Gray0Simage/color:Grayimage/color:GrayModel
image:Grayimage:Pointimage:Rectangle0Ç¨ Çp	Gray.Ptr.prototype.SetGray = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c.Y) : go$throwRuntimeError("index out of range");
	};
	Gray.prototype.SetGray = function(x, y, c) { return this.go$val.SetGray(x, y, c); };
 0Gray0*
image:Grayimage:Pointimage:Rectangle0Ç Ç◊	Gray.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new Gray.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Gray.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	Gray.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0Gray0*
image:Grayimage:Pointimage:Rectangle0Åµ Åò	Gray.Ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	Gray.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0Gray0
image:Gray0Ç”NewGrayÇç	NewGray = go$pkg.NewGray = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 1, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new Gray.Ptr(pix, (x$2 = 1, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0	NewGray0*
image:Grayimage:Pointimage:Rectangle0ÅÔ Åµ	Gray16.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.Gray16Model;
	};
	Gray16.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0Gray160'image/color:Gray16Modelimage:Gray160Ç§ Çd	Gray16.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	Gray16.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0Gray160,image:Gray16image:Pointimage:Rectangle0ÇK Ç˜	Gray16.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, i, x$2, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.Gray16.Ptr(0), new x$1.constructor.Struct(x$1));
		}
		i = p.PixOffset(x, y);
		return (x$2 = new color.Gray16.Ptr(((((_slice = p.Pix, _index = (i + 0 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) << 16 >>> 16) << 8 << 16 >>> 16) | ((_slice$1 = p.Pix, _index$1 = (i + 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) << 16 >>> 16)) >>> 0), new x$2.constructor.Struct(x$2));
	};
	Gray16.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0Gray160@image/color:Gray16image:Gray16image:Pointimage:Rectangle0Ç» Ç¶	Gray16.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 2, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	Gray16.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0Gray160image:Gray160Ç¬ ÇU	Gray16.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, x$1, _struct$3, c1, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		c1 = (_struct$3 = (x$1 = color.Gray16Model.Convert(c), (x$1 !== null && x$1.constructor === color.Gray16 ? x$1.go$val : go$typeAssertionFailed(x$1, color.Gray16))), new color.Gray16.Ptr(_struct$3.Y));
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c1.Y >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c1.Y << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	Gray16.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0Gray160Yimage/color:Gray16image/color:Gray16Modelimage:Gray16image:Pointimage:Rectangle0Ç∆ ÇÜ	Gray16.Ptr.prototype.SetGray16 = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index, _slice$1, _index$1;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i + 0 >> 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = ((c.Y >>> 8 << 16 >>> 16) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = p.Pix, _index$1 = i + 1 >> 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (c.Y << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	Gray16.prototype.SetGray16 = function(x, y, c) { return this.go$val.SetGray16(x, y, c); };
 0Gray160,image:Gray16image:Pointimage:Rectangle0Ç Çﬂ	Gray16.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new Gray16.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr());
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Gray16.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	Gray16.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0Gray160,image:Gray16image:Pointimage:Rectangle0ÅΩ Åú	Gray16.Ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	Gray16.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0Gray160image:Gray160Çﬂ	NewGray16Çì	NewGray16 = go$pkg.NewGray16 = function(r) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 2, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new Gray16.Ptr(pix, (x$2 = 2, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0	NewGray160,image:Gray16image:Pointimage:Rectangle0Å÷ Å±	Paletted.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return p.Palette;
	};
	Paletted.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0
Paletted0image:Paletted0Ç¨ Çh	Paletted.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	Paletted.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0
Paletted0.image:Palettedimage:Pointimage:Rectangle0Ç[ Ç	Paletted.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, _slice, _index, i, _slice$1, _index$1, _slice$2, _index$2;
		p = this;
		if (p.Palette.length === 0) {
			return null;
		}
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (_slice = p.Palette, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		i = p.PixOffset(x, y);
		return (_slice$1 = p.Palette, _index$1 = (_slice$2 = p.Pix, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
	};
	Paletted.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0
Paletted0.image:Palettedimage:Pointimage:Rectangle0Ç– Ç™	Paletted.Ptr.prototype.PixOffset = function(x, y) {
		var p, x$1, x$2, x$3, x$4;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.Stride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (x$3 = (x - p.Rect.Min.X >> 0), x$4 = 1, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) >> 0;
	};
	Paletted.prototype.PixOffset = function(x, y) { return this.go$val.PixOffset(x, y); };
 0
Paletted0image:Paletted0ÇŒ Çä	Paletted.Ptr.prototype.Set = function(x, y, c) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (p.Palette.Index(c) << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
	Paletted.prototype.Set = function(x, y, c) { return this.go$val.Set(x, y, c); };
 0
Paletted0.image:Palettedimage:Pointimage:Rectangle0Ç≈ ÇÅ	Paletted.Ptr.prototype.ColorIndexAt = function(x, y) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return 0;
		}
		i = p.PixOffset(x, y);
		return (_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
	};
	Paletted.prototype.ColorIndexAt = function(x, y) { return this.go$val.ColorIndexAt(x, y); };
 0
Paletted0.image:Palettedimage:Pointimage:Rectangle0Ç‹ Çò	Paletted.Ptr.prototype.SetColorIndex = function(x, y, index) {
		var p, _struct, _struct$1, _struct$2, i, _slice, _index;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return;
		}
		i = p.PixOffset(x, y);
		_slice = p.Pix, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = index) : go$throwRuntimeError("index out of range");
	};
	Paletted.prototype.SetColorIndex = function(x, y, index) { return this.go$val.SetColorIndex(x, y, index); };
 0
Paletted0.image:Palettedimage:Pointimage:Rectangle0Ç> ÇÂ	Paletted.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, i, _struct$6, _struct$7, _struct$8, _struct$9, _struct$10, _struct$11;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new Paletted.Ptr((go$sliceType(Go$Uint8)).nil, 0, new Rectangle.Ptr(), p.Palette);
		}
		i = p.PixOffset(r.Min.X, r.Min.Y);
		return new Paletted.Ptr(go$subslice(p.Pix, i), p.Stride, (_struct$9 = p.Rect.Intersect((_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y))))), new Rectangle.Ptr((_struct$10 = _struct$9.Min, new Point.Ptr(_struct$10.X, _struct$10.Y)), (_struct$11 = _struct$9.Max, new Point.Ptr(_struct$11.X, _struct$11.Y)))), p.Palette);
	};
	Paletted.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0
Paletted0Cimage/color:Paletteimage:Palettedimage:Pointimage:Rectangle0Ç Ç›	Paletted.Ptr.prototype.Opaque = function() {
		var p, present, _tuple, i0, i1, y, _ref, _i, _slice, _index, c, _ref$1, _i$1, _slice$1, _index$1, c$1, i, _tuple$1, a;
		p = this;
		present = go$makeNativeArray("Bool", 256, function() { return false; });
		_tuple = [0, p.Rect.Dx()], i0 = _tuple[0], i1 = _tuple[1];
		y = p.Rect.Min.Y;
		while (y < p.Rect.Max.Y) {
			_ref = go$subslice(p.Pix, i0, i1);
			_i = 0;
			while (_i < _ref.length) {
				c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				present[c] = true;
				_i++;
			}
			i0 = i0 + (p.Stride) >> 0;
			i1 = i1 + (p.Stride) >> 0;
			y = y + 1 >> 0;
		}
		_ref$1 = p.Palette;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			c$1 = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			i = _i$1;
			if (!present[i]) {
				_i$1++;
				continue;
			}
			_tuple$1 = c$1.RGBA(), a = _tuple$1[3];
			if (!((a === 65535))) {
				return false;
			}
			_i$1++;
		}
		return true;
	};
	Paletted.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0
Paletted0image:Paletted0ÇÒNewPalettedÇü	NewPaletted = go$pkg.NewPaletted = function(r, p) {
		var _tuple, w, h, x, x$1, pix, x$2, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy()], w = _tuple[0], h = _tuple[1];
		pix = (go$sliceType(Go$Uint8)).make((x = (x$1 = 1, (((x$1 >>> 16 << 16) * w >> 0) + (x$1 << 16 >>> 16) * w) >> 0), (((x >>> 16 << 16) * h >> 0) + (x << 16 >>> 16) * h) >> 0), 0, function() { return 0; });
		return new Paletted.Ptr(pix, (x$2 = 1, (((x$2 >>> 16 << 16) * w >> 0) + (x$2 << 16 >>> 16) * w) >> 0), (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))), p);
	};
 0NewPaletted0.image:Palettedimage:Pointimage:Rectangle0ÇO Ç+	Uniform.Ptr.prototype.RGBA = function() {
		var r, g, b, a, c, _tuple;
		r = 0;
		g = 0;
		b = 0;
		a = 0;
		c = this;
		_tuple = c.C.RGBA(), r = _tuple[0], g = _tuple[1], b = _tuple[2], a = _tuple[3];
		return [r, g, b, a];
	};
	Uniform.prototype.RGBA = function() { return this.go$val.RGBA(); };
 0	Uniform0image:Uniform0Å  Åß	Uniform.Ptr.prototype.ColorModel = function() {
		var c;
		c = this;
		return c;
	};
	Uniform.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0	Uniform0image:Uniform0Å√ Å†	Uniform.Ptr.prototype.Convert = function() {
		var c;
		c = this;
		return c.C;
	};
	Uniform.prototype.Convert = function() { return this.go$val.Convert(); };
 0	Uniform0image:Uniform0Ç< Å˚	Uniform.Ptr.prototype.Bounds = function() {
		var c;
		c = this;
		return new Rectangle.Ptr(new Point.Ptr(-1000000000, -1000000000), new Point.Ptr(1000000000, 1000000000));
	};
	Uniform.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0	Uniform0-image:Pointimage:Rectangleimage:Uniform0Å¿ Åù	Uniform.Ptr.prototype.At = function(x, y) {
		var c;
		c = this;
		return c.C;
	};
	Uniform.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0	Uniform0image:Uniform0Å˘ Å÷	Uniform.Ptr.prototype.Opaque = function() {
		var c, _tuple, a;
		c = this;
		_tuple = c.C.RGBA(), a = _tuple[3];
		return a === 65535;
	};
	Uniform.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0	Uniform0image:Uniform0ÅÄ
NewUniformQ	NewUniform = go$pkg.NewUniform = function(c) {
		return new Uniform.Ptr(c);
	};
 0
NewUniform0image:Uniform0Ç? Ç	YCbCrSubsampleRatio.prototype.String = function() {
		var s, _ref;
		s = this.go$val;
		_ref = s;
		if (_ref === 0) {
			return "YCbCrSubsampleRatio444";
		} else if (_ref === 1) {
			return "YCbCrSubsampleRatio422";
		} else if (_ref === 2) {
			return "YCbCrSubsampleRatio420";
		} else if (_ref === 3) {
			return "YCbCrSubsampleRatio440";
		}
		return "YCbCrSubsampleRatioUnknown";
	};
	go$ptrType(YCbCrSubsampleRatio).prototype.String = function() { return new YCbCrSubsampleRatio(this.go$get()).String(); };
 0YCbCrSubsampleRatio0image:YCbCrSubsampleRatio0ÅÈ Å≤	YCbCr.Ptr.prototype.ColorModel = function() {
		var p;
		p = this;
		return color.YCbCrModel;
	};
	YCbCr.prototype.ColorModel = function() { return this.go$val.ColorModel(); };
 0YCbCr0%image/color:YCbCrModelimage:YCbCr0Ç† Çb	YCbCr.Ptr.prototype.Bounds = function() {
		var p, _struct, _struct$1, _struct$2;
		p = this;
		return (_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))));
	};
	YCbCr.prototype.Bounds = function() { return this.go$val.Bounds(); };
 0YCbCr0+image:Pointimage:Rectangleimage:YCbCr0Ç” ÇÇ	YCbCr.Ptr.prototype.At = function(x, y) {
		var p, _struct, _struct$1, _struct$2, x$1, yi, ci, x$2, _slice, _index, _slice$1, _index$1, _slice$2, _index$2;
		p = this;
		if (!(new Point.Ptr(x, y).In((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))))) {
			return (x$1 = new color.YCbCr.Ptr(0, 0, 0), new x$1.constructor.Struct(x$1));
		}
		yi = p.YOffset(x, y);
		ci = p.COffset(x, y);
		return (x$2 = new color.YCbCr.Ptr((_slice = p.Y, _index = yi, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p.Cb, _index$1 = ci, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), (_slice$2 = p.Cr, _index$2 = ci, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))), new x$2.constructor.Struct(x$2));
	};
	YCbCr.prototype.At = function(x, y) { return this.go$val.At(x, y); };
 0YCbCr0>image/color:YCbCrimage:Pointimage:Rectangleimage:YCbCr0Çc ÇC	YCbCr.Ptr.prototype.YOffset = function(x, y) {
		var p, x$1, x$2;
		p = this;
		return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.YStride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + ((x - p.Rect.Min.X >> 0)) >> 0;
	};
	YCbCr.prototype.YOffset = function(x, y) { return this.go$val.YOffset(x, y); };
 0YCbCr0image:YCbCr0Ç“ Ç≤	YCbCr.Ptr.prototype.COffset = function(x, y) {
		var p, _ref, x$1, x$2, _q, _q$1, x$3, _q$2, _q$3, x$4, _q$4, _q$5, x$5, _q$6, _q$7, x$6, x$7, x$8;
		p = this;
		_ref = p.SubsampleRatio;
		if (_ref === 1) {
			return (x$1 = (y - p.Rect.Min.Y >> 0), x$2 = p.CStride, (((x$1 >>> 16 << 16) * x$2 >> 0) + (x$1 << 16 >>> 16) * x$2) >> 0) + (((_q = x / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$1 = p.Rect.Min.X / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		} else if (_ref === 2) {
			return (x$3 = ((_q$2 = y / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$3 = p.Rect.Min.Y / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0), x$4 = p.CStride, (((x$3 >>> 16 << 16) * x$4 >> 0) + (x$3 << 16 >>> 16) * x$4) >> 0) + (((_q$4 = x / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$5 = p.Rect.Min.X / 2, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0)) >> 0;
		} else if (_ref === 3) {
			return (x$5 = ((_q$6 = y / 2, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$7 = p.Rect.Min.Y / 2, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0), x$6 = p.CStride, (((x$5 >>> 16 << 16) * x$6 >> 0) + (x$5 << 16 >>> 16) * x$6) >> 0) + ((x - p.Rect.Min.X >> 0)) >> 0;
		}
		return (x$7 = (y - p.Rect.Min.Y >> 0), x$8 = p.CStride, (((x$7 >>> 16 << 16) * x$8 >> 0) + (x$7 << 16 >>> 16) * x$8) >> 0) + ((x - p.Rect.Min.X >> 0)) >> 0;
	};
	YCbCr.prototype.COffset = function(x, y) { return this.go$val.COffset(x, y); };
 0YCbCr0image:YCbCr0Ç› Çü	YCbCr.Ptr.prototype.SubImage = function(r) {
		var p, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, yi, ci, _struct$6, _struct$7, _struct$8;
		p = this;
		r = (_struct$3 = r.Intersect((_struct = p.Rect, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y))))), new Rectangle.Ptr((_struct$4 = _struct$3.Min, new Point.Ptr(_struct$4.X, _struct$4.Y)), (_struct$5 = _struct$3.Max, new Point.Ptr(_struct$5.X, _struct$5.Y))));
		if (r.Empty()) {
			return new YCbCr.Ptr((go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, 0, 0, p.SubsampleRatio, new Rectangle.Ptr());
		}
		yi = p.YOffset(r.Min.X, r.Min.Y);
		ci = p.COffset(r.Min.X, r.Min.Y);
		return new YCbCr.Ptr(go$subslice(p.Y, yi), go$subslice(p.Cb, ci), go$subslice(p.Cr, ci), p.YStride, p.CStride, p.SubsampleRatio, (_struct$6 = r, new Rectangle.Ptr((_struct$7 = _struct$6.Min, new Point.Ptr(_struct$7.X, _struct$7.Y)), (_struct$8 = _struct$6.Max, new Point.Ptr(_struct$8.X, _struct$8.Y)))));
	};
	YCbCr.prototype.SubImage = function(r) { return this.go$val.SubImage(r); };
 0YCbCr0+image:Pointimage:Rectangleimage:YCbCr0Åπ Åö	YCbCr.Ptr.prototype.Opaque = function() {
		var p;
		p = this;
		return true;
	};
	YCbCr.prototype.Opaque = function() { return this.go$val.Opaque(); };
 0YCbCr0image:YCbCr0ÇsNewYCbCrÇ*	NewYCbCr = go$pkg.NewYCbCr = function(r, subsampleRatio) {
		var _tuple, w, h, cw, ch, _ref, _q, _q$1, _q$2, _q$3, _q$4, _q$5, _q$6, _q$7, x, x$1, b, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, _struct, _struct$1, _struct$2;
		_tuple = [r.Dx(), r.Dy(), 0, 0], w = _tuple[0], h = _tuple[1], cw = _tuple[2], ch = _tuple[3];
		_ref = subsampleRatio;
		if (_ref === 1) {
			cw = (_q = ((r.Max.X + 1 >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$1 = r.Min.X / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			ch = h;
		} else if (_ref === 2) {
			cw = (_q$2 = ((r.Max.X + 1 >> 0)) / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$3 = r.Min.X / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			ch = (_q$4 = ((r.Max.Y + 1 >> 0)) / 2, (_q$4 === _q$4 && _q$4 !== 1/0 && _q$4 !== -1/0) ? _q$4 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$5 = r.Min.Y / 2, (_q$5 === _q$5 && _q$5 !== 1/0 && _q$5 !== -1/0) ? _q$5 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
		} else if (_ref === 3) {
			cw = w;
			ch = (_q$6 = ((r.Max.Y + 1 >> 0)) / 2, (_q$6 === _q$6 && _q$6 !== 1/0 && _q$6 !== -1/0) ? _q$6 >> 0 : go$throwRuntimeError("integer divide by zero")) - (_q$7 = r.Min.Y / 2, (_q$7 === _q$7 && _q$7 !== 1/0 && _q$7 !== -1/0) ? _q$7 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
		} else {
			cw = w;
			ch = h;
		}
		b = (go$sliceType(Go$Uint8)).make(((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0) + (x = (x$1 = 2, (((x$1 >>> 16 << 16) * cw >> 0) + (x$1 << 16 >>> 16) * cw) >> 0), (((x >>> 16 << 16) * ch >> 0) + (x << 16 >>> 16) * ch) >> 0) >> 0, 0, function() { return 0; });
		return new YCbCr.Ptr(go$subslice(b, 0, ((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0)), go$subslice(b, ((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0) + (x$2 = (x$3 = 0, (((x$3 >>> 16 << 16) * cw >> 0) + (x$3 << 16 >>> 16) * cw) >> 0), (((x$2 >>> 16 << 16) * ch >> 0) + (x$2 << 16 >>> 16) * ch) >> 0) >> 0, (((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0) + (x$4 = (x$5 = 1, (((x$5 >>> 16 << 16) * cw >> 0) + (x$5 << 16 >>> 16) * cw) >> 0), (((x$4 >>> 16 << 16) * ch >> 0) + (x$4 << 16 >>> 16) * ch) >> 0) >> 0)), go$subslice(b, ((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0) + (x$6 = (x$7 = 1, (((x$7 >>> 16 << 16) * cw >> 0) + (x$7 << 16 >>> 16) * cw) >> 0), (((x$6 >>> 16 << 16) * ch >> 0) + (x$6 << 16 >>> 16) * ch) >> 0) >> 0, (((((w >>> 16 << 16) * h >> 0) + (w << 16 >>> 16) * h) >> 0) + (x$8 = (x$9 = 2, (((x$9 >>> 16 << 16) * cw >> 0) + (x$9 << 16 >>> 16) * cw) >> 0), (((x$8 >>> 16 << 16) * ch >> 0) + (x$8 << 16 >>> 16) * ch) >> 0) >> 0)), w, cw, subsampleRatio, (_struct = r, new Rectangle.Ptr((_struct$1 = _struct.Min, new Point.Ptr(_struct$1.X, _struct$1.Y)), (_struct$2 = _struct.Max, new Point.Ptr(_struct$2.X, _struct$2.Y)))));
	};
 0
NewYCbCr0+image:Pointimage:Rectangleimage:YCbCr0   0	ErrFormat0 0_formats (		formats = (go$sliceType(format)).nil;
0	formats0image:formatimage:formats0D  		go$pkg.ZP = new Point.Ptr();
0ZP0image:Pointimage:ZP0L  #		go$pkg.ZR = new Rectangle.Ptr();
0ZR0image:Rectangleimage:ZR0   0Black0 0   0White0 0   0Transparent0 0   0Opaque0 0a  :		go$pkg.ErrFormat = errors.New("image: unknown format");
0 0
errors:Newimage:ErrFormat0Åí  V		var x;
		go$pkg.Black = NewUniform((x = color.Black, new x.constructor.Struct(x)));
0 02image/color:Blackimage:Blackimage:NewUniform0Åö  ^		var x$1;
		go$pkg.White = NewUniform((x$1 = color.White, new x$1.constructor.Struct(x$1)));
0 02image/color:Whiteimage:NewUniformimage:White0Å≤  j		var x$2;
		go$pkg.Transparent = NewUniform((x$2 = color.Transparent, new x$2.constructor.Struct(x$2)));
0 0>image/color:Transparentimage:NewUniformimage:Transparent0Åû  `		var x$3;
		go$pkg.Opaque = NewUniform((x$3 = color.Opaque, new x$3.constructor.Struct(x$3)));
0 04image/color:Opaqueimage:NewUniformimage:Opaque0
   0 0 0
   0 0 0 