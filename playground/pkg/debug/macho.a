0É©debug/machoÇ2Ãpackage macho
import bytes "bytes"
import dwarf "debug/dwarf"
import binary "encoding/binary"
import errors "errors"
import fmt "fmt"
import io "io"
import os "os"
import strconv "strconv"
type @"".Cpu uint32
func (? @"".Cpu) @"".GoString() (? string)
func (? @"".Cpu) @"".String() (? string)
func (? *@"".Cpu) @"".GoString() (? string)
func (? *@"".Cpu) @"".String() (? string)
const @"".Cpu386 @"".Cpu = 0x7
const @"".CpuAmd64 @"".Cpu = 0x1000007
type @"".Dylib struct { ? @"".LoadBytes; @"".Name string; @"".Time uint32; @"".CurrentVersion uint32; @"".CompatVersion uint32 }
type @"".DylibCmd struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Name uint32; @"".Time uint32; @"".CurrentVersion uint32; @"".CompatVersion uint32 }
type @"".Dysymtab struct { ? @"".LoadBytes; ? @"".DysymtabCmd; @"".IndirectSyms []uint32 }
type @"".DysymtabCmd struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Ilocalsym uint32; @"".Nlocalsym uint32; @"".Iextdefsym uint32; @"".Nextdefsym uint32; @"".Iundefsym uint32; @"".Nundefsym uint32; @"".Tocoffset uint32; @"".Ntoc uint32; @"".Modtaboff uint32; @"".Nmodtab uint32; @"".Extrefsymoff uint32; @"".Nextrefsyms uint32; @"".Indirectsymoff uint32; @"".Nindirectsyms uint32; @"".Extreloff uint32; @"".Nextrel uint32; @"".Locreloff uint32; @"".Nlocrel uint32 }
type @"".File struct { ? @"".FileHeader; @"".ByteOrder @"encoding/binary".ByteOrder; @"".Loads []@"".Load; @"".Sections []*@"".Section; @"".Symtab *@"".Symtab; @"".Dysymtab *@"".Dysymtab; @"".closer @"io".Closer }
func (? *@"".File) @"".Close() (? error)
func (? *@"".File) @"".DWARF() (? *@"debug/dwarf".Data, ? error)
func (? *@"".File) @"".ImportedLibraries() (? []string, ? error)
func (? *@"".File) @"".ImportedSymbols() (? []string, ? error)
func (? *@"".File) @"".Section(@"".name string) (? *@"".Section)
func (? *@"".File) @"".Segment(@"".name string) (? *@"".Segment)
func (? *@"".File) @"".parseSymtab(@"".symdat []byte, @"".strtab []byte, @"".cmddat []byte, @"".hdr *@"".SymtabCmd, @"".offset int64) (? *@"".Symtab, ? error)
func (? *@"".File) @"".pushSection(@"".sh *@"".Section, @"".r @"io".ReaderAt) ()
type @"".FileHeader struct { @"".Magic uint32; @"".Cpu @"".Cpu; @"".SubCpu uint32; @"".Type @"".Type; @"".Ncmd uint32; @"".Cmdsz uint32; @"".Flags uint32 }
type @"".FormatError struct { @"".off int64; @"".msg string; @"".val interface {  } }
func (? *@"".FormatError) @"".Error() (? string)
type @"".Load interface { @"".Raw() (? []byte) }
type @"".LoadBytes []byte
func (? @"".LoadBytes) @"".Raw() (? []byte)
func (? *@"".LoadBytes) @"".Raw() (? []byte)
type @"".LoadCmd uint32
func (? @"".LoadCmd) @"".GoString() (? string)
func (? @"".LoadCmd) @"".String() (? string)
func (? *@"".LoadCmd) @"".GoString() (? string)
func (? *@"".LoadCmd) @"".String() (? string)
const @"".LoadCmdDylib @"".LoadCmd = 0xc
const @"".LoadCmdDylinker @"".LoadCmd = 0xf
const @"".LoadCmdDysymtab @"".LoadCmd = 0xb
const @"".LoadCmdSegment @"".LoadCmd = 0x1
const @"".LoadCmdSegment64 @"".LoadCmd = 0x19
const @"".LoadCmdSymtab @"".LoadCmd = 0x2
const @"".LoadCmdThread @"".LoadCmd = 0x4
const @"".LoadCmdUnixThread @"".LoadCmd = 0x5
const @"".Magic32 uint32 = 0xfeedface
const @"".Magic64 uint32 = 0xfeedfacf
func @"".NewFile(@"".r @"io".ReaderAt) (? *@"".File, ? error)
type @"".Nlist32 struct { @"".Name uint32; @"".Type uint8; @"".Sect uint8; @"".Desc uint16; @"".Value uint32 }
type @"".Nlist64 struct { @"".Name uint32; @"".Type uint8; @"".Sect uint8; @"".Desc uint16; @"".Value uint64 }
func @"".Open(@"".name string) (? *@"".File, ? error)
type @"".Regs386 struct { @"".AX uint32; @"".BX uint32; @"".CX uint32; @"".DX uint32; @"".DI uint32; @"".SI uint32; @"".BP uint32; @"".SP uint32; @"".SS uint32; @"".FLAGS uint32; @"".IP uint32; @"".CS uint32; @"".DS uint32; @"".ES uint32; @"".FS uint32; @"".GS uint32 }
type @"".RegsAMD64 struct { @"".AX uint64; @"".BX uint64; @"".CX uint64; @"".DX uint64; @"".DI uint64; @"".SI uint64; @"".BP uint64; @"".SP uint64; @"".R8 uint64; @"".R9 uint64; @"".R10 uint64; @"".R11 uint64; @"".R12 uint64; @"".R13 uint64; @"".R14 uint64; @"".R15 uint64; @"".IP uint64; @"".FLAGS uint64; @"".CS uint64; @"".FS uint64; @"".GS uint64 }
type @"".Section struct { ? @"".SectionHeader; ? @"io".ReaderAt; @"".sr *@"io".SectionReader }
func (? *@"".Section) @"".Data() (? []byte, ? error)
func (? *@"".Section) @"".Open() (? @"io".ReadSeeker)
type @"".Section32 struct { @"".Name [16]byte; @"".Seg [16]byte; @"".Addr uint32; @"".Size uint32; @"".Offset uint32; @"".Align uint32; @"".Reloff uint32; @"".Nreloc uint32; @"".Flags uint32; @"".Reserve1 uint32; @"".Reserve2 uint32 }
type @"".Section64 struct { @"".Name [16]byte; @"".Seg [16]byte; @"".Addr uint64; @"".Size uint64; @"".Offset uint32; @"".Align uint32; @"".Reloff uint32; @"".Nreloc uint32; @"".Flags uint32; @"".Reserve1 uint32; @"".Reserve2 uint32; @"".Reserve3 uint32 }
type @"".SectionHeader struct { @"".Name string; @"".Seg string; @"".Addr uint64; @"".Size uint64; @"".Offset uint32; @"".Align uint32; @"".Reloff uint32; @"".Nreloc uint32; @"".Flags uint32 }
type @"".Segment struct { ? @"".LoadBytes; ? @"".SegmentHeader; ? @"io".ReaderAt; @"".sr *@"io".SectionReader }
func (? *@"".Segment) @"".Data() (? []byte, ? error)
func (? *@"".Segment) @"".Open() (? @"io".ReadSeeker)
type @"".Segment32 struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Name [16]byte; @"".Addr uint32; @"".Memsz uint32; @"".Offset uint32; @"".Filesz uint32; @"".Maxprot uint32; @"".Prot uint32; @"".Nsect uint32; @"".Flag uint32 }
type @"".Segment64 struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Name [16]byte; @"".Addr uint64; @"".Memsz uint64; @"".Offset uint64; @"".Filesz uint64; @"".Maxprot uint32; @"".Prot uint32; @"".Nsect uint32; @"".Flag uint32 }
type @"".SegmentHeader struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Name string; @"".Addr uint64; @"".Memsz uint64; @"".Offset uint64; @"".Filesz uint64; @"".Maxprot uint32; @"".Prot uint32; @"".Nsect uint32; @"".Flag uint32 }
type @"".Symbol struct { @"".Name string; @"".Type uint8; @"".Sect uint8; @"".Desc uint16; @"".Value uint64 }
type @"".Symtab struct { ? @"".LoadBytes; ? @"".SymtabCmd; @"".Syms []@"".Symbol }
type @"".SymtabCmd struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Symoff uint32; @"".Nsyms uint32; @"".Stroff uint32; @"".Strsize uint32 }
type @"".Thread struct { @"".Cmd @"".LoadCmd; @"".Len uint32; @"".Type uint32; @"".Data []uint32 }
type @"".Type uint32
const @"".TypeExec @"".Type = 0x2
const @"".TypeObj @"".Type = 0x1
type @"".intName struct { @"".i uint32; @"".s string }
type @"encoding/binary".ByteOrder interface { @"encoding/binary".PutUint16(? []byte, ? uint16) (); @"encoding/binary".PutUint32(? []byte, ? uint32) (); @"encoding/binary".PutUint64(? []byte, ? uint64) (); @"encoding/binary".String() (? string); @"encoding/binary".Uint16(? []byte) (? uint16); @"encoding/binary".Uint32(? []byte) (? uint32); @"encoding/binary".Uint64(? []byte) (? uint64) }
type @"io".Closer interface { @"io".Close() (? error) }
type @"debug/dwarf".Data struct { @"debug/dwarf".abbrev []byte; @"debug/dwarf".aranges []byte; @"debug/dwarf".frame []byte; @"debug/dwarf".info []byte; @"debug/dwarf".line []byte; @"debug/dwarf".pubnames []byte; @"debug/dwarf".ranges []byte; @"debug/dwarf".str []byte; @"debug/dwarf".abbrevCache map[uint32]@"debug/dwarf".abbrevTable; @"debug/dwarf".addrsize int; @"debug/dwarf".order @"encoding/binary".ByteOrder; @"debug/dwarf".typeCache map[@"debug/dwarf".Offset]@"debug/dwarf".Type; @"debug/dwarf".unit []@"debug/dwarf".unit }
func (? *@"debug/dwarf".Data) @"debug/dwarf".Reader() (? *@"debug/dwarf".Reader)
func (? *@"debug/dwarf".Data) @"debug/dwarf".Type(@"debug/dwarf".off @"debug/dwarf".Offset) (? @"debug/dwarf".Type, ? error)
func (? *@"debug/dwarf".Data) @"debug/dwarf".parseAbbrev(@"debug/dwarf".off uint32) (? @"debug/dwarf".abbrevTable, ? error)
func (? *@"debug/dwarf".Data) @"debug/dwarf".parseUnits() (? []@"debug/dwarf".unit, ? error)
type @"io".ReaderAt interface { @"io".ReadAt(@"".p []byte, @"".off int64) (@"".n int, @"".err error) }
type @"io".SectionReader struct { @"io".r @"io".ReaderAt; @"io".base int64; @"io".off int64; @"io".limit int64 }
func (? *@"io".SectionReader) @"io".Read(@"".p []byte) (@"".n int, @"".err error)
func (? *@"io".SectionReader) @"io".ReadAt(@"".p []byte, @"".off int64) (@"".n int, @"".err error)
func (? *@"io".SectionReader) @"io".Seek(@"".offset int64, @"".whence int) (? int64, ? error)
func (? *@"io".SectionReader) @"io".Size() (? int64)
type @"io".ReadSeeker interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error); @"io".Seek(@"".offset int64, @"".whence int) (? int64, ? error) }
type @"debug/dwarf".abbrevTable map[uint32]@"debug/dwarf".abbrev
type @"debug/dwarf".Offset uint32
type @"debug/dwarf".Type interface { @"debug/dwarf".Common() (? *@"debug/dwarf".CommonType); @"debug/dwarf".Size() (? int64); @"debug/dwarf".String() (? string) }
type @"debug/dwarf".unit struct { @"debug/dwarf".base @"debug/dwarf".Offset; @"debug/dwarf".off @"debug/dwarf".Offset; @"debug/dwarf".data []byte; @"debug/dwarf".atable @"debug/dwarf".abbrevTable; @"debug/dwarf".asize int; @"debug/dwarf".vers int; @"debug/dwarf".is64 bool }
func (? *@"debug/dwarf".unit) @"debug/dwarf".addrsize() (? int)
func (? *@"debug/dwarf".unit) @"debug/dwarf".dwarf64() (? bool, ? bool)
func (? *@"debug/dwarf".unit) @"debug/dwarf".version() (? int)
type @"debug/dwarf".Reader struct { @"debug/dwarf".b @"debug/dwarf".buf; @"debug/dwarf".d *@"debug/dwarf".Data; @"debug/dwarf".err error; @"debug/dwarf".unit int; @"debug/dwarf".lastChildren bool; @"debug/dwarf".lastSibling @"debug/dwarf".Offset }
func (? *@"debug/dwarf".Reader) @"debug/dwarf".Next() (? *@"debug/dwarf".Entry, ? error)
func (? *@"debug/dwarf".Reader) @"debug/dwarf".Seek(@"debug/dwarf".off @"debug/dwarf".Offset) ()
func (? *@"debug/dwarf".Reader) @"debug/dwarf".SkipChildren() ()
func (? *@"debug/dwarf".Reader) @"debug/dwarf".maybeNextUnit() ()
type @"debug/dwarf".abbrev struct { @"debug/dwarf".tag @"debug/dwarf".Tag; @"debug/dwarf".children bool; @"debug/dwarf".field []@"debug/dwarf".afield }
type @"debug/dwarf".CommonType struct { @"debug/dwarf".ByteSize int64; @"debug/dwarf".Name string }
func (? *@"debug/dwarf".CommonType) @"debug/dwarf".Common() (? *@"debug/dwarf".CommonType)
func (? *@"debug/dwarf".CommonType) @"debug/dwarf".Size() (? int64)
type @"debug/dwarf".buf struct { @"debug/dwarf".dwarf *@"debug/dwarf".Data; @"debug/dwarf".order @"encoding/binary".ByteOrder; @"debug/dwarf".format @"debug/dwarf".dataFormat; @"debug/dwarf".name string; @"debug/dwarf".off @"debug/dwarf".Offset; @"debug/dwarf".data []byte; @"debug/dwarf".err error }
func (? *@"debug/dwarf".buf) @"debug/dwarf".addr() (? uint64)
func (? *@"debug/dwarf".buf) @"debug/dwarf".bytes(@"debug/dwarf".n int) (? []byte)
func (? *@"debug/dwarf".buf) @"debug/dwarf".entry(@"debug/dwarf".atab @"debug/dwarf".abbrevTable, @"debug/dwarf".ubase @"debug/dwarf".Offset) (? *@"debug/dwarf".Entry)
func (? *@"debug/dwarf".buf) @"debug/dwarf".error(@"debug/dwarf".s string) ()
func (? *@"debug/dwarf".buf) @"debug/dwarf".int() (? int64)
func (? *@"debug/dwarf".buf) @"debug/dwarf".skip(@"debug/dwarf".n int) ()
func (? *@"debug/dwarf".buf) @"debug/dwarf".string() (? string)
func (? *@"debug/dwarf".buf) @"debug/dwarf".uint() (? uint64)
func (? *@"debug/dwarf".buf) @"debug/dwarf".uint16() (? uint16)
func (? *@"debug/dwarf".buf) @"debug/dwarf".uint32() (? uint32)
func (? *@"debug/dwarf".buf) @"debug/dwarf".uint64() (? uint64)
func (? *@"debug/dwarf".buf) @"debug/dwarf".uint8() (? uint8)
func (? *@"debug/dwarf".buf) @"debug/dwarf".varint() (@"debug/dwarf".c uint64, @"debug/dwarf".bits uint)
type @"debug/dwarf".Entry struct { @"debug/dwarf".Offset @"debug/dwarf".Offset; @"debug/dwarf".Tag @"debug/dwarf".Tag; @"debug/dwarf".Children bool; @"debug/dwarf".Field []@"debug/dwarf".Field }
func (? *@"debug/dwarf".Entry) @"debug/dwarf".Val(@"debug/dwarf".a @"debug/dwarf".Attr) (? interface {  })
type @"debug/dwarf".Tag uint32
func (? @"debug/dwarf".Tag) @"debug/dwarf".GoString() (? string)
func (? @"debug/dwarf".Tag) @"debug/dwarf".String() (? string)
func (? *@"debug/dwarf".Tag) @"debug/dwarf".GoString() (? string)
func (? *@"debug/dwarf".Tag) @"debug/dwarf".String() (? string)
type @"debug/dwarf".afield struct { @"debug/dwarf".attr @"debug/dwarf".Attr; @"debug/dwarf".fmt @"debug/dwarf".format }
type @"debug/dwarf".dataFormat interface { @"debug/dwarf".addrsize() (? int); @"debug/dwarf".dwarf64() (@"debug/dwarf".dwarf64 bool, @"debug/dwarf".isKnown bool); @"debug/dwarf".version() (? int) }
type @"debug/dwarf".Field struct { @"debug/dwarf".Attr @"debug/dwarf".Attr; @"debug/dwarf".Val interface {  } }
type @"debug/dwarf".Attr uint32
func (? @"debug/dwarf".Attr) @"debug/dwarf".GoString() (? string)
func (? @"debug/dwarf".Attr) @"debug/dwarf".String() (? string)
func (? *@"debug/dwarf".Attr) @"debug/dwarf".GoString() (? string)
func (? *@"debug/dwarf".Attr) @"debug/dwarf".String() (? string)
type @"debug/dwarf".format uint32
$$
0Å°runtimeerrorssync/atomicsynciounicodeunicode/utf8bytesmathstrconvreflectencoding/binarydebug/dwarfsyscalltimeosfmtdebug/macho0Åá0bytesbytes0debug/dwarfdwarf0encoding/binarybinary0errorserrors0
fmtfmt0ioio0osos0strconvstrconv0Ç‘ò0Ç FileÇ€	File = go$pkg.File = go$newType(0, "Struct", "macho.File", "File", "debug/macho", function(FileHeader_, ByteOrder_, Loads_, Sections_, Symtab_, Dysymtab_, closer_) {
		this.go$val = this;
		this.FileHeader = FileHeader_ !== undefined ? FileHeader_ : new FileHeader.Ptr();
		this.ByteOrder = ByteOrder_ !== undefined ? ByteOrder_ : null;
		this.Loads = Loads_ !== undefined ? Loads_ : (go$sliceType(Load)).nil;
		this.Sections = Sections_ !== undefined ? Sections_ : (go$sliceType((go$ptrType(Section)))).nil;
		this.Symtab = Symtab_ !== undefined ? Symtab_ : (go$ptrType(Symtab)).nil;
		this.Dysymtab = Dysymtab_ !== undefined ? Dysymtab_ : (go$ptrType(Dysymtab)).nil;
		this.closer = closer_ !== undefined ? closer_ : null;
	});
ÇR		(go$ptrType(File)).methods = [["Close", "", [], [go$error], false, -1], ["DWARF", "", [], [(go$ptrType(dwarf.Data)), go$error], false, -1], ["ImportedLibraries", "", [], [(go$sliceType(Go$String)), go$error], false, -1], ["ImportedSymbols", "", [], [(go$sliceType(Go$String)), go$error], false, -1], ["Section", "", [Go$String], [(go$ptrType(Section))], false, -1], ["Segment", "", [Go$String], [(go$ptrType(Segment))], false, -1], ["parseSymtab", "debug/macho", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$ptrType(SymtabCmd)), Go$Int64], [(go$ptrType(Symtab)), go$error], false, -1], ["pushSection", "debug/macho", [(go$ptrType(Section)), io.ReaderAt], [], false, -1]];
		File.init([["FileHeader", "", "", FileHeader, ""], ["ByteOrder", "ByteOrder", "", binary.ByteOrder, ""], ["Loads", "Loads", "", (go$sliceType(Load)), ""], ["Sections", "Sections", "", (go$sliceType((go$ptrType(Section)))), ""], ["Symtab", "Symtab", "", (go$ptrType(Symtab)), ""], ["Dysymtab", "Dysymtab", "", (go$ptrType(Dysymtab)), ""], ["closer", "closer", "debug/macho", io.Closer, ""]]);
0File0Å⁄debug/dwarf:Datadebug/macho:Dysymtabdebug/macho:FileHeaderdebug/macho:Loaddebug/macho:Sectiondebug/macho:Segmentdebug/macho:Symtabdebug/macho:SymtabCmdencoding/binary:ByteOrder	io:Closerio:ReaderAt0Å√Load]	Load = go$pkg.Load = go$newType(0, "Interface", "macho.Load", "Load", "debug/macho", null);
R		Load.init([["Raw", "", (go$funcType([], [(go$sliceType(Go$Uint8))], false))]]);
0Load0 0ÇV	LoadBytesm	LoadBytes = go$pkg.LoadBytes = go$newType(0, "Slice", "macho.LoadBytes", "LoadBytes", "debug/macho", null);
Å 		LoadBytes.methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, -1]];
		(go$ptrType(LoadBytes)).methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, -1]];
		LoadBytes.init(Go$Uint8);
0	LoadBytes0 0ÇNSegmentHeaderÇT	SegmentHeader = go$pkg.SegmentHeader = go$newType(0, "Struct", "macho.SegmentHeader", "SegmentHeader", "debug/macho", function(Cmd_, Len_, Name_, Addr_, Memsz_, Offset_, Filesz_, Maxprot_, Prot_, Nsect_, Flag_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Addr = Addr_ !== undefined ? Addr_ : new Go$Uint64(0, 0);
		this.Memsz = Memsz_ !== undefined ? Memsz_ : new Go$Uint64(0, 0);
		this.Offset = Offset_ !== undefined ? Offset_ : new Go$Uint64(0, 0);
		this.Filesz = Filesz_ !== undefined ? Filesz_ : new Go$Uint64(0, 0);
		this.Maxprot = Maxprot_ !== undefined ? Maxprot_ : 0;
		this.Prot = Prot_ !== undefined ? Prot_ : 0;
		this.Nsect = Nsect_ !== undefined ? Nsect_ : 0;
		this.Flag = Flag_ !== undefined ? Flag_ : 0;
	});
Çª		SegmentHeader.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Name", "Name", "", Go$String, ""], ["Addr", "Addr", "", Go$Uint64, ""], ["Memsz", "Memsz", "", Go$Uint64, ""], ["Offset", "Offset", "", Go$Uint64, ""], ["Filesz", "Filesz", "", Go$Uint64, ""], ["Maxprot", "Maxprot", "", Go$Uint32, ""], ["Prot", "Prot", "", Go$Uint32, ""], ["Nsect", "Nsect", "", Go$Uint32, ""], ["Flag", "Flag", "", Go$Uint32, ""]]);
0SegmentHeader0debug/macho:LoadCmd0ÇSegmentÇ„	Segment = go$pkg.Segment = go$newType(0, "Struct", "macho.Segment", "Segment", "debug/macho", function(LoadBytes_, SegmentHeader_, ReaderAt_, sr_) {
		this.go$val = this;
		this.LoadBytes = LoadBytes_ !== undefined ? LoadBytes_ : LoadBytes.nil;
		this.SegmentHeader = SegmentHeader_ !== undefined ? SegmentHeader_ : new SegmentHeader.Ptr();
		this.ReaderAt = ReaderAt_ !== undefined ? ReaderAt_ : null;
		this.sr = sr_ !== undefined ? sr_ : (go$ptrType(io.SectionReader)).nil;
	});
Çè		Segment.methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false, 2]];
		(go$ptrType(Segment)).methods = [["Data", "", [], [(go$sliceType(Go$Uint8)), go$error], false, -1], ["Open", "", [], [io.ReadSeeker], false, -1], ["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false, 2]];
		Segment.init([["LoadBytes", "", "", LoadBytes, ""], ["SegmentHeader", "", "", SegmentHeader, ""], ["ReaderAt", "", "", io.ReaderAt, ""], ["sr", "sr", "debug/macho", (go$ptrType(io.SectionReader)), ""]]);
0	Segment0`debug/macho:LoadBytesdebug/macho:SegmentHeaderio:ReadSeekerio:ReaderAtio:SectionReader0ÇbSectionHeaderÇ≈	SectionHeader = go$pkg.SectionHeader = go$newType(0, "Struct", "macho.SectionHeader", "SectionHeader", "debug/macho", function(Name_, Seg_, Addr_, Size_, Offset_, Align_, Reloff_, Nreloc_, Flags_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Seg = Seg_ !== undefined ? Seg_ : "";
		this.Addr = Addr_ !== undefined ? Addr_ : new Go$Uint64(0, 0);
		this.Size = Size_ !== undefined ? Size_ : new Go$Uint64(0, 0);
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Align = Align_ !== undefined ? Align_ : 0;
		this.Reloff = Reloff_ !== undefined ? Reloff_ : 0;
		this.Nreloc = Nreloc_ !== undefined ? Nreloc_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
	});
Çs		SectionHeader.init([["Name", "Name", "", Go$String, ""], ["Seg", "Seg", "", Go$String, ""], ["Addr", "Addr", "", Go$Uint64, ""], ["Size", "Size", "", Go$Uint64, ""], ["Offset", "Offset", "", Go$Uint32, ""], ["Align", "Align", "", Go$Uint32, ""], ["Reloff", "Reloff", "", Go$Uint32, ""], ["Nreloc", "Nreloc", "", Go$Uint32, ""], ["Flags", "Flags", "", Go$Uint32, ""]]);
0SectionHeader0 0ÇÔSectionÇç	Section = go$pkg.Section = go$newType(0, "Struct", "macho.Section", "Section", "debug/macho", function(SectionHeader_, ReaderAt_, sr_) {
		this.go$val = this;
		this.SectionHeader = SectionHeader_ !== undefined ? SectionHeader_ : new SectionHeader.Ptr();
		this.ReaderAt = ReaderAt_ !== undefined ? ReaderAt_ : null;
		this.sr = sr_ !== undefined ? sr_ : (go$ptrType(io.SectionReader)).nil;
	});
Ç˚		Section.methods = [["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false, 1]];
		(go$ptrType(Section)).methods = [["Data", "", [], [(go$sliceType(Go$Uint8)), go$error], false, -1], ["Open", "", [], [io.ReadSeeker], false, -1], ["ReadAt", "", [(go$sliceType(Go$Uint8)), Go$Int64], [Go$Int, go$error], false, 1]];
		Section.init([["SectionHeader", "", "", SectionHeader, ""], ["ReaderAt", "", "", io.ReaderAt, ""], ["sr", "sr", "debug/macho", (go$ptrType(io.SectionReader)), ""]]);
0	Section0Idebug/macho:SectionHeaderio:ReadSeekerio:ReaderAtio:SectionReader0ÇΩDylibÇ¯	Dylib = go$pkg.Dylib = go$newType(0, "Struct", "macho.Dylib", "Dylib", "debug/macho", function(LoadBytes_, Name_, Time_, CurrentVersion_, CompatVersion_) {
		this.go$val = this;
		this.LoadBytes = LoadBytes_ !== undefined ? LoadBytes_ : LoadBytes.nil;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Time = Time_ !== undefined ? Time_ : 0;
		this.CurrentVersion = CurrentVersion_ !== undefined ? CurrentVersion_ : 0;
		this.CompatVersion = CompatVersion_ !== undefined ? CompatVersion_ : 0;
	});
Çî		Dylib.methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		(go$ptrType(Dylib)).methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		Dylib.init([["LoadBytes", "", "", LoadBytes, ""], ["Name", "Name", "", Go$String, ""], ["Time", "Time", "", Go$Uint32, ""], ["CurrentVersion", "CurrentVersion", "", Go$Uint32, ""], ["CompatVersion", "CompatVersion", "", Go$Uint32, ""]]);
0Dylib0debug/macho:LoadBytes0ÇSymtabÇÇ	Symtab = go$pkg.Symtab = go$newType(0, "Struct", "macho.Symtab", "Symtab", "debug/macho", function(LoadBytes_, SymtabCmd_, Syms_) {
		this.go$val = this;
		this.LoadBytes = LoadBytes_ !== undefined ? LoadBytes_ : LoadBytes.nil;
		this.SymtabCmd = SymtabCmd_ !== undefined ? SymtabCmd_ : new SymtabCmd.Ptr();
		this.Syms = Syms_ !== undefined ? Syms_ : (go$sliceType(Symbol)).nil;
	});
Ç5		Symtab.methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		(go$ptrType(Symtab)).methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		Symtab.init([["LoadBytes", "", "", LoadBytes, ""], ["SymtabCmd", "", "", SymtabCmd, ""], ["Syms", "Syms", "", (go$sliceType(Symbol)), ""]]);
0Symtab0Bdebug/macho:LoadBytesdebug/macho:Symboldebug/macho:SymtabCmd0ÇYDysymtabÇ∑	Dysymtab = go$pkg.Dysymtab = go$newType(0, "Struct", "macho.Dysymtab", "Dysymtab", "debug/macho", function(LoadBytes_, DysymtabCmd_, IndirectSyms_) {
		this.go$val = this;
		this.LoadBytes = LoadBytes_ !== undefined ? LoadBytes_ : LoadBytes.nil;
		this.DysymtabCmd = DysymtabCmd_ !== undefined ? DysymtabCmd_ : new DysymtabCmd.Ptr();
		this.IndirectSyms = IndirectSyms_ !== undefined ? IndirectSyms_ : (go$sliceType(Go$Uint32)).nil;
	});
ÇR		Dysymtab.methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		(go$ptrType(Dysymtab)).methods = [["Raw", "", [], [(go$sliceType(Go$Uint8))], false, 0]];
		Dysymtab.init([["LoadBytes", "", "", LoadBytes, ""], ["DysymtabCmd", "", "", DysymtabCmd, ""], ["IndirectSyms", "IndirectSyms", "", (go$sliceType(Go$Uint32)), ""]]);
0
Dysymtab00debug/macho:DysymtabCmddebug/macho:LoadBytes0Ç_FormatErrorÇ@	FormatError = go$pkg.FormatError = go$newType(0, "Struct", "macho.FormatError", "FormatError", "debug/macho", function(off_, msg_, val_) {
		this.go$val = this;
		this.off = off_ !== undefined ? off_ : new Go$Int64(0, 0);
		this.msg = msg_ !== undefined ? msg_ : "";
		this.val = val_ !== undefined ? val_ : null;
	});
Å˙		(go$ptrType(FormatError)).methods = [["Error", "", [], [Go$String], false, -1]];
		FormatError.init([["off", "off", "debug/macho", Go$Int64, ""], ["msg", "msg", "debug/macho", Go$String, ""], ["val", "val", "debug/macho", go$emptyInterface, ""]]);
0FormatError0 0Çw
FileHeaderÇ	FileHeader = go$pkg.FileHeader = go$newType(0, "Struct", "macho.FileHeader", "FileHeader", "debug/macho", function(Magic_, Cpu_, SubCpu_, Type_, Ncmd_, Cmdsz_, Flags_) {
		this.go$val = this;
		this.Magic = Magic_ !== undefined ? Magic_ : 0;
		this.Cpu = Cpu_ !== undefined ? Cpu_ : 0;
		this.SubCpu = SubCpu_ !== undefined ? SubCpu_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Ncmd = Ncmd_ !== undefined ? Ncmd_ : 0;
		this.Cmdsz = Cmdsz_ !== undefined ? Cmdsz_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
	});
Ç		FileHeader.init([["Magic", "Magic", "", Go$Uint32, ""], ["Cpu", "Cpu", "", Cpu, ""], ["SubCpu", "SubCpu", "", Go$Uint32, ""], ["Type", "Type", "", Type, ""], ["Ncmd", "Ncmd", "", Go$Uint32, ""], ["Cmdsz", "Cmdsz", "", Go$Uint32, ""], ["Flags", "Flags", "", Go$Uint32, ""]]);
0
FileHeader0#debug/macho:Cpudebug/macho:Type0nTypeZ	Type = go$pkg.Type = go$newType(4, "Uint32", "macho.Type", "Type", "debug/macho", null);
 0Type0 0ÇOCpuV	Cpu = go$pkg.Cpu = go$newType(4, "Uint32", "macho.Cpu", "Cpu", "debug/macho", null);
ÅÊ		Cpu.methods = [["GoString", "", [], [Go$String], false, -1], ["String", "", [], [Go$String], false, -1]];
		(go$ptrType(Cpu)).methods = [["GoString", "", [], [Go$String], false, -1], ["String", "", [], [Go$String], false, -1]];
0Cpu0 0ÇoLoadCmdf	LoadCmd = go$pkg.LoadCmd = go$newType(4, "Uint32", "macho.LoadCmd", "LoadCmd", "debug/macho", null);
ÅÓ		LoadCmd.methods = [["GoString", "", [], [Go$String], false, -1], ["String", "", [], [Go$String], false, -1]];
		(go$ptrType(LoadCmd)).methods = [["GoString", "", [], [Go$String], false, -1], ["String", "", [], [Go$String], false, -1]];
0	LoadCmd0 0Ç|	Segment64Ç{	Segment64 = go$pkg.Segment64 = go$newType(0, "Struct", "macho.Segment64", "Segment64", "debug/macho", function(Cmd_, Len_, Name_, Addr_, Memsz_, Offset_, Filesz_, Maxprot_, Prot_, Nsect_, Flag_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Name = Name_ !== undefined ? Name_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Addr = Addr_ !== undefined ? Addr_ : new Go$Uint64(0, 0);
		this.Memsz = Memsz_ !== undefined ? Memsz_ : new Go$Uint64(0, 0);
		this.Offset = Offset_ !== undefined ? Offset_ : new Go$Uint64(0, 0);
		this.Filesz = Filesz_ !== undefined ? Filesz_ : new Go$Uint64(0, 0);
		this.Maxprot = Maxprot_ !== undefined ? Maxprot_ : 0;
		this.Prot = Prot_ !== undefined ? Prot_ : 0;
		this.Nsect = Nsect_ !== undefined ? Nsect_ : 0;
		this.Flag = Flag_ !== undefined ? Flag_ : 0;
	});
Ç 		Segment64.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Name", "Name", "", (go$arrayType(Go$Uint8, 16)), ""], ["Addr", "Addr", "", Go$Uint64, ""], ["Memsz", "Memsz", "", Go$Uint64, ""], ["Offset", "Offset", "", Go$Uint64, ""], ["Filesz", "Filesz", "", Go$Uint64, ""], ["Maxprot", "Maxprot", "", Go$Uint32, ""], ["Prot", "Prot", "", Go$Uint32, ""], ["Nsect", "Nsect", "", Go$Uint32, ""], ["Flag", "Flag", "", Go$Uint32, ""]]);
0	Segment640debug/macho:LoadCmd0Ç4	Segment32Ç3	Segment32 = go$pkg.Segment32 = go$newType(0, "Struct", "macho.Segment32", "Segment32", "debug/macho", function(Cmd_, Len_, Name_, Addr_, Memsz_, Offset_, Filesz_, Maxprot_, Prot_, Nsect_, Flag_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Name = Name_ !== undefined ? Name_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Addr = Addr_ !== undefined ? Addr_ : 0;
		this.Memsz = Memsz_ !== undefined ? Memsz_ : 0;
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Filesz = Filesz_ !== undefined ? Filesz_ : 0;
		this.Maxprot = Maxprot_ !== undefined ? Maxprot_ : 0;
		this.Prot = Prot_ !== undefined ? Prot_ : 0;
		this.Nsect = Nsect_ !== undefined ? Nsect_ : 0;
		this.Flag = Flag_ !== undefined ? Flag_ : 0;
	});
Ç 		Segment32.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Name", "Name", "", (go$arrayType(Go$Uint8, 16)), ""], ["Addr", "Addr", "", Go$Uint32, ""], ["Memsz", "Memsz", "", Go$Uint32, ""], ["Offset", "Offset", "", Go$Uint32, ""], ["Filesz", "Filesz", "", Go$Uint32, ""], ["Maxprot", "Maxprot", "", Go$Uint32, ""], ["Prot", "Prot", "", Go$Uint32, ""], ["Nsect", "Nsect", "", Go$Uint32, ""], ["Flag", "Flag", "", Go$Uint32, ""]]);
0	Segment320debug/macho:LoadCmd0ÇWDylibCmdÇ	DylibCmd = go$pkg.DylibCmd = go$newType(0, "Struct", "macho.DylibCmd", "DylibCmd", "debug/macho", function(Cmd_, Len_, Name_, Time_, CurrentVersion_, CompatVersion_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Name = Name_ !== undefined ? Name_ : 0;
		this.Time = Time_ !== undefined ? Time_ : 0;
		this.CurrentVersion = CurrentVersion_ !== undefined ? CurrentVersion_ : 0;
		this.CompatVersion = CompatVersion_ !== undefined ? CompatVersion_ : 0;
	});
Ç		DylibCmd.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Name", "Name", "", Go$Uint32, ""], ["Time", "Time", "", Go$Uint32, ""], ["CurrentVersion", "CurrentVersion", "", Go$Uint32, ""], ["CompatVersion", "CompatVersion", "", Go$Uint32, ""]]);
0
DylibCmd0debug/macho:LoadCmd0Çú	Section32Çã	Section32 = go$pkg.Section32 = go$newType(0, "Struct", "macho.Section32", "Section32", "debug/macho", function(Name_, Seg_, Addr_, Size_, Offset_, Align_, Reloff_, Nreloc_, Flags_, Reserve1_, Reserve2_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Seg = Seg_ !== undefined ? Seg_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Addr = Addr_ !== undefined ? Addr_ : 0;
		this.Size = Size_ !== undefined ? Size_ : 0;
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Align = Align_ !== undefined ? Align_ : 0;
		this.Reloff = Reloff_ !== undefined ? Reloff_ : 0;
		this.Nreloc = Nreloc_ !== undefined ? Nreloc_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.Reserve1 = Reserve1_ !== undefined ? Reserve1_ : 0;
		this.Reserve2 = Reserve2_ !== undefined ? Reserve2_ : 0;
	});
ÇÔ		Section32.init([["Name", "Name", "", (go$arrayType(Go$Uint8, 16)), ""], ["Seg", "Seg", "", (go$arrayType(Go$Uint8, 16)), ""], ["Addr", "Addr", "", Go$Uint32, ""], ["Size", "Size", "", Go$Uint32, ""], ["Offset", "Offset", "", Go$Uint32, ""], ["Align", "Align", "", Go$Uint32, ""], ["Reloff", "Reloff", "", Go$Uint32, ""], ["Nreloc", "Nreloc", "", Go$Uint32, ""], ["Flags", "Flags", "", Go$Uint32, ""], ["Reserve1", "Reserve1", "", Go$Uint32, ""], ["Reserve2", "Reserve2", "", Go$Uint32, ""]]);
0	Section320 0Ç3	Section64Çı	Section64 = go$pkg.Section64 = go$newType(0, "Struct", "macho.Section64", "Section64", "debug/macho", function(Name_, Seg_, Addr_, Size_, Offset_, Align_, Reloff_, Nreloc_, Flags_, Reserve1_, Reserve2_, Reserve3_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Seg = Seg_ !== undefined ? Seg_ : go$makeNativeArray("Uint8", 16, function() { return 0; });
		this.Addr = Addr_ !== undefined ? Addr_ : new Go$Uint64(0, 0);
		this.Size = Size_ !== undefined ? Size_ : new Go$Uint64(0, 0);
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Align = Align_ !== undefined ? Align_ : 0;
		this.Reloff = Reloff_ !== undefined ? Reloff_ : 0;
		this.Nreloc = Nreloc_ !== undefined ? Nreloc_ : 0;
		this.Flags = Flags_ !== undefined ? Flags_ : 0;
		this.Reserve1 = Reserve1_ !== undefined ? Reserve1_ : 0;
		this.Reserve2 = Reserve2_ !== undefined ? Reserve2_ : 0;
		this.Reserve3 = Reserve3_ !== undefined ? Reserve3_ : 0;
	});
Ç		Section64.init([["Name", "Name", "", (go$arrayType(Go$Uint8, 16)), ""], ["Seg", "Seg", "", (go$arrayType(Go$Uint8, 16)), ""], ["Addr", "Addr", "", Go$Uint64, ""], ["Size", "Size", "", Go$Uint64, ""], ["Offset", "Offset", "", Go$Uint32, ""], ["Align", "Align", "", Go$Uint32, ""], ["Reloff", "Reloff", "", Go$Uint32, ""], ["Nreloc", "Nreloc", "", Go$Uint32, ""], ["Flags", "Flags", "", Go$Uint32, ""], ["Reserve1", "Reserve1", "", Go$Uint32, ""], ["Reserve2", "Reserve2", "", Go$Uint32, ""], ["Reserve3", "Reserve3", "", Go$Uint32, ""]]);
0	Section640 0Ç	SymtabCmdÇÈ	SymtabCmd = go$pkg.SymtabCmd = go$newType(0, "Struct", "macho.SymtabCmd", "SymtabCmd", "debug/macho", function(Cmd_, Len_, Symoff_, Nsyms_, Stroff_, Strsize_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Symoff = Symoff_ !== undefined ? Symoff_ : 0;
		this.Nsyms = Nsyms_ !== undefined ? Nsyms_ : 0;
		this.Stroff = Stroff_ !== undefined ? Stroff_ : 0;
		this.Strsize = Strsize_ !== undefined ? Strsize_ : 0;
	});
Å¸		SymtabCmd.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Symoff", "Symoff", "", Go$Uint32, ""], ["Nsyms", "Nsyms", "", Go$Uint32, ""], ["Stroff", "Stroff", "", Go$Uint32, ""], ["Strsize", "Strsize", "", Go$Uint32, ""]]);
0	SymtabCmd0debug/macho:LoadCmd0Ç
.DysymtabCmdÇA	DysymtabCmd = go$pkg.DysymtabCmd = go$newType(0, "Struct", "macho.DysymtabCmd", "DysymtabCmd", "debug/macho", function(Cmd_, Len_, Ilocalsym_, Nlocalsym_, Iextdefsym_, Nextdefsym_, Iundefsym_, Nundefsym_, Tocoffset_, Ntoc_, Modtaboff_, Nmodtab_, Extrefsymoff_, Nextrefsyms_, Indirectsymoff_, Nindirectsyms_, Extreloff_, Nextrel_, Locreloff_, Nlocrel_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Ilocalsym = Ilocalsym_ !== undefined ? Ilocalsym_ : 0;
		this.Nlocalsym = Nlocalsym_ !== undefined ? Nlocalsym_ : 0;
		this.Iextdefsym = Iextdefsym_ !== undefined ? Iextdefsym_ : 0;
		this.Nextdefsym = Nextdefsym_ !== undefined ? Nextdefsym_ : 0;
		this.Iundefsym = Iundefsym_ !== undefined ? Iundefsym_ : 0;
		this.Nundefsym = Nundefsym_ !== undefined ? Nundefsym_ : 0;
		this.Tocoffset = Tocoffset_ !== undefined ? Tocoffset_ : 0;
		this.Ntoc = Ntoc_ !== undefined ? Ntoc_ : 0;
		this.Modtaboff = Modtaboff_ !== undefined ? Modtaboff_ : 0;
		this.Nmodtab = Nmodtab_ !== undefined ? Nmodtab_ : 0;
		this.Extrefsymoff = Extrefsymoff_ !== undefined ? Extrefsymoff_ : 0;
		this.Nextrefsyms = Nextrefsyms_ !== undefined ? Nextrefsyms_ : 0;
		this.Indirectsymoff = Indirectsymoff_ !== undefined ? Indirectsymoff_ : 0;
		this.Nindirectsyms = Nindirectsyms_ !== undefined ? Nindirectsyms_ : 0;
		this.Extreloff = Extreloff_ !== undefined ? Extreloff_ : 0;
		this.Nextrel = Nextrel_ !== undefined ? Nextrel_ : 0;
		this.Locreloff = Locreloff_ !== undefined ? Locreloff_ : 0;
		this.Nlocrel = Nlocrel_ !== undefined ? Nlocrel_ : 0;
	});
Ç≤		DysymtabCmd.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Ilocalsym", "Ilocalsym", "", Go$Uint32, ""], ["Nlocalsym", "Nlocalsym", "", Go$Uint32, ""], ["Iextdefsym", "Iextdefsym", "", Go$Uint32, ""], ["Nextdefsym", "Nextdefsym", "", Go$Uint32, ""], ["Iundefsym", "Iundefsym", "", Go$Uint32, ""], ["Nundefsym", "Nundefsym", "", Go$Uint32, ""], ["Tocoffset", "Tocoffset", "", Go$Uint32, ""], ["Ntoc", "Ntoc", "", Go$Uint32, ""], ["Modtaboff", "Modtaboff", "", Go$Uint32, ""], ["Nmodtab", "Nmodtab", "", Go$Uint32, ""], ["Extrefsymoff", "Extrefsymoff", "", Go$Uint32, ""], ["Nextrefsyms", "Nextrefsyms", "", Go$Uint32, ""], ["Indirectsymoff", "Indirectsymoff", "", Go$Uint32, ""], ["Nindirectsyms", "Nindirectsyms", "", Go$Uint32, ""], ["Extreloff", "Extreloff", "", Go$Uint32, ""], ["Nextrel", "Nextrel", "", Go$Uint32, ""], ["Locreloff", "Locreloff", "", Go$Uint32, ""], ["Nlocrel", "Nlocrel", "", Go$Uint32, ""]]);
0DysymtabCmd0debug/macho:LoadCmd0ÇNlist32Çó	Nlist32 = go$pkg.Nlist32 = go$newType(0, "Struct", "macho.Nlist32", "Nlist32", "debug/macho", function(Name_, Type_, Sect_, Desc_, Value_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Sect = Sect_ !== undefined ? Sect_ : 0;
		this.Desc = Desc_ !== undefined ? Desc_ : 0;
		this.Value = Value_ !== undefined ? Value_ : 0;
	});
ÅÀ		Nlist32.init([["Name", "Name", "", Go$Uint32, ""], ["Type", "Type", "", Go$Uint8, ""], ["Sect", "Sect", "", Go$Uint8, ""], ["Desc", "Desc", "", Go$Uint16, ""], ["Value", "Value", "", Go$Uint32, ""]]);
0	Nlist320 0ÇëNlist64Ç©	Nlist64 = go$pkg.Nlist64 = go$newType(0, "Struct", "macho.Nlist64", "Nlist64", "debug/macho", function(Name_, Type_, Sect_, Desc_, Value_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Sect = Sect_ !== undefined ? Sect_ : 0;
		this.Desc = Desc_ !== undefined ? Desc_ : 0;
		this.Value = Value_ !== undefined ? Value_ : new Go$Uint64(0, 0);
	});
ÅÀ		Nlist64.init([["Name", "Name", "", Go$Uint32, ""], ["Type", "Type", "", Go$Uint8, ""], ["Sect", "Sect", "", Go$Uint8, ""], ["Desc", "Desc", "", Go$Uint16, ""], ["Value", "Value", "", Go$Uint64, ""]]);
0	Nlist640 0ÇãSymbolÇ¶	Symbol = go$pkg.Symbol = go$newType(0, "Struct", "macho.Symbol", "Symbol", "debug/macho", function(Name_, Type_, Sect_, Desc_, Value_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Sect = Sect_ !== undefined ? Sect_ : 0;
		this.Desc = Desc_ !== undefined ? Desc_ : 0;
		this.Value = Value_ !== undefined ? Value_ : new Go$Uint64(0, 0);
	});
Å 		Symbol.init([["Name", "Name", "", Go$String, ""], ["Type", "Type", "", Go$Uint8, ""], ["Sect", "Sect", "", Go$Uint8, ""], ["Desc", "Desc", "", Go$Uint16, ""], ["Value", "Value", "", Go$Uint64, ""]]);
0Symbol0 0ÇLThreadÇm	Thread = go$pkg.Thread = go$newType(0, "Struct", "macho.Thread", "Thread", "debug/macho", function(Cmd_, Len_, Type_, Data_) {
		this.go$val = this;
		this.Cmd = Cmd_ !== undefined ? Cmd_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Type = Type_ !== undefined ? Type_ : 0;
		this.Data = Data_ !== undefined ? Data_ : (go$sliceType(Go$Uint32)).nil;
	});
ÅØ		Thread.init([["Cmd", "Cmd", "", LoadCmd, ""], ["Len", "Len", "", Go$Uint32, ""], ["Type", "Type", "", Go$Uint32, ""], ["Data", "Data", "", (go$sliceType(Go$Uint32)), ""]]);
0Thread0debug/macho:LoadCmd0Ç∑Regs386Çq	Regs386 = go$pkg.Regs386 = go$newType(0, "Struct", "macho.Regs386", "Regs386", "debug/macho", function(AX_, BX_, CX_, DX_, DI_, SI_, BP_, SP_, SS_, FLAGS_, IP_, CS_, DS_, ES_, FS_, GS_) {
		this.go$val = this;
		this.AX = AX_ !== undefined ? AX_ : 0;
		this.BX = BX_ !== undefined ? BX_ : 0;
		this.CX = CX_ !== undefined ? CX_ : 0;
		this.DX = DX_ !== undefined ? DX_ : 0;
		this.DI = DI_ !== undefined ? DI_ : 0;
		this.SI = SI_ !== undefined ? SI_ : 0;
		this.BP = BP_ !== undefined ? BP_ : 0;
		this.SP = SP_ !== undefined ? SP_ : 0;
		this.SS = SS_ !== undefined ? SS_ : 0;
		this.FLAGS = FLAGS_ !== undefined ? FLAGS_ : 0;
		this.IP = IP_ !== undefined ? IP_ : 0;
		this.CS = CS_ !== undefined ? CS_ : 0;
		this.DS = DS_ !== undefined ? DS_ : 0;
		this.ES = ES_ !== undefined ? ES_ : 0;
		this.FS = FS_ !== undefined ? FS_ : 0;
		this.GS = GS_ !== undefined ? GS_ : 0;
	});
Ç(		Regs386.init([["AX", "AX", "", Go$Uint32, ""], ["BX", "BX", "", Go$Uint32, ""], ["CX", "CX", "", Go$Uint32, ""], ["DX", "DX", "", Go$Uint32, ""], ["DI", "DI", "", Go$Uint32, ""], ["SI", "SI", "", Go$Uint32, ""], ["BP", "BP", "", Go$Uint32, ""], ["SP", "SP", "", Go$Uint32, ""], ["SS", "SS", "", Go$Uint32, ""], ["FLAGS", "FLAGS", "", Go$Uint32, ""], ["IP", "IP", "", Go$Uint32, ""], ["CS", "CS", "", Go$Uint32, ""], ["DS", "DS", "", Go$Uint32, ""], ["ES", "ES", "", Go$Uint32, ""], ["FS", "FS", "", Go$Uint32, ""], ["GS", "GS", "", Go$Uint32, ""]]);
0	Regs3860 0ÇÓ	RegsAMD64ÇÒ	RegsAMD64 = go$pkg.RegsAMD64 = go$newType(0, "Struct", "macho.RegsAMD64", "RegsAMD64", "debug/macho", function(AX_, BX_, CX_, DX_, DI_, SI_, BP_, SP_, R8_, R9_, R10_, R11_, R12_, R13_, R14_, R15_, IP_, FLAGS_, CS_, FS_, GS_) {
		this.go$val = this;
		this.AX = AX_ !== undefined ? AX_ : new Go$Uint64(0, 0);
		this.BX = BX_ !== undefined ? BX_ : new Go$Uint64(0, 0);
		this.CX = CX_ !== undefined ? CX_ : new Go$Uint64(0, 0);
		this.DX = DX_ !== undefined ? DX_ : new Go$Uint64(0, 0);
		this.DI = DI_ !== undefined ? DI_ : new Go$Uint64(0, 0);
		this.SI = SI_ !== undefined ? SI_ : new Go$Uint64(0, 0);
		this.BP = BP_ !== undefined ? BP_ : new Go$Uint64(0, 0);
		this.SP = SP_ !== undefined ? SP_ : new Go$Uint64(0, 0);
		this.R8 = R8_ !== undefined ? R8_ : new Go$Uint64(0, 0);
		this.R9 = R9_ !== undefined ? R9_ : new Go$Uint64(0, 0);
		this.R10 = R10_ !== undefined ? R10_ : new Go$Uint64(0, 0);
		this.R11 = R11_ !== undefined ? R11_ : new Go$Uint64(0, 0);
		this.R12 = R12_ !== undefined ? R12_ : new Go$Uint64(0, 0);
		this.R13 = R13_ !== undefined ? R13_ : new Go$Uint64(0, 0);
		this.R14 = R14_ !== undefined ? R14_ : new Go$Uint64(0, 0);
		this.R15 = R15_ !== undefined ? R15_ : new Go$Uint64(0, 0);
		this.IP = IP_ !== undefined ? IP_ : new Go$Uint64(0, 0);
		this.FLAGS = FLAGS_ !== undefined ? FLAGS_ : new Go$Uint64(0, 0);
		this.CS = CS_ !== undefined ? CS_ : new Go$Uint64(0, 0);
		this.FS = FS_ !== undefined ? FS_ : new Go$Uint64(0, 0);
		this.GS = GS_ !== undefined ? GS_ : new Go$Uint64(0, 0);
	});
Ç€		RegsAMD64.init([["AX", "AX", "", Go$Uint64, ""], ["BX", "BX", "", Go$Uint64, ""], ["CX", "CX", "", Go$Uint64, ""], ["DX", "DX", "", Go$Uint64, ""], ["DI", "DI", "", Go$Uint64, ""], ["SI", "SI", "", Go$Uint64, ""], ["BP", "BP", "", Go$Uint64, ""], ["SP", "SP", "", Go$Uint64, ""], ["R8", "R8", "", Go$Uint64, ""], ["R9", "R9", "", Go$Uint64, ""], ["R10", "R10", "", Go$Uint64, ""], ["R11", "R11", "", Go$Uint64, ""], ["R12", "R12", "", Go$Uint64, ""], ["R13", "R13", "", Go$Uint64, ""], ["R14", "R14", "", Go$Uint64, ""], ["R15", "R15", "", Go$Uint64, ""], ["IP", "IP", "", Go$Uint64, ""], ["FLAGS", "FLAGS", "", Go$Uint64, ""], ["CS", "CS", "", Go$Uint64, ""], ["FS", "FS", "", Go$Uint64, ""], ["GS", "GS", "", Go$Uint64, ""]]);
0	RegsAMD640 0Ç[intNameÅ⁄	intName = go$pkg.intName = go$newType(0, "Struct", "macho.intName", "intName", "debug/macho", function(i_, s_) {
		this.go$val = this;
		this.i = i_ !== undefined ? i_ : 0;
		this.s = s_ !== undefined ? s_ : "";
	});
f		intName.init([["i", "i", "debug/macho", Go$Uint32, ""], ["s", "s", "debug/macho", Go$String, ""]]);
0	intName0 0Ç Å	LoadBytes.prototype.Raw = function() {
		var b;
		b = this;
		return go$subslice(new (go$sliceType(Go$Uint8))(b.array), b.offset, b.offset + b.length);
	};
	go$ptrType(LoadBytes).prototype.Raw = function() { return this.go$get().Raw(); };
 0	LoadBytes0debug/macho:LoadBytes0Ç† Çv	Segment.Ptr.prototype.Data = function() {
		var s, dat, _tuple, n, err;
		s = this;
		dat = (go$sliceType(Go$Uint8)).make(go$flatten64(s.sr.Size()), 0, function() { return 0; });
		_tuple = s.sr.ReadAt(dat, new Go$Int64(0, 0)), n = _tuple[0], err = _tuple[1];
		return [go$subslice(dat, 0, n), err];
	};
	Segment.prototype.Data = function() { return this.go$val.Data(); };
 0	Segment0debug/macho:Segment0Ç% ÅÁ	Segment.Ptr.prototype.Open = function() {
		var s;
		s = this;
		return io.NewSectionReader(s.sr, new Go$Int64(0, 0), new Go$Int64(2147483647, 4294967295));
	};
	Segment.prototype.Open = function() { return this.go$val.Open(); };
 0	Segment0*debug/macho:Segmentio:NewSectionReader0Ç† Çv	Section.Ptr.prototype.Data = function() {
		var s, dat, _tuple, n, err;
		s = this;
		dat = (go$sliceType(Go$Uint8)).make(go$flatten64(s.sr.Size()), 0, function() { return 0; });
		_tuple = s.sr.ReadAt(dat, new Go$Int64(0, 0)), n = _tuple[0], err = _tuple[1];
		return [go$subslice(dat, 0, n), err];
	};
	Section.prototype.Data = function() { return this.go$val.Data(); };
 0	Section0debug/macho:Section0Ç% ÅÁ	Section.Ptr.prototype.Open = function() {
		var s;
		s = this;
		return io.NewSectionReader(s.sr, new Go$Int64(0, 0), new Go$Int64(2147483647, 4294967295));
	};
	Section.prototype.Open = function() { return this.go$val.Open(); };
 0	Section0*debug/macho:Sectionio:NewSectionReader0Ç‰ Ç•	FormatError.Ptr.prototype.Error = function() {
		var e, msg;
		e = this;
		msg = e.msg;
		if (!(go$interfaceIsEqual(e.val, null))) {
			msg = msg + (fmt.Sprintf(" '%v'", new (go$sliceType(go$emptyInterface))([e.val])));
		}
		msg = msg + (fmt.Sprintf(" in record at byte %#x", new (go$sliceType(go$emptyInterface))([e.off])));
		return msg;
	};
	FormatError.prototype.Error = function() { return this.go$val.Error(); };
 0FormatError0&debug/macho:FormatErrorfmt:Sprintf0ÇÒOpenÇ´	Open = go$pkg.Open = function(name) {
		var _tuple, f, err, _tuple$1, ff;
		_tuple = os.Open(name), f = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(File)).nil, err];
		}
		_tuple$1 = NewFile(f), ff = _tuple$1[0], err = _tuple$1[1];
		if (!(go$interfaceIsEqual(err, null))) {
			f.Close();
			return [(go$ptrType(File)).nil, err];
		}
		ff.closer = f;
		return [ff, null];
	};
 0Open00debug/macho:Filedebug/macho:NewFileos:Open0Ç. Ç
	File.Ptr.prototype.Close = function() {
		var f, err;
		f = this;
		err = null;
		if (!(go$interfaceIsEqual(f.closer, null))) {
			err = f.closer.Close();
			f.closer = null;
		}
		return err;
	};
	File.prototype.Close = function() { return this.go$val.Close(); };
 0File0debug/macho:File0Ç.NewFileÇ+‚	NewFile = go$pkg.NewFile = function(r) {
		var f, sr, ident, err, _tuple, be, le, _ref, x, x$1, err$1, offset, dat, err$2, _tuple$1, bo, _ref$1, _i, i, _tuple$2, cmd, siz, cmddat, _tuple$3, x$2, s, _ref$2, hdr, b, err$3, l, _slice, _index, hdr$1, b$1, err$4, strtab, err$5, _tuple$4, symsz, x$3, symdat, err$6, _tuple$5, _tuple$6, st, err$7, _slice$1, _index$1, hdr$2, b$2, err$8, x$4, x$5, dat$1, err$9, _tuple$7, x$6, err$10, st$1, _struct, _slice$2, _index$2, seg32, b$3, err$11, _slice$3, _index$3, i$1, sh32, err$12, sh, seg64, b$4, err$13, _slice$4, _index$4, i$2, sh64, err$14, sh$1, _slice$5, _index$5, x$7, x$8;
		f = new File.Ptr();
		sr = io.NewSectionReader(r, new Go$Int64(0, 0), new Go$Int64(2147483647, 4294967295));
		ident = go$makeNativeArray("Uint8", 4, function() { return 0; });
		if (_tuple = r.ReadAt(go$subslice(new (go$sliceType(Go$Uint8))(ident), 0), new Go$Int64(0, 0)), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			return [(go$ptrType(File)).nil, err];
		}
		be = binary.BigEndian.Uint32(go$subslice(new (go$sliceType(Go$Uint8))(ident), 0));
		le = binary.LittleEndian.Uint32(go$subslice(new (go$sliceType(Go$Uint8))(ident), 0));
		_ref = 4277009102;
		if (_ref === (be & ~1)) {
			f.ByteOrder = (x = binary.BigEndian, new x.constructor.Struct(x));
			f.FileHeader.Magic = be;
		} else if (_ref === (le & ~1)) {
			f.ByteOrder = (x$1 = binary.LittleEndian, new x$1.constructor.Struct(x$1));
			f.FileHeader.Magic = le;
		} else {
			return [(go$ptrType(File)).nil, new FormatError.Ptr(new Go$Int64(0, 0), "invalid magic number", null)];
		}
		if (err$1 = binary.Read(sr, f.ByteOrder, f.FileHeader), !(go$interfaceIsEqual(err$1, null))) {
			return [(go$ptrType(File)).nil, err$1];
		}
		offset = new Go$Int64(0, 28);
		if (f.FileHeader.Magic === 4277009103) {
			offset = new Go$Int64(0, 32);
		}
		dat = (go$sliceType(Go$Uint8)).make(f.FileHeader.Cmdsz, 0, function() { return 0; });
		if (_tuple$1 = r.ReadAt(dat, offset), err$2 = _tuple$1[1], !(go$interfaceIsEqual(err$2, null))) {
			return [(go$ptrType(File)).nil, err$2];
		}
		f.Loads = (go$sliceType(Load)).make(f.FileHeader.Ncmd, 0, function() { return null; });
		bo = f.ByteOrder;
		_ref$1 = f.Loads;
		_i = 0;
		while (_i < _ref$1.length) {
			i = _i;
			if (dat.length < 8) {
				return [(go$ptrType(File)).nil, new FormatError.Ptr(offset, "command block too small", null)];
			}
			_tuple$2 = [(bo.Uint32(go$subslice(dat, 0, 4)) >>> 0), bo.Uint32(go$subslice(dat, 4, 8))], cmd = _tuple$2[0], siz = _tuple$2[1];
			if (siz < 8 || siz > (dat.length >>> 0)) {
				return [(go$ptrType(File)).nil, new FormatError.Ptr(offset, "invalid command block size", null)];
			}
			cmddat = (go$sliceType(Go$Uint8)).nil;
			_tuple$3 = [go$subslice(dat, 0, siz), go$subslice(dat, siz)], cmddat = _tuple$3[0], dat = _tuple$3[1];
			offset = (x$2 = new Go$Int64(0, siz), new Go$Int64(offset.high + x$2.high, offset.low + x$2.low));
			s = (go$ptrType(Segment)).nil;
			_ref$2 = cmd;
			if (_ref$2 === 12) {
				hdr = new DylibCmd.Ptr();
				b = bytes.NewBuffer(cmddat);
				if (err$3 = binary.Read(b, bo, hdr), !(go$interfaceIsEqual(err$3, null))) {
					return [(go$ptrType(File)).nil, err$3];
				}
				l = new Dylib.Ptr();
				if (hdr.Name >= (cmddat.length >>> 0)) {
					return [(go$ptrType(File)).nil, new FormatError.Ptr(offset, "invalid name in dynamic library command", new Go$Uint32(hdr.Name))];
				}
				l.Name = cstring(go$subslice(cmddat, hdr.Name));
				l.Time = hdr.Time;
				l.CurrentVersion = hdr.CurrentVersion;
				l.CompatVersion = hdr.CompatVersion;
				l.LoadBytes = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length);
				_slice = f.Loads, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = l) : go$throwRuntimeError("index out of range");
			} else if (_ref$2 === 2) {
				hdr$1 = new SymtabCmd.Ptr();
				b$1 = bytes.NewBuffer(cmddat);
				if (err$4 = binary.Read(b$1, bo, hdr$1), !(go$interfaceIsEqual(err$4, null))) {
					return [(go$ptrType(File)).nil, err$4];
				}
				strtab = (go$sliceType(Go$Uint8)).make(hdr$1.Strsize, 0, function() { return 0; });
				if (_tuple$4 = r.ReadAt(strtab, new Go$Int64(0, hdr$1.Stroff)), err$5 = _tuple$4[1], !(go$interfaceIsEqual(err$5, null))) {
					return [(go$ptrType(File)).nil, err$5];
				}
				symsz = 0;
				if (f.FileHeader.Magic === 4277009103) {
					symsz = 16;
				} else {
					symsz = 12;
				}
				symdat = (go$sliceType(Go$Uint8)).make((x$3 = (hdr$1.Nsyms >> 0), (((x$3 >>> 16 << 16) * symsz >> 0) + (x$3 << 16 >>> 16) * symsz) >> 0), 0, function() { return 0; });
				if (_tuple$5 = r.ReadAt(symdat, new Go$Int64(0, hdr$1.Symoff)), err$6 = _tuple$5[1], !(go$interfaceIsEqual(err$6, null))) {
					return [(go$ptrType(File)).nil, err$6];
				}
				_tuple$6 = f.parseSymtab(symdat, strtab, cmddat, hdr$1, offset), st = _tuple$6[0], err$7 = _tuple$6[1];
				if (!(go$interfaceIsEqual(err$7, null))) {
					return [(go$ptrType(File)).nil, err$7];
				}
				_slice$1 = f.Loads, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = st) : go$throwRuntimeError("index out of range");
				f.Symtab = st;
			} else if (_ref$2 === 11) {
				hdr$2 = new DysymtabCmd.Ptr();
				b$2 = bytes.NewBuffer(cmddat);
				if (err$8 = binary.Read(b$2, bo, hdr$2), !(go$interfaceIsEqual(err$8, null))) {
					return [(go$ptrType(File)).nil, err$8];
				}
				dat$1 = (go$sliceType(Go$Uint8)).make((x$4 = hdr$2.Nindirectsyms, x$5 = 4, (((x$4 >>> 16 << 16) * x$5 >>> 0) + (x$4 << 16 >>> 16) * x$5) >>> 0), 0, function() { return 0; });
				if (_tuple$7 = r.ReadAt(dat$1, new Go$Int64(0, hdr$2.Indirectsymoff)), err$9 = _tuple$7[1], !(go$interfaceIsEqual(err$9, null))) {
					return [(go$ptrType(File)).nil, err$9];
				}
				x$6 = (go$sliceType(Go$Uint32)).make(hdr$2.Nindirectsyms, 0, function() { return 0; });
				if (err$10 = binary.Read(bytes.NewBuffer(dat$1), bo, x$6), !(go$interfaceIsEqual(err$10, null))) {
					return [(go$ptrType(File)).nil, err$10];
				}
				st$1 = new Dysymtab.Ptr();
				st$1.LoadBytes = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length);
				st$1.DysymtabCmd = (_struct = hdr$2, new DysymtabCmd.Ptr(_struct.Cmd, _struct.Len, _struct.Ilocalsym, _struct.Nlocalsym, _struct.Iextdefsym, _struct.Nextdefsym, _struct.Iundefsym, _struct.Nundefsym, _struct.Tocoffset, _struct.Ntoc, _struct.Modtaboff, _struct.Nmodtab, _struct.Extrefsymoff, _struct.Nextrefsyms, _struct.Indirectsymoff, _struct.Nindirectsyms, _struct.Extreloff, _struct.Nextrel, _struct.Locreloff, _struct.Nlocrel));
				st$1.IndirectSyms = x$6;
				_slice$2 = f.Loads, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = st$1) : go$throwRuntimeError("index out of range");
				f.Dysymtab = st$1;
			} else if (_ref$2 === 1) {
				seg32 = new Segment32.Ptr();
				b$3 = bytes.NewBuffer(cmddat);
				if (err$11 = binary.Read(b$3, bo, seg32), !(go$interfaceIsEqual(err$11, null))) {
					return [(go$ptrType(File)).nil, err$11];
				}
				s = new Segment.Ptr();
				s.LoadBytes = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length);
				s.SegmentHeader.Cmd = cmd;
				s.SegmentHeader.Len = siz;
				s.SegmentHeader.Name = cstring(go$subslice(new (go$sliceType(Go$Uint8))(seg32.Name), 0));
				s.SegmentHeader.Addr = new Go$Uint64(0, seg32.Addr);
				s.SegmentHeader.Memsz = new Go$Uint64(0, seg32.Memsz);
				s.SegmentHeader.Offset = new Go$Uint64(0, seg32.Offset);
				s.SegmentHeader.Filesz = new Go$Uint64(0, seg32.Filesz);
				s.SegmentHeader.Maxprot = seg32.Maxprot;
				s.SegmentHeader.Prot = seg32.Prot;
				s.SegmentHeader.Nsect = seg32.Nsect;
				s.SegmentHeader.Flag = seg32.Flag;
				_slice$3 = f.Loads, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = s) : go$throwRuntimeError("index out of range");
				i$1 = 0;
				while (i$1 < (s.SegmentHeader.Nsect >> 0)) {
					sh32 = new Section32.Ptr();
					if (err$12 = binary.Read(b$3, bo, sh32), !(go$interfaceIsEqual(err$12, null))) {
						return [(go$ptrType(File)).nil, err$12];
					}
					sh = new Section.Ptr();
					sh.SectionHeader.Name = cstring(go$subslice(new (go$sliceType(Go$Uint8))(sh32.Name), 0));
					sh.SectionHeader.Seg = cstring(go$subslice(new (go$sliceType(Go$Uint8))(sh32.Seg), 0));
					sh.SectionHeader.Addr = new Go$Uint64(0, sh32.Addr);
					sh.SectionHeader.Size = new Go$Uint64(0, sh32.Size);
					sh.SectionHeader.Offset = sh32.Offset;
					sh.SectionHeader.Align = sh32.Align;
					sh.SectionHeader.Reloff = sh32.Reloff;
					sh.SectionHeader.Nreloc = sh32.Nreloc;
					sh.SectionHeader.Flags = sh32.Flags;
					f.pushSection(sh, r);
					i$1 = i$1 + 1 >> 0;
				}
			} else if (_ref$2 === 25) {
				seg64 = new Segment64.Ptr();
				b$4 = bytes.NewBuffer(cmddat);
				if (err$13 = binary.Read(b$4, bo, seg64), !(go$interfaceIsEqual(err$13, null))) {
					return [(go$ptrType(File)).nil, err$13];
				}
				s = new Segment.Ptr();
				s.LoadBytes = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length);
				s.SegmentHeader.Cmd = cmd;
				s.SegmentHeader.Len = siz;
				s.SegmentHeader.Name = cstring(go$subslice(new (go$sliceType(Go$Uint8))(seg64.Name), 0));
				s.SegmentHeader.Addr = seg64.Addr;
				s.SegmentHeader.Memsz = seg64.Memsz;
				s.SegmentHeader.Offset = seg64.Offset;
				s.SegmentHeader.Filesz = seg64.Filesz;
				s.SegmentHeader.Maxprot = seg64.Maxprot;
				s.SegmentHeader.Prot = seg64.Prot;
				s.SegmentHeader.Nsect = seg64.Nsect;
				s.SegmentHeader.Flag = seg64.Flag;
				_slice$4 = f.Loads, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = s) : go$throwRuntimeError("index out of range");
				i$2 = 0;
				while (i$2 < (s.SegmentHeader.Nsect >> 0)) {
					sh64 = new Section64.Ptr();
					if (err$14 = binary.Read(b$4, bo, sh64), !(go$interfaceIsEqual(err$14, null))) {
						return [(go$ptrType(File)).nil, err$14];
					}
					sh$1 = new Section.Ptr();
					sh$1.SectionHeader.Name = cstring(go$subslice(new (go$sliceType(Go$Uint8))(sh64.Name), 0));
					sh$1.SectionHeader.Seg = cstring(go$subslice(new (go$sliceType(Go$Uint8))(sh64.Seg), 0));
					sh$1.SectionHeader.Addr = sh64.Addr;
					sh$1.SectionHeader.Size = sh64.Size;
					sh$1.SectionHeader.Offset = sh64.Offset;
					sh$1.SectionHeader.Align = sh64.Align;
					sh$1.SectionHeader.Reloff = sh64.Reloff;
					sh$1.SectionHeader.Nreloc = sh64.Nreloc;
					sh$1.SectionHeader.Flags = sh64.Flags;
					f.pushSection(sh$1, r);
					i$2 = i$2 + 1 >> 0;
				}
			} else {
				_slice$5 = f.Loads, _index$5 = i, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length)) : go$throwRuntimeError("index out of range");
			}
			if (!(s === (go$ptrType(Segment)).nil)) {
				s.sr = io.NewSectionReader(r, (x$7 = s.SegmentHeader.Offset, new Go$Int64(x$7.high, x$7.low)), (x$8 = s.SegmentHeader.Filesz, new Go$Int64(x$8.high, x$8.low)));
				s.ReaderAt = s.sr;
			}
			_i++;
		}
		return [f, null];
	};
 0	NewFile0Çbytes:NewBufferdebug/macho:Dylibdebug/macho:DylibCmddebug/macho:Dysymtabdebug/macho:DysymtabCmddebug/macho:Filedebug/macho:FormatErrordebug/macho:Loaddebug/macho:LoadBytesdebug/macho:Sectiondebug/macho:Section32debug/macho:Section64debug/macho:Segmentdebug/macho:Segment32debug/macho:Segment64debug/macho:SymtabCmddebug/macho:cstringdebug/macho:parseSymtabdebug/macho:pushSectionencoding/binary:BigEndianencoding/binary:LittleEndianencoding/binary:Readio:NewSectionReader0Ç° Ç±	File.Ptr.prototype.parseSymtab = function(symdat, strtab, cmddat, hdr, offset) {
		var f, bo, symtab, b, _ref, _i, i, n, err, n32, err$1, _slice, _index, sym, st;
		f = this;
		bo = f.ByteOrder;
		symtab = (go$sliceType(Symbol)).make(hdr.Nsyms, 0, function() { return new Symbol.Ptr(); });
		b = bytes.NewBuffer(symdat);
		_ref = symtab;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			n = new Nlist64.Ptr();
			if (f.FileHeader.Magic === 4277009103) {
				if (err = binary.Read(b, bo, n), !(go$interfaceIsEqual(err, null))) {
					return [(go$ptrType(Symtab)).nil, err];
				}
			} else {
				n32 = new Nlist32.Ptr();
				if (err$1 = binary.Read(b, bo, n32), !(go$interfaceIsEqual(err$1, null))) {
					return [(go$ptrType(Symtab)).nil, err$1];
				}
				n.Name = n32.Name;
				n.Type = n32.Type;
				n.Sect = n32.Sect;
				n.Desc = n32.Desc;
				n.Value = new Go$Uint64(0, n32.Value);
			}
			sym = (_slice = symtab, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (n.Name >= (strtab.length >>> 0)) {
				return [(go$ptrType(Symtab)).nil, new FormatError.Ptr(offset, "invalid name in symbol table", new Go$Uint32(n.Name))];
			}
			sym.Name = cstring(go$subslice(strtab, n.Name));
			sym.Type = n.Type;
			sym.Sect = n.Sect;
			sym.Desc = n.Desc;
			sym.Value = n.Value;
			_i++;
		}
		st = new Symtab.Ptr();
		st.LoadBytes = go$subslice(new LoadBytes(cmddat.array), cmddat.offset, cmddat.offset + cmddat.length);
		st.Syms = symtab;
		return [st, null];
	};
	File.prototype.parseSymtab = function(symdat, strtab, cmddat, hdr, offset) { return this.go$val.parseSymtab(symdat, strtab, cmddat, hdr, offset); };
 0FileparseSymtab0Å–bytes:NewBufferdebug/macho:Filedebug/macho:FormatErrordebug/macho:LoadBytesdebug/macho:Nlist32debug/macho:Nlist64debug/macho:Symboldebug/macho:Symtabdebug/macho:cstringencoding/binary:Read0Ç∑ Çq	File.Ptr.prototype.pushSection = function(sh, r) {
		var f, x;
		f = this;
		f.Sections = go$append(f.Sections, sh);
		sh.sr = io.NewSectionReader(r, new Go$Int64(0, sh.SectionHeader.Offset), (x = sh.SectionHeader.Size, new Go$Int64(x.high, x.low)));
		sh.ReaderAt = sh.sr;
	};
	File.prototype.pushSection = function(sh, r) { return this.go$val.pushSection(sh, r); };
 0FilepushSection0'debug/macho:Fileio:NewSectionReader0ÇicstringÇM	cstring = function(b) {
		var i, _slice, _index;
		i = 0;
		i = 0;
		while (i < b.length && !(((_slice = b, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 0))) {
			i = i + 1 >> 0;
		}
		return go$bytesToString(go$subslice(b, 0, i));
	};
 0	cstring0 0Ç„ Ç™	File.Ptr.prototype.Segment = function(name) {
		var f, _ref, _i, _slice, _index, l, ok, s, _tuple;
		f = this;
		_ref = f.Loads;
		_i = 0;
		while (_i < _ref.length) {
			l = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (_tuple = (l !== null && l.constructor === (go$ptrType(Segment)) ? [l.go$val, true] : [(go$ptrType(Segment)).nil, false]), s = _tuple[0], ok = _tuple[1], ok && s.SegmentHeader.Name === name) {
				return s;
			}
			_i++;
		}
		return (go$ptrType(Segment)).nil;
	};
	File.prototype.Segment = function(name) { return this.go$val.Segment(name); };
 0File0'debug/macho:Filedebug/macho:Segment0Ç8 Çˇ	File.Ptr.prototype.Section = function(name) {
		var f, _ref, _i, _slice, _index, s;
		f = this;
		_ref = f.Sections;
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (s.SectionHeader.Name === name) {
				return s;
			}
			_i++;
		}
		return (go$ptrType(Section)).nil;
	};
	File.prototype.Section = function(name) { return this.go$val.Section(name); };
 0File0'debug/macho:Filedebug/macho:Section0ÇA ÇŸ	File.Ptr.prototype.DWARF = function() {
		var f, names, dat, _ref, _i, name, i, s, _tuple, b, err, x, x$1, _tuple$1, abbrev, info, str;
		f = this;
		names = go$toNativeArray("String", ["abbrev", "info", "str"]);
		dat = go$makeNativeArray("Slice", 3, function() { return (go$sliceType(Go$Uint8)).nil; });
		_ref = names;
		_i = 0;
		while (_i < 3) {
			name = _ref[_i];
			i = _i;
			name = "__debug_" + name;
			s = f.Section(name);
			if (s === (go$ptrType(Section)).nil) {
				return [(go$ptrType(dwarf.Data)).nil, errors.New("missing Mach-O section " + name)];
			}
			_tuple = s.Data(), b = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null)) && (x = new Go$Uint64(0, b.length), x$1 = s.SectionHeader.Size, (x.high < x$1.high || (x.high === x$1.high && x.low < x$1.low)))) {
				return [(go$ptrType(dwarf.Data)).nil, err];
			}
			dat[i] = b;
			_i++;
		}
		_tuple$1 = [dat[0], dat[1], dat[2]], abbrev = _tuple$1[0], info = _tuple$1[1], str = _tuple$1[2];
		return dwarf.New(abbrev, (go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, info, (go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, (go$sliceType(Go$Uint8)).nil, str);
	};
	File.prototype.DWARF = function() { return this.go$val.DWARF(); };
 0File0Vdebug/dwarf:Datadebug/dwarf:Newdebug/macho:Filedebug/macho:Section
errors:New0ÇU Ç⁄	File.Ptr.prototype.ImportedSymbols = function() {
		var f, st, dt, all, _ref, _i, _slice, _index, _struct, s;
		f = this;
		if (f.Dysymtab === (go$ptrType(Dysymtab)).nil || f.Symtab === (go$ptrType(Symtab)).nil) {
			return [(go$sliceType(Go$String)).nil, new FormatError.Ptr(new Go$Int64(0, 0), "missing symbol table", null)];
		}
		st = f.Symtab;
		dt = f.Dysymtab;
		all = (go$sliceType(Go$String)).nil;
		_ref = go$subslice(st.Syms, dt.DysymtabCmd.Iundefsym, (dt.DysymtabCmd.Iundefsym + dt.DysymtabCmd.Nundefsym >>> 0));
		_i = 0;
		while (_i < _ref.length) {
			s = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Symbol.Ptr(_struct.Name, _struct.Type, _struct.Sect, _struct.Desc, _struct.Value));
			all = go$append(all, s.Name);
			_i++;
		}
		return [all, null];
	};
	File.prototype.ImportedSymbols = function() { return this.go$val.ImportedSymbols(); };
 0File0idebug/macho:Dysymtabdebug/macho:Filedebug/macho:FormatErrordebug/macho:Symboldebug/macho:Symtab0Ç Çœ	File.Ptr.prototype.ImportedLibraries = function() {
		var f, all, _ref, _i, _slice, _index, l, ok, _tuple, lib;
		f = this;
		all = (go$sliceType(Go$String)).nil;
		_ref = f.Loads;
		_i = 0;
		while (_i < _ref.length) {
			l = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (_tuple = (l !== null && l.constructor === (go$ptrType(Dylib)) ? [l.go$val, true] : [(go$ptrType(Dylib)).nil, false]), lib = _tuple[0], ok = _tuple[1], ok) {
				all = go$append(all, lib.Name);
			}
			_i++;
		}
		return [all, null];
	};
	File.prototype.ImportedLibraries = function() { return this.go$val.ImportedLibraries(); };
 0File0%debug/macho:Dylibdebug/macho:File0Ç% Å‘	Cpu.prototype.String = function() {
		var i;
		i = this.go$val;
		return stringName((i >>> 0), cpuStrings, false);
	};
	go$ptrType(Cpu).prototype.String = function() { return new Cpu(this.go$get()).String(); };
 0Cpu0Adebug/macho:Cpudebug/macho:cpuStringsdebug/macho:stringName0Ç* ÅŸ	Cpu.prototype.GoString = function() {
		var i;
		i = this.go$val;
		return stringName((i >>> 0), cpuStrings, true);
	};
	go$ptrType(Cpu).prototype.GoString = function() { return new Cpu(this.go$get()).GoString(); };
 0Cpu0Adebug/macho:Cpudebug/macho:cpuStringsdebug/macho:stringName0Ç9 Å‡	LoadCmd.prototype.String = function() {
		var i;
		i = this.go$val;
		return stringName((i >>> 0), cmdStrings, false);
	};
	go$ptrType(LoadCmd).prototype.String = function() { return new LoadCmd(this.go$get()).String(); };
 0	LoadCmd0Edebug/macho:LoadCmddebug/macho:cmdStringsdebug/macho:stringName0Ç> ÅÂ	LoadCmd.prototype.GoString = function() {
		var i;
		i = this.go$val;
		return stringName((i >>> 0), cmdStrings, true);
	};
	go$ptrType(LoadCmd).prototype.GoString = function() { return new LoadCmd(this.go$get()).GoString(); };
 0	LoadCmd0Edebug/macho:LoadCmddebug/macho:cmdStringsdebug/macho:stringName0ÇV
stringNameÇ	stringName = function(i, names, goSyntax) {
		var _ref, _i, _slice, _index, _struct, n;
		_ref = names;
		_i = 0;
		while (_i < _ref.length) {
			n = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new intName.Ptr(_struct.i, _struct.s));
			if (n.i === i) {
				if (goSyntax) {
					return "macho." + n.s;
				}
				return n.s;
			}
			_i++;
		}
		return strconv.FormatUint(new Go$Uint64(0, i), 10);
	};
 0
stringName0)debug/macho:intNamestrconv:FormatUint0Ç@flagNameÇ˘	flagName = function(i, names, goSyntax) {
		var s, _ref, _i, _slice, _index, _struct, n;
		s = "";
		_ref = names;
		_i = 0;
		while (_i < _ref.length) {
			n = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new intName.Ptr(_struct.i, _struct.s));
			if (((n.i & i) >>> 0) === n.i) {
				if (s.length > 0) {
					s = s + "+";
				}
				if (goSyntax) {
					s = s + "macho.";
				}
				s = s + (n.s);
				i = i - (n.i) >>> 0;
			}
			_i++;
		}
		if (s.length === 0) {
			return "0x" + strconv.FormatUint(new Go$Uint64(0, i), 16);
		}
		if (!((i === 0))) {
			s = s + ("+0x" + strconv.FormatUint(new Go$Uint64(0, i), 16));
		}
		return s;
	};
 0
flagName0)debug/macho:intNamestrconv:FormatUint0 
cpuStrings  0
cpuStrings0 0 
cmdStrings  0
cmdStrings0 0Å∂  s		cpuStrings = new (go$sliceType(intName))([new intName.Ptr(7, "Cpu386"), new intName.Ptr(16777223, "CpuAmd64")]);
0
cpuStrings0-debug/macho:cpuStringsdebug/macho:intName0Ç4  Å		cmdStrings = new (go$sliceType(intName))([new intName.Ptr(1, "LoadCmdSegment"), new intName.Ptr(4, "LoadCmdThread"), new intName.Ptr(5, "LoadCmdUnixThread"), new intName.Ptr(12, "LoadCmdDylib"), new intName.Ptr(25, "LoadCmdSegment64")]);
0
cmdStrings0-debug/macho:cmdStringsdebug/macho:intName0
   0 0 0
   0 0 0 