0Éñ¿reflectÇE&package reflect
import strconv "strconv"
import sync "sync"
import math "math"
import runtime "runtime"
func @"".Append(@"".s @"".Value, @"".x ...@"".Value) (? @"".Value)
func @"".AppendSlice(@"".s @"".Value, @"".t @"".Value) (? @"".Value)
const @"".Array @"".Kind = 0x11
const @"".Bool @"".Kind = 0x1
const @"".BothDir @"".ChanDir = 0x3
const @"".Chan @"".Kind = 0x12
type @"".ChanDir int
func (? @"".ChanDir) @"".String() (? string)
func (? *@"".ChanDir) @"".String() (? string)
func @"".ChanOf(@"".dir @"".ChanDir, @"".t @"".Type) (? @"".Type)
const @"".Complex128 @"".Kind = 0x10
const @"".Complex64 @"".Kind = 0xf
func @"".Copy(@"".dst @"".Value, @"".src @"".Value) (? int)
func @"".DeepEqual(@"".a1 interface {  }, @"".a2 interface {  }) (? bool)
const @"".Float32 @"".Kind = 0xd
const @"".Float64 @"".Kind = 0xe
const @"".Func @"".Kind = 0x13
func @"".Indirect(@"".v @"".Value) (? @"".Value)
const @"".Int @"".Kind = 0x2
const @"".Int16 @"".Kind = 0x4
const @"".Int32 @"".Kind = 0x5
const @"".Int64 @"".Kind = 0x6
const @"".Int8 @"".Kind = 0x3
const @"".Interface @"".Kind = 0x14
const @"".Invalid @"".Kind = 0x0
type @"".Kind uint
func (? @"".Kind) @"".String() (? string)
func (? *@"".Kind) @"".String() (? string)
func @"".MakeChan(@"".typ @"".Type, @"".buffer int) (? @"".Value)
func @"".MakeFunc(@"".typ @"".Type, @"".fn func (@"".args []@"".Value) (@"".results []@"".Value)) (? @"".Value)
func @"".MakeMap(@"".typ @"".Type) (? @"".Value)
func @"".MakeSlice(@"".typ @"".Type, @"".len int, @"".cap int) (? @"".Value)
const @"".Map @"".Kind = 0x15
func @"".MapOf(@"".key @"".Type, @"".elem @"".Type) (? @"".Type)
type @"".Method struct { @"".Name string; @"".PkgPath string; @"".Type @"".Type; @"".Func @"".Value; @"".Index int }
func @"".New(@"".typ @"".Type) (? @"".Value)
func @"".NewAt(@"".typ @"".Type, @"".p @"unsafe".Pointer) (? @"".Value)
const @"".Ptr @"".Kind = 0x16
func @"".PtrTo(@"".t @"".Type) (? @"".Type)
const @"".RecvDir @"".ChanDir = 0x1
func @"".Select(@"".cases []@"".SelectCase) (@"".chosen int, @"".recv @"".Value, @"".recvOK bool)
type @"".SelectCase struct { @"".Dir @"".SelectDir; @"".Chan @"".Value; @"".Send @"".Value }
const @"".SelectDefault @"".SelectDir = 0x3
type @"".SelectDir int
const @"".SelectRecv @"".SelectDir = 0x2
const @"".SelectSend @"".SelectDir = 0x1
const @"".SendDir @"".ChanDir = 0x2
const @"".Slice @"".Kind = 0x17
type @"".SliceHeader struct { @"".Data uintptr; @"".Len int; @"".Cap int }
func @"".SliceOf(@"".t @"".Type) (? @"".Type)
const @"".String @"".Kind = 0x18
type @"".StringHeader struct { @"".Data uintptr; @"".Len int }
const @"".Struct @"".Kind = 0x19
type @"".StructField struct { @"".Name string; @"".PkgPath string; @"".Type @"".Type; @"".Tag @"".StructTag; @"".Offset uintptr; @"".Index []int; @"".Anonymous bool }
type @"".StructTag string
func (? @"".StructTag) @"".Get(@"".key string) (? string)
func (? *@"".StructTag) @"".Get(@"".key string) (? string)
type @"".Type interface { @"".Align() (? int); @"".AssignableTo(@"".u @"".Type) (? bool); @"".Bits() (? int); @"".ChanDir() (? @"".ChanDir); @"".ConvertibleTo(@"".u @"".Type) (? bool); @"".Elem() (? @"".Type); @"".Field(@"".i int) (? @"".StructField); @"".FieldAlign() (? int); @"".FieldByIndex(@"".index []int) (? @"".StructField); @"".FieldByName(@"".name string) (? @"".StructField, ? bool); @"".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"".StructField, ? bool); @"".Implements(@"".u @"".Type) (? bool); @"".In(@"".i int) (? @"".Type); @"".IsVariadic() (? bool); @"".Key() (? @"".Type); @"".Kind() (? @"".Kind); @"".Len() (? int); @"".Method(? int) (? @"".Method); @"".MethodByName(? string) (? @"".Method, ? bool); @"".Name() (? string); @"".NumField() (? int); @"".NumIn() (? int); @"".NumMethod() (? int); @"".NumOut() (? int); @"".Out(@"".i int) (? @"".Type); @"".PkgPath() (? string); @"".Size() (? uintptr); @"".String() (? string); @"".common() (? *@"".rtype); @"".uncommon() (? *@"".uncommonType) }
func @"".TypeOf(@"".i interface {  }) (? @"".Type)
const @"".Uint @"".Kind = 0x7
const @"".Uint16 @"".Kind = 0x9
const @"".Uint32 @"".Kind = 0xa
const @"".Uint64 @"".Kind = 0xb
const @"".Uint8 @"".Kind = 0x8
const @"".Uintptr @"".Kind = 0xc
const @"".UnsafePointer @"".Kind = 0x1a
type @"".Value struct { @"".typ *@"".rtype; @"".val @"unsafe".Pointer; ? @"".flag }
func (? @"".Value) @"".Addr() (? @"".Value)
func (? @"".Value) @"".Bool() (? bool)
func (? @"".Value) @"".Bytes() (? []byte)
func (? @"".Value) @"".Call(@"".in []@"".Value) (? []@"".Value)
func (? @"".Value) @"".CallSlice(@"".in []@"".Value) (? []@"".Value)
func (? @"".Value) @"".CanAddr() (? bool)
func (? @"".Value) @"".CanInterface() (? bool)
func (? @"".Value) @"".CanSet() (? bool)
func (? @"".Value) @"".Cap() (? int)
func (? @"".Value) @"".Close() ()
func (? @"".Value) @"".Complex() (? complex128)
func (? @"".Value) @"".Convert(@"".t @"".Type) (? @"".Value)
func (? @"".Value) @"".Elem() (? @"".Value)
func (? @"".Value) @"".Field(@"".i int) (? @"".Value)
func (? @"".Value) @"".FieldByIndex(@"".index []int) (? @"".Value)
func (? @"".Value) @"".FieldByName(@"".name string) (? @"".Value)
func (? @"".Value) @"".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"".Value)
func (? @"".Value) @"".Float() (? float64)
func (? @"".Value) @"".Index(@"".i int) (? @"".Value)
func (? @"".Value) @"".Int() (? int64)
func (? @"".Value) @"".Interface() (@"".i interface {  })
func (? @"".Value) @"".InterfaceData() (? [2]uintptr)
func (? @"".Value) @"".IsNil() (? bool)
func (? @"".Value) @"".IsValid() (? bool)
func (? @"".Value) @"".Kind() (? @"".Kind)
func (? @"".Value) @"".Len() (? int)
func (? @"".Value) @"".MapIndex(@"".key @"".Value) (? @"".Value)
func (? @"".Value) @"".MapKeys() (? []@"".Value)
func (? @"".Value) @"".Method(@"".i int) (? @"".Value)
func (? @"".Value) @"".MethodByName(@"".name string) (? @"".Value)
func (? @"".Value) @"".NumField() (? int)
func (? @"".Value) @"".NumMethod() (? int)
func (? @"".Value) @"".OverflowComplex(@"".x complex128) (? bool)
func (? @"".Value) @"".OverflowFloat(@"".x float64) (? bool)
func (? @"".Value) @"".OverflowInt(@"".x int64) (? bool)
func (? @"".Value) @"".OverflowUint(@"".x uint64) (? bool)
func (? @"".Value) @"".Pointer() (? uintptr)
func (? @"".Value) @"".Recv() (@"".x @"".Value, @"".ok bool)
func (? @"".Value) @"".Send(@"".x @"".Value) ()
func (? @"".Value) @"".Set(@"".x @"".Value) ()
func (? @"".Value) @"".SetBool(@"".x bool) ()
func (? @"".Value) @"".SetBytes(@"".x []byte) ()
func (? @"".Value) @"".SetCap(@"".n int) ()
func (? @"".Value) @"".SetComplex(@"".x complex128) ()
func (? @"".Value) @"".SetFloat(@"".x float64) ()
func (? @"".Value) @"".SetInt(@"".x int64) ()
func (? @"".Value) @"".SetLen(@"".n int) ()
func (? @"".Value) @"".SetMapIndex(@"".key @"".Value, @"".val @"".Value) ()
func (? @"".Value) @"".SetPointer(@"".x @"unsafe".Pointer) ()
func (? @"".Value) @"".SetString(@"".x string) ()
func (? @"".Value) @"".SetUint(@"".x uint64) ()
func (? @"".Value) @"".Slice(@"".i int, @"".j int) (? @"".Value)
func (? @"".Value) @"".Slice3(@"".i int, @"".j int, @"".k int) (? @"".Value)
func (? @"".Value) @"".String() (? string)
func (? @"".Value) @"".TryRecv() (@"".x @"".Value, @"".ok bool)
func (? @"".Value) @"".TrySend(@"".x @"".Value) (? bool)
func (? @"".Value) @"".Type() (? @"".Type)
func (? @"".Value) @"".Uint() (? uint64)
func (? @"".Value) @"".UnsafeAddr() (? uintptr)
func (? @"".Value) @"".assignTo(@"".context string, @"".dst *@"".rtype, @"".target *interface {  }) (? @"".Value)
func (? @"".Value) @"".call(@"".op string, @"".in []@"".Value) (? []@"".Value)
func (? @"".Value) @"".iword() (? @"".iword)
func (? @"".Value) @"".recv(@"".nb bool) (@"".val @"".Value, @"".ok bool)
func (? @"".Value) @"".runes() (? []rune)
func (? @"".Value) @"".send(@"".x @"".Value, @"".nb bool) (@"".selected bool)
func (? @"".Value) @"".setRunes(@"".x []rune) ()
func (? *@"".Value) @"".Addr() (? @"".Value)
func (? *@"".Value) @"".Bool() (? bool)
func (? *@"".Value) @"".Bytes() (? []byte)
func (? *@"".Value) @"".Call(@"".in []@"".Value) (? []@"".Value)
func (? *@"".Value) @"".CallSlice(@"".in []@"".Value) (? []@"".Value)
func (? *@"".Value) @"".CanAddr() (? bool)
func (? *@"".Value) @"".CanInterface() (? bool)
func (? *@"".Value) @"".CanSet() (? bool)
func (? *@"".Value) @"".Cap() (? int)
func (? *@"".Value) @"".Close() ()
func (? *@"".Value) @"".Complex() (? complex128)
func (? *@"".Value) @"".Convert(@"".t @"".Type) (? @"".Value)
func (? *@"".Value) @"".Elem() (? @"".Value)
func (? *@"".Value) @"".Field(@"".i int) (? @"".Value)
func (? *@"".Value) @"".FieldByIndex(@"".index []int) (? @"".Value)
func (? *@"".Value) @"".FieldByName(@"".name string) (? @"".Value)
func (? *@"".Value) @"".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"".Value)
func (? *@"".Value) @"".Float() (? float64)
func (? *@"".Value) @"".Index(@"".i int) (? @"".Value)
func (? *@"".Value) @"".Int() (? int64)
func (? *@"".Value) @"".Interface() (@"".i interface {  })
func (? *@"".Value) @"".InterfaceData() (? [2]uintptr)
func (? *@"".Value) @"".IsNil() (? bool)
func (? *@"".Value) @"".IsValid() (? bool)
func (? *@"".Value) @"".Kind() (? @"".Kind)
func (? *@"".Value) @"".Len() (? int)
func (? *@"".Value) @"".MapIndex(@"".key @"".Value) (? @"".Value)
func (? *@"".Value) @"".MapKeys() (? []@"".Value)
func (? *@"".Value) @"".Method(@"".i int) (? @"".Value)
func (? *@"".Value) @"".MethodByName(@"".name string) (? @"".Value)
func (? *@"".Value) @"".NumField() (? int)
func (? *@"".Value) @"".NumMethod() (? int)
func (? *@"".Value) @"".OverflowComplex(@"".x complex128) (? bool)
func (? *@"".Value) @"".OverflowFloat(@"".x float64) (? bool)
func (? *@"".Value) @"".OverflowInt(@"".x int64) (? bool)
func (? *@"".Value) @"".OverflowUint(@"".x uint64) (? bool)
func (? *@"".Value) @"".Pointer() (? uintptr)
func (? *@"".Value) @"".Recv() (@"".x @"".Value, @"".ok bool)
func (? *@"".Value) @"".Send(@"".x @"".Value) ()
func (? *@"".Value) @"".Set(@"".x @"".Value) ()
func (? *@"".Value) @"".SetBool(@"".x bool) ()
func (? *@"".Value) @"".SetBytes(@"".x []byte) ()
func (? *@"".Value) @"".SetCap(@"".n int) ()
func (? *@"".Value) @"".SetComplex(@"".x complex128) ()
func (? *@"".Value) @"".SetFloat(@"".x float64) ()
func (? *@"".Value) @"".SetInt(@"".x int64) ()
func (? *@"".Value) @"".SetLen(@"".n int) ()
func (? *@"".Value) @"".SetMapIndex(@"".key @"".Value, @"".val @"".Value) ()
func (? *@"".Value) @"".SetPointer(@"".x @"unsafe".Pointer) ()
func (? *@"".Value) @"".SetString(@"".x string) ()
func (? *@"".Value) @"".SetUint(@"".x uint64) ()
func (? *@"".Value) @"".Slice(@"".i int, @"".j int) (? @"".Value)
func (? *@"".Value) @"".Slice3(@"".i int, @"".j int, @"".k int) (? @"".Value)
func (? *@"".Value) @"".String() (? string)
func (? *@"".Value) @"".TryRecv() (@"".x @"".Value, @"".ok bool)
func (? *@"".Value) @"".TrySend(@"".x @"".Value) (? bool)
func (? *@"".Value) @"".Type() (? @"".Type)
func (? *@"".Value) @"".Uint() (? uint64)
func (? *@"".Value) @"".UnsafeAddr() (? uintptr)
func (? *@"".Value) @"".assignTo(@"".context string, @"".dst *@"".rtype, @"".target *interface {  }) (? @"".Value)
func (? *@"".Value) @"".call(@"".op string, @"".in []@"".Value) (? []@"".Value)
func (? *@"".Value) @"".iword() (? @"".iword)
func (? *@"".Value) @"".recv(@"".nb bool) (@"".val @"".Value, @"".ok bool)
func (? *@"".Value) @"".runes() (? []rune)
func (? *@"".Value) @"".send(@"".x @"".Value, @"".nb bool) (@"".selected bool)
func (? *@"".Value) @"".setRunes(@"".x []rune) ()
type @"".ValueError struct { @"".Method string; @"".Kind @"".Kind }
func (? *@"".ValueError) @"".Error() (? string)
func @"".ValueOf(@"".i interface {  }) (? @"".Value)
func @"".Zero(@"".typ @"".Type) (? @"".Value)
type @"".arrayType struct { ? @"".rtype "reflect:\"array\""; @"".elem *@"".rtype; @"".slice *@"".rtype; @"".len uintptr }
type @"".badGC struct { @"".width uintptr; @"".end uintptr }
type @"".cacheKey struct { @"".kind @"".Kind; @"".t1 *@"".rtype; @"".t2 *@"".rtype; @"".extra uintptr }
type @"".chanGC struct { @"".width uintptr; @"".op uintptr; @"".off uintptr; @"".typ *@"".rtype; @"".end uintptr }
type @"".chanType struct { ? @"".rtype "reflect:\"chan\""; @"".elem *@"".rtype; @"".dir uintptr }
type @"".emptyInterface struct { @"".typ *@"".rtype; @"".word @"".iword }
type @"".fieldScan struct { @"".typ *@"".structType; @"".index []int }
type @"".flag uintptr
func (? @"".flag) @"".kind() (? @"".Kind)
func (? @"".flag) @"".mustBe(@"".expected @"".Kind) ()
func (? @"".flag) @"".mustBeAssignable() ()
func (? @"".flag) @"".mustBeExported() ()
func (? *@"".flag) @"".kind() (? @"".Kind)
func (? *@"".flag) @"".mustBe(@"".expected @"".Kind) ()
func (? *@"".flag) @"".mustBeAssignable() ()
func (? *@"".flag) @"".mustBeExported() ()
type @"".funcType struct { ? @"".rtype "reflect:\"func\""; @"".dotdotdot bool; @"".in []*@"".rtype; @"".out []*@"".rtype }
type @"".imethod struct { @"".name *string; @"".pkgPath *string; @"".typ *@"".rtype }
type @"".interfaceType struct { ? @"".rtype "reflect:\"interface\""; @"".methods []@"".imethod }
func (? *@"".interfaceType) @"".Method(@"".i int) (@"".m @"".Method)
func (? *@"".interfaceType) @"".MethodByName(@"".name string) (@"".m @"".Method, @"".ok bool)
func (? *@"".interfaceType) @"".NumMethod() (? int)
type @"".iword @"unsafe".Pointer
type @"".makeFuncImpl struct { @"".code uintptr; @"".typ *@"".funcType; @"".fn func (? []@"".Value) (? []@"".Value) }
type @"".mapType struct { ? @"".rtype "reflect:\"map\""; @"".key *@"".rtype; @"".elem *@"".rtype; @"".bucket *@"".rtype; @"".hmap *@"".rtype }
type @"".method struct { @"".name *string; @"".pkgPath *string; @"".mtyp *@"".rtype; @"".typ *@"".rtype; @"".ifn @"unsafe".Pointer; @"".tfn @"unsafe".Pointer }
type @"".methodValue struct { @"".fn uintptr; @"".method int; @"".rcvr @"".Value }
type @"".nonEmptyInterface struct { @"".itab *struct { @"".ityp *@"".rtype; @"".typ *@"".rtype; @"".link @"unsafe".Pointer; @"".bad int32; @"".unused int32; @"".fun [100000]@"unsafe".Pointer }; @"".word @"".iword }
type @"".ptrDataGC struct { @"".width uintptr; @"".op uintptr; @"".off uintptr; @"".end uintptr }
type @"".ptrGC struct { @"".width uintptr; @"".op uintptr; @"".off uintptr; @"".elemgc @"unsafe".Pointer; @"".end uintptr }
type @"".ptrType struct { ? @"".rtype "reflect:\"ptr\""; @"".elem *@"".rtype }
type @"".rtype struct { @"".size uintptr; @"".hash uint32; _ uint8; @"".align uint8; @"".fieldAlign uint8; @"".kind uint8; @"".alg *uintptr; @"".gc @"unsafe".Pointer; @"".string *string; ? *@"".uncommonType; @"".ptrToThis *@"".rtype }
func (? *@"".rtype) @"".Align() (? int)
func (? *@"".rtype) @"".AssignableTo(@"".u @"".Type) (? bool)
func (? *@"".rtype) @"".Bits() (? int)
func (? *@"".rtype) @"".ChanDir() (? @"".ChanDir)
func (? *@"".rtype) @"".ConvertibleTo(@"".u @"".Type) (? bool)
func (? *@"".rtype) @"".Elem() (? @"".Type)
func (? *@"".rtype) @"".Field(@"".i int) (? @"".StructField)
func (? *@"".rtype) @"".FieldAlign() (? int)
func (? *@"".rtype) @"".FieldByIndex(@"".index []int) (? @"".StructField)
func (? *@"".rtype) @"".FieldByName(@"".name string) (? @"".StructField, ? bool)
func (? *@"".rtype) @"".FieldByNameFunc(@"".match func (? string) (? bool)) (? @"".StructField, ? bool)
func (? *@"".rtype) @"".Implements(@"".u @"".Type) (? bool)
func (? *@"".rtype) @"".In(@"".i int) (? @"".Type)
func (? *@"".rtype) @"".IsVariadic() (? bool)
func (? *@"".rtype) @"".Key() (? @"".Type)
func (? *@"".rtype) @"".Kind() (? @"".Kind)
func (? *@"".rtype) @"".Len() (? int)
func (? *@"".rtype) @"".Method(@"".i int) (@"".m @"".Method)
func (? *@"".rtype) @"".MethodByName(@"".name string) (@"".m @"".Method, @"".ok bool)
func (? *@"".rtype) @"".Name() (? string)
func (? *@"".rtype) @"".NumField() (? int)
func (? *@"".rtype) @"".NumIn() (? int)
func (? *@"".rtype) @"".NumMethod() (? int)
func (? *@"".rtype) @"".NumOut() (? int)
func (? *@"".rtype) @"".Out(@"".i int) (? @"".Type)
func (? *@"".rtype) @"".PkgPath() (? string)
func (? *@"".rtype) @"".Size() (? uintptr)
func (? *@"".rtype) @"".String() (? string)
func (? *@"".rtype) @"".common() (? *@"".rtype)
func (? *@"".rtype) @"".ptrTo() (? *@"".rtype)
type @"".runtimeSelect struct { @"".dir uintptr; @"".typ *@"".rtype; @"".ch @"".iword; @"".val @"".iword }
type @"".sliceEmptyGC struct { @"".width uintptr; @"".op uintptr; @"".off uintptr; @"".end uintptr }
type @"".sliceGC struct { @"".width uintptr; @"".op uintptr; @"".off uintptr; @"".elemgc @"unsafe".Pointer; @"".end uintptr }
type @"".sliceType struct { ? @"".rtype "reflect:\"slice\""; @"".elem *@"".rtype }
type @"".structField struct { @"".name *string; @"".pkgPath *string; @"".typ *@"".rtype; @"".tag *string; @"".offset uintptr }
type @"".structType struct { ? @"".rtype "reflect:\"struct\""; @"".fields []@"".structField }
func (? *@"".structType) @"".Field(@"".i int) (@"".f @"".StructField)
func (? *@"".structType) @"".FieldByIndex(@"".index []int) (@"".f @"".StructField)
func (? *@"".structType) @"".FieldByName(@"".name string) (@"".f @"".StructField, @"".present bool)
func (? *@"".structType) @"".FieldByNameFunc(@"".match func (? string) (? bool)) (@"".result @"".StructField, @"".ok bool)
type @"".uncommonType struct { @"".name *string; @"".pkgPath *string; @"".methods []@"".method }
func (? *@"".uncommonType) @"".Method(@"".i int) (@"".m @"".Method)
func (? *@"".uncommonType) @"".MethodByName(@"".name string) (@"".m @"".Method, @"".ok bool)
func (? *@"".uncommonType) @"".Name() (? string)
func (? *@"".uncommonType) @"".NumMethod() (? int)
func (? *@"".uncommonType) @"".PkgPath() (? string)
func (? *@"".uncommonType) @"".uncommon() (? *@"".uncommonType)
type @"".visit struct { @"".a1 uintptr; @"".a2 uintptr; @"".typ @"".Type }
$$
0Jruntimematherrorsunicode/utf8strconvsync/atomicsyncreflect0D0strconvstrconv0syncsync0mathmath0runtimeruntime0ÉPÙ0Çè visitÇ	visit = go$pkg.visit = go$newType(0, "Struct", "reflect.visit", "visit", "reflect", function(a1_, a2_, typ_) {
		this.go$val = this;
		this.a1 = a1_ !== undefined ? a1_ : 0;
		this.a2 = a2_ !== undefined ? a2_ : 0;
		this.typ = typ_ !== undefined ? typ_ : null;
	});
t		visit.init([["a1", "reflect", Go$Uintptr, ""], ["a2", "reflect", Go$Uintptr, ""], ["typ", "reflect", Type, ""]]);
0Ç> makeFuncImplÇ\	makeFuncImpl = go$pkg.makeFuncImpl = go$newType(0, "Struct", "reflect.makeFuncImpl", "makeFuncImpl", "reflect", function(code_, typ_, fn_) {
		this.go$val = this;
		this.code = code_ !== undefined ? code_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(funcType)).nil;
		this.fn = fn_ !== undefined ? fn_ : go$throwNilPointerError;
	});
ÅÀ		makeFuncImpl.init([["code", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(funcType)), ""], ["fn", "reflect", (go$funcType([(go$sliceType(Value))], [(go$sliceType(Value))], false)), ""]]);
0Ç‘ methodValueÇC	methodValue = go$pkg.methodValue = go$newType(0, "Struct", "reflect.methodValue", "methodValue", "reflect", function(fn_, method_, rcvr_) {
		this.go$val = this;
		this.fn = fn_ !== undefined ? fn_ : 0;
		this.method = method_ !== undefined ? method_ : 0;
		this.rcvr = rcvr_ !== undefined ? rcvr_ : new Value.Ptr();
	});
|		methodValue.init([["fn", "reflect", Go$Uintptr, ""], ["method", "reflect", Go$Int, ""], ["rcvr", "reflect", Value, ""]]);
0Çê Type[	Type = go$pkg.Type = go$newType(0, "Interface", "reflect.Type", "Type", "reflect", null);
Ç'		Type.init([["Align", "", (go$funcType([], [Go$Int], false))], ["AssignableTo", "", (go$funcType([Type], [Go$Bool], false))], ["Bits", "", (go$funcType([], [Go$Int], false))], ["ChanDir", "", (go$funcType([], [ChanDir], false))], ["ConvertibleTo", "", (go$funcType([Type], [Go$Bool], false))], ["Elem", "", (go$funcType([], [Type], false))], ["Field", "", (go$funcType([Go$Int], [StructField], false))], ["FieldAlign", "", (go$funcType([], [Go$Int], false))], ["FieldByIndex", "", (go$funcType([(go$sliceType(Go$Int))], [StructField], false))], ["FieldByName", "", (go$funcType([Go$String], [StructField, Go$Bool], false))], ["FieldByNameFunc", "", (go$funcType([(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false))], ["Implements", "", (go$funcType([Type], [Go$Bool], false))], ["In", "", (go$funcType([Go$Int], [Type], false))], ["IsVariadic", "", (go$funcType([], [Go$Bool], false))], ["Key", "", (go$funcType([], [Type], false))], ["Kind", "", (go$funcType([], [Kind], false))], ["Len", "", (go$funcType([], [Go$Int], false))], ["Method", "", (go$funcType([Go$Int], [Method], false))], ["MethodByName", "", (go$funcType([Go$String], [Method, Go$Bool], false))], ["Name", "", (go$funcType([], [Go$String], false))], ["NumField", "", (go$funcType([], [Go$Int], false))], ["NumIn", "", (go$funcType([], [Go$Int], false))], ["NumMethod", "", (go$funcType([], [Go$Int], false))], ["NumOut", "", (go$funcType([], [Go$Int], false))], ["Out", "", (go$funcType([Go$Int], [Type], false))], ["PkgPath", "", (go$funcType([], [Go$String], false))], ["Size", "", (go$funcType([], [Go$Uintptr], false))], ["String", "", (go$funcType([], [Go$String], false))], ["common", "reflect", (go$funcType([], [(go$ptrType(rtype))], false))], ["uncommon", "reflect", (go$funcType([], [(go$ptrType(uncommonType))], false))]]);
0ÅÁ KindV	Kind = go$pkg.Kind = go$newType(4, "Uint", "reflect.Kind", "Kind", "reflect", null);
ÅÑ		Kind.methods = [["String", "", [], [Go$String], false]];
		(go$ptrType(Kind)).methods = [["String", "", [], [Go$String], false]];
0Ç< rtypeÇI	rtype = go$pkg.rtype = go$newType(0, "Struct", "reflect.rtype", "rtype", "reflect", function(size_, hash_, _$2_, align_, fieldAlign_, kind_, alg_, gc_, string_, uncommonType_, ptrToThis_) {
		this.go$val = this;
		this.size = size_ !== undefined ? size_ : 0;
		this.hash = hash_ !== undefined ? hash_ : 0;
		this._$2 = _$2_ !== undefined ? _$2_ : 0;
		this.align = align_ !== undefined ? align_ : 0;
		this.fieldAlign = fieldAlign_ !== undefined ? fieldAlign_ : 0;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.alg = alg_ !== undefined ? alg_ : (go$ptrType(Go$Uintptr)).nil;
		this.gc = gc_ !== undefined ? gc_ : 0;
		this.string = string_ !== undefined ? string_ : (go$ptrType(Go$String)).nil;
		this.uncommonType = uncommonType_ !== undefined ? uncommonType_ : (go$ptrType(uncommonType)).nil;
		this.ptrToThis = ptrToThis_ !== undefined ? ptrToThis_ : (go$ptrType(rtype)).nil;
	});
	rtype.prototype.Method = function(i) { return this.go$val.Method(i); };
	rtype.Ptr.prototype.Method = function(i) { return this.uncommonType.Method(i); };
	rtype.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	rtype.Ptr.prototype.MethodByName = function(name) { return this.uncommonType.MethodByName(name); };
	rtype.prototype.Name = function() { return this.go$val.Name(); };
	rtype.Ptr.prototype.Name = function() { return this.uncommonType.Name(); };
	rtype.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	rtype.Ptr.prototype.NumMethod = function() { return this.uncommonType.NumMethod(); };
	rtype.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	rtype.Ptr.prototype.PkgPath = function() { return this.uncommonType.PkgPath(); };
	rtype.prototype.uncommon = function() { return this.go$val.uncommon(); };
	rtype.Ptr.prototype.uncommon = function() { return this.uncommonType.uncommon(); };
Ç‚		rtype.init([["size", "reflect", Go$Uintptr, ""], ["hash", "reflect", Go$Uint32, ""], ["_", "reflect", Go$Uint8, ""], ["align", "reflect", Go$Uint8, ""], ["fieldAlign", "reflect", Go$Uint8, ""], ["kind", "reflect", Go$Uint8, ""], ["alg", "reflect", (go$ptrType(Go$Uintptr)), ""], ["gc", "reflect", Go$UnsafePointer, ""], ["string", "reflect", (go$ptrType(Go$String)), ""], ["", "reflect", (go$ptrType(uncommonType)), ""], ["ptrToThis", "reflect", (go$ptrType(rtype)), ""]]);
		rtype.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(rtype)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç\ methodÇ#	method = go$pkg.method = go$newType(0, "Struct", "reflect.method", "method", "reflect", function(name_, pkgPath_, mtyp_, typ_, ifn_, tfn_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.mtyp = mtyp_ !== undefined ? mtyp_ : (go$ptrType(rtype)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.ifn = ifn_ !== undefined ? ifn_ : 0;
		this.tfn = tfn_ !== undefined ? tfn_ : 0;
	});
Ç'		method.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["mtyp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["ifn", "reflect", Go$UnsafePointer, ""], ["tfn", "reflect", Go$UnsafePointer, ""]]);
0Ç≤ uncommonTypeÇû	uncommonType = go$pkg.uncommonType = go$newType(0, "Struct", "reflect.uncommonType", "uncommonType", "reflect", function(name_, pkgPath_, methods_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(method)).nil;
	});
Ç¸		uncommonType.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["methods", "reflect", (go$sliceType(method)), ""]]);
		(go$ptrType(uncommonType)).methods = [["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumMethod", "", [], [Go$Int], false], ["PkgPath", "", [], [Go$String], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Å˚ ChanDira	ChanDir = go$pkg.ChanDir = go$newType(4, "Int", "reflect.ChanDir", "ChanDir", "reflect", null);
Åä		ChanDir.methods = [["String", "", [], [Go$String], false]];
		(go$ptrType(ChanDir)).methods = [["String", "", [], [Go$String], false]];
0Çı 	arrayTypeÇ	arrayType = go$pkg.arrayType = go$newType(0, "Struct", "reflect.arrayType", "arrayType", "reflect", function(rtype_, elem_, slice_, len_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.slice = slice_ !== undefined ? slice_ : (go$ptrType(rtype)).nil;
		this.len = len_ !== undefined ? len_ : 0;
	});
	arrayType.prototype.Align = function() { return this.go$val.Align(); };
	arrayType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	arrayType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	arrayType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	arrayType.prototype.Bits = function() { return this.go$val.Bits(); };
	arrayType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	arrayType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	arrayType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	arrayType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	arrayType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	arrayType.prototype.Elem = function() { return this.go$val.Elem(); };
	arrayType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	arrayType.prototype.Field = function(i) { return this.go$val.Field(i); };
	arrayType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	arrayType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	arrayType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	arrayType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	arrayType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	arrayType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	arrayType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	arrayType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	arrayType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	arrayType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	arrayType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	arrayType.prototype.In = function(i) { return this.go$val.In(i); };
	arrayType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	arrayType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	arrayType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	arrayType.prototype.Key = function() { return this.go$val.Key(); };
	arrayType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	arrayType.prototype.Kind = function() { return this.go$val.Kind(); };
	arrayType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	arrayType.prototype.Len = function() { return this.go$val.Len(); };
	arrayType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	arrayType.prototype.Method = function(i) { return this.go$val.Method(i); };
	arrayType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	arrayType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	arrayType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	arrayType.prototype.Name = function() { return this.go$val.Name(); };
	arrayType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	arrayType.prototype.NumField = function() { return this.go$val.NumField(); };
	arrayType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	arrayType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	arrayType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	arrayType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	arrayType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	arrayType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	arrayType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	arrayType.prototype.Out = function(i) { return this.go$val.Out(i); };
	arrayType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	arrayType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	arrayType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	arrayType.prototype.Size = function() { return this.go$val.Size(); };
	arrayType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	arrayType.prototype.String = function() { return this.go$val.String(); };
	arrayType.Ptr.prototype.String = function() { return this.rtype.String(); };
	arrayType.prototype.common = function() { return this.go$val.common(); };
	arrayType.Ptr.prototype.common = function() { return this.rtype.common(); };
	arrayType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	arrayType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	arrayType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	arrayType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Ç–		arrayType.init([["", "reflect", rtype, "reflect:\"array\""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["slice", "reflect", (go$ptrType(rtype)), ""], ["len", "reflect", Go$Uintptr, ""]]);
		arrayType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(arrayType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç/ chanTypeÇ~	chanType = go$pkg.chanType = go$newType(0, "Struct", "reflect.chanType", "chanType", "reflect", function(rtype_, elem_, dir_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.dir = dir_ !== undefined ? dir_ : 0;
	});
	chanType.prototype.Align = function() { return this.go$val.Align(); };
	chanType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	chanType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	chanType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	chanType.prototype.Bits = function() { return this.go$val.Bits(); };
	chanType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	chanType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	chanType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	chanType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	chanType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	chanType.prototype.Elem = function() { return this.go$val.Elem(); };
	chanType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	chanType.prototype.Field = function(i) { return this.go$val.Field(i); };
	chanType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	chanType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	chanType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	chanType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	chanType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	chanType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	chanType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	chanType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	chanType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	chanType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	chanType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	chanType.prototype.In = function(i) { return this.go$val.In(i); };
	chanType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	chanType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	chanType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	chanType.prototype.Key = function() { return this.go$val.Key(); };
	chanType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	chanType.prototype.Kind = function() { return this.go$val.Kind(); };
	chanType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	chanType.prototype.Len = function() { return this.go$val.Len(); };
	chanType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	chanType.prototype.Method = function(i) { return this.go$val.Method(i); };
	chanType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	chanType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	chanType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	chanType.prototype.Name = function() { return this.go$val.Name(); };
	chanType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	chanType.prototype.NumField = function() { return this.go$val.NumField(); };
	chanType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	chanType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	chanType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	chanType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	chanType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	chanType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	chanType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	chanType.prototype.Out = function(i) { return this.go$val.Out(i); };
	chanType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	chanType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	chanType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	chanType.prototype.Size = function() { return this.go$val.Size(); };
	chanType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	chanType.prototype.String = function() { return this.go$val.String(); };
	chanType.Ptr.prototype.String = function() { return this.rtype.String(); };
	chanType.prototype.common = function() { return this.go$val.common(); };
	chanType.Ptr.prototype.common = function() { return this.rtype.common(); };
	chanType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	chanType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	chanType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	chanType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Çù		chanType.init([["", "reflect", rtype, "reflect:\"chan\""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["dir", "reflect", Go$Uintptr, ""]]);
		chanType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(chanType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç funcTypeÇ	funcType = go$pkg.funcType = go$newType(0, "Struct", "reflect.funcType", "funcType", "reflect", function(rtype_, dotdotdot_, in$2_, out_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.dotdotdot = dotdotdot_ !== undefined ? dotdotdot_ : false;
		this.in$2 = in$2_ !== undefined ? in$2_ : (go$sliceType((go$ptrType(rtype)))).nil;
		this.out = out_ !== undefined ? out_ : (go$sliceType((go$ptrType(rtype)))).nil;
	});
	funcType.prototype.Align = function() { return this.go$val.Align(); };
	funcType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	funcType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	funcType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	funcType.prototype.Bits = function() { return this.go$val.Bits(); };
	funcType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	funcType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	funcType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	funcType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	funcType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	funcType.prototype.Elem = function() { return this.go$val.Elem(); };
	funcType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	funcType.prototype.Field = function(i) { return this.go$val.Field(i); };
	funcType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	funcType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	funcType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	funcType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	funcType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	funcType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	funcType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	funcType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	funcType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	funcType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	funcType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	funcType.prototype.In = function(i) { return this.go$val.In(i); };
	funcType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	funcType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	funcType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	funcType.prototype.Key = function() { return this.go$val.Key(); };
	funcType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	funcType.prototype.Kind = function() { return this.go$val.Kind(); };
	funcType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	funcType.prototype.Len = function() { return this.go$val.Len(); };
	funcType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	funcType.prototype.Method = function(i) { return this.go$val.Method(i); };
	funcType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	funcType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	funcType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	funcType.prototype.Name = function() { return this.go$val.Name(); };
	funcType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	funcType.prototype.NumField = function() { return this.go$val.NumField(); };
	funcType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	funcType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	funcType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	funcType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	funcType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	funcType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	funcType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	funcType.prototype.Out = function(i) { return this.go$val.Out(i); };
	funcType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	funcType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	funcType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	funcType.prototype.Size = function() { return this.go$val.Size(); };
	funcType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	funcType.prototype.String = function() { return this.go$val.String(); };
	funcType.Ptr.prototype.String = function() { return this.rtype.String(); };
	funcType.prototype.common = function() { return this.go$val.common(); };
	funcType.Ptr.prototype.common = function() { return this.rtype.common(); };
	funcType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	funcType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	funcType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	funcType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
ÇÎ		funcType.init([["", "reflect", rtype, "reflect:\"func\""], ["dotdotdot", "reflect", Go$Bool, ""], ["in", "reflect", (go$sliceType((go$ptrType(rtype)))), ""], ["out", "reflect", (go$sliceType((go$ptrType(rtype)))), ""]]);
		funcType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(funcType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç/ imethodÇw	imethod = go$pkg.imethod = go$newType(0, "Struct", "reflect.imethod", "imethod", "reflect", function(name_, pkgPath_, typ_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
	});
Å¶		imethod.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""]]);
0ÇS interfaceTypeÇ¶	interfaceType = go$pkg.interfaceType = go$newType(0, "Struct", "reflect.interfaceType", "interfaceType", "reflect", function(rtype_, methods_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.methods = methods_ !== undefined ? methods_ : (go$sliceType(imethod)).nil;
	});
	interfaceType.prototype.Align = function() { return this.go$val.Align(); };
	interfaceType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	interfaceType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	interfaceType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	interfaceType.prototype.Bits = function() { return this.go$val.Bits(); };
	interfaceType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	interfaceType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	interfaceType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	interfaceType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	interfaceType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	interfaceType.prototype.Elem = function() { return this.go$val.Elem(); };
	interfaceType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	interfaceType.prototype.Field = function(i) { return this.go$val.Field(i); };
	interfaceType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	interfaceType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	interfaceType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	interfaceType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	interfaceType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	interfaceType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	interfaceType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	interfaceType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	interfaceType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	interfaceType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	interfaceType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	interfaceType.prototype.In = function(i) { return this.go$val.In(i); };
	interfaceType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	interfaceType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	interfaceType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	interfaceType.prototype.Key = function() { return this.go$val.Key(); };
	interfaceType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	interfaceType.prototype.Kind = function() { return this.go$val.Kind(); };
	interfaceType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	interfaceType.prototype.Len = function() { return this.go$val.Len(); };
	interfaceType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	interfaceType.prototype.Method = function(i) { return this.go$val.Method(i); };
	interfaceType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	interfaceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	interfaceType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	interfaceType.prototype.Name = function() { return this.go$val.Name(); };
	interfaceType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	interfaceType.prototype.NumField = function() { return this.go$val.NumField(); };
	interfaceType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	interfaceType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	interfaceType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	interfaceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	interfaceType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	interfaceType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	interfaceType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	interfaceType.prototype.Out = function(i) { return this.go$val.Out(i); };
	interfaceType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	interfaceType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	interfaceType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	interfaceType.prototype.Size = function() { return this.go$val.Size(); };
	interfaceType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	interfaceType.prototype.String = function() { return this.go$val.String(); };
	interfaceType.Ptr.prototype.String = function() { return this.rtype.String(); };
	interfaceType.prototype.common = function() { return this.go$val.common(); };
	interfaceType.Ptr.prototype.common = function() { return this.rtype.common(); };
	interfaceType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	interfaceType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	interfaceType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	interfaceType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Çî		interfaceType.init([["", "reflect", rtype, "reflect:\"interface\""], ["methods", "reflect", (go$sliceType(imethod)), ""]]);
		interfaceType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(interfaceType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç mapTypeÇÚ	mapType = go$pkg.mapType = go$newType(0, "Struct", "reflect.mapType", "mapType", "reflect", function(rtype_, key_, elem_, bucket_, hmap_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.key = key_ !== undefined ? key_ : (go$ptrType(rtype)).nil;
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
		this.bucket = bucket_ !== undefined ? bucket_ : (go$ptrType(rtype)).nil;
		this.hmap = hmap_ !== undefined ? hmap_ : (go$ptrType(rtype)).nil;
	});
	mapType.prototype.Align = function() { return this.go$val.Align(); };
	mapType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	mapType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	mapType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	mapType.prototype.Bits = function() { return this.go$val.Bits(); };
	mapType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	mapType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	mapType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	mapType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	mapType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	mapType.prototype.Elem = function() { return this.go$val.Elem(); };
	mapType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	mapType.prototype.Field = function(i) { return this.go$val.Field(i); };
	mapType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	mapType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	mapType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	mapType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	mapType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	mapType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	mapType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	mapType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	mapType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	mapType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	mapType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	mapType.prototype.In = function(i) { return this.go$val.In(i); };
	mapType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	mapType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	mapType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	mapType.prototype.Key = function() { return this.go$val.Key(); };
	mapType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	mapType.prototype.Kind = function() { return this.go$val.Kind(); };
	mapType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	mapType.prototype.Len = function() { return this.go$val.Len(); };
	mapType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	mapType.prototype.Method = function(i) { return this.go$val.Method(i); };
	mapType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	mapType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	mapType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	mapType.prototype.Name = function() { return this.go$val.Name(); };
	mapType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	mapType.prototype.NumField = function() { return this.go$val.NumField(); };
	mapType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	mapType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	mapType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	mapType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	mapType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	mapType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	mapType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	mapType.prototype.Out = function(i) { return this.go$val.Out(i); };
	mapType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	mapType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	mapType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	mapType.prototype.Size = function() { return this.go$val.Size(); };
	mapType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	mapType.prototype.String = function() { return this.go$val.String(); };
	mapType.Ptr.prototype.String = function() { return this.rtype.String(); };
	mapType.prototype.common = function() { return this.go$val.common(); };
	mapType.Ptr.prototype.common = function() { return this.rtype.common(); };
	mapType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	mapType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	mapType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	mapType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Ç 		mapType.init([["", "reflect", rtype, "reflect:\"map\""], ["key", "reflect", (go$ptrType(rtype)), ""], ["elem", "reflect", (go$ptrType(rtype)), ""], ["bucket", "reflect", (go$ptrType(rtype)), ""], ["hmap", "reflect", (go$ptrType(rtype)), ""]]);
		mapType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(mapType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Çí ptrTypeÇ
	ptrType = go$pkg.ptrType = go$newType(0, "Struct", "reflect.ptrType", "ptrType", "reflect", function(rtype_, elem_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
	});
	ptrType.prototype.Align = function() { return this.go$val.Align(); };
	ptrType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	ptrType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	ptrType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	ptrType.prototype.Bits = function() { return this.go$val.Bits(); };
	ptrType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	ptrType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	ptrType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	ptrType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	ptrType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	ptrType.prototype.Elem = function() { return this.go$val.Elem(); };
	ptrType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	ptrType.prototype.Field = function(i) { return this.go$val.Field(i); };
	ptrType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	ptrType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	ptrType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	ptrType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	ptrType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	ptrType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	ptrType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	ptrType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	ptrType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	ptrType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	ptrType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	ptrType.prototype.In = function(i) { return this.go$val.In(i); };
	ptrType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	ptrType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	ptrType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	ptrType.prototype.Key = function() { return this.go$val.Key(); };
	ptrType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	ptrType.prototype.Kind = function() { return this.go$val.Kind(); };
	ptrType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	ptrType.prototype.Len = function() { return this.go$val.Len(); };
	ptrType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	ptrType.prototype.Method = function(i) { return this.go$val.Method(i); };
	ptrType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	ptrType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	ptrType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	ptrType.prototype.Name = function() { return this.go$val.Name(); };
	ptrType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	ptrType.prototype.NumField = function() { return this.go$val.NumField(); };
	ptrType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	ptrType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	ptrType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	ptrType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	ptrType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	ptrType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	ptrType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	ptrType.prototype.Out = function(i) { return this.go$val.Out(i); };
	ptrType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	ptrType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	ptrType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	ptrType.prototype.Size = function() { return this.go$val.Size(); };
	ptrType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	ptrType.prototype.String = function() { return this.go$val.String(); };
	ptrType.Ptr.prototype.String = function() { return this.rtype.String(); };
	ptrType.prototype.common = function() { return this.go$val.common(); };
	ptrType.Ptr.prototype.common = function() { return this.rtype.common(); };
	ptrType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	ptrType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	ptrType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	ptrType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Çu		ptrType.init([["", "reflect", rtype, "reflect:\"ptr\""], ["elem", "reflect", (go$ptrType(rtype)), ""]]);
		ptrType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(ptrType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç  	sliceTypeÇé	sliceType = go$pkg.sliceType = go$newType(0, "Struct", "reflect.sliceType", "sliceType", "reflect", function(rtype_, elem_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.elem = elem_ !== undefined ? elem_ : (go$ptrType(rtype)).nil;
	});
	sliceType.prototype.Align = function() { return this.go$val.Align(); };
	sliceType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	sliceType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	sliceType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	sliceType.prototype.Bits = function() { return this.go$val.Bits(); };
	sliceType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	sliceType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	sliceType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	sliceType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	sliceType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	sliceType.prototype.Elem = function() { return this.go$val.Elem(); };
	sliceType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	sliceType.prototype.Field = function(i) { return this.go$val.Field(i); };
	sliceType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	sliceType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	sliceType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	sliceType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	sliceType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	sliceType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	sliceType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	sliceType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	sliceType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	sliceType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	sliceType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	sliceType.prototype.In = function(i) { return this.go$val.In(i); };
	sliceType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	sliceType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	sliceType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	sliceType.prototype.Key = function() { return this.go$val.Key(); };
	sliceType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	sliceType.prototype.Kind = function() { return this.go$val.Kind(); };
	sliceType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	sliceType.prototype.Len = function() { return this.go$val.Len(); };
	sliceType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	sliceType.prototype.Method = function(i) { return this.go$val.Method(i); };
	sliceType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	sliceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	sliceType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	sliceType.prototype.Name = function() { return this.go$val.Name(); };
	sliceType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	sliceType.prototype.NumField = function() { return this.go$val.NumField(); };
	sliceType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	sliceType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	sliceType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	sliceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	sliceType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	sliceType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	sliceType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	sliceType.prototype.Out = function(i) { return this.go$val.Out(i); };
	sliceType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	sliceType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	sliceType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	sliceType.prototype.Size = function() { return this.go$val.Size(); };
	sliceType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	sliceType.prototype.String = function() { return this.go$val.String(); };
	sliceType.Ptr.prototype.String = function() { return this.rtype.String(); };
	sliceType.prototype.common = function() { return this.go$val.common(); };
	sliceType.Ptr.prototype.common = function() { return this.rtype.common(); };
	sliceType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	sliceType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	sliceType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	sliceType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Ç}		sliceType.init([["", "reflect", rtype, "reflect:\"slice\""], ["elem", "reflect", (go$ptrType(rtype)), ""]]);
		sliceType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(sliceType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç* structFieldÇ	structField = go$pkg.structField = go$newType(0, "Struct", "reflect.structField", "structField", "reflect", function(name_, pkgPath_, typ_, tag_, offset_) {
		this.go$val = this;
		this.name = name_ !== undefined ? name_ : (go$ptrType(Go$String)).nil;
		this.pkgPath = pkgPath_ !== undefined ? pkgPath_ : (go$ptrType(Go$String)).nil;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.tag = tag_ !== undefined ? tag_ : (go$ptrType(Go$String)).nil;
		this.offset = offset_ !== undefined ? offset_ : 0;
	});
Ç		structField.init([["name", "reflect", (go$ptrType(Go$String)), ""], ["pkgPath", "reflect", (go$ptrType(Go$String)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["tag", "reflect", (go$ptrType(Go$String)), ""], ["offset", "reflect", Go$Uintptr, ""]]);
0ÇÅ 
structTypeÇ‡	structType = go$pkg.structType = go$newType(0, "Struct", "reflect.structType", "structType", "reflect", function(rtype_, fields_) {
		this.go$val = this;
		this.rtype = rtype_ !== undefined ? rtype_ : new rtype.Ptr();
		this.fields = fields_ !== undefined ? fields_ : (go$sliceType(structField)).nil;
	});
	structType.prototype.Align = function() { return this.go$val.Align(); };
	structType.Ptr.prototype.Align = function() { return this.rtype.Align(); };
	structType.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
	structType.Ptr.prototype.AssignableTo = function(u) { return this.rtype.AssignableTo(u); };
	structType.prototype.Bits = function() { return this.go$val.Bits(); };
	structType.Ptr.prototype.Bits = function() { return this.rtype.Bits(); };
	structType.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
	structType.Ptr.prototype.ChanDir = function() { return this.rtype.ChanDir(); };
	structType.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
	structType.Ptr.prototype.ConvertibleTo = function(u) { return this.rtype.ConvertibleTo(u); };
	structType.prototype.Elem = function() { return this.go$val.Elem(); };
	structType.Ptr.prototype.Elem = function() { return this.rtype.Elem(); };
	structType.prototype.Field = function(i) { return this.go$val.Field(i); };
	structType.Ptr.prototype.Field = function(i) { return this.rtype.Field(i); };
	structType.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
	structType.Ptr.prototype.FieldAlign = function() { return this.rtype.FieldAlign(); };
	structType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
	structType.Ptr.prototype.FieldByIndex = function(index) { return this.rtype.FieldByIndex(index); };
	structType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
	structType.Ptr.prototype.FieldByName = function(name) { return this.rtype.FieldByName(name); };
	structType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
	structType.Ptr.prototype.FieldByNameFunc = function(match) { return this.rtype.FieldByNameFunc(match); };
	structType.prototype.Implements = function(u) { return this.go$val.Implements(u); };
	structType.Ptr.prototype.Implements = function(u) { return this.rtype.Implements(u); };
	structType.prototype.In = function(i) { return this.go$val.In(i); };
	structType.Ptr.prototype.In = function(i) { return this.rtype.In(i); };
	structType.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
	structType.Ptr.prototype.IsVariadic = function() { return this.rtype.IsVariadic(); };
	structType.prototype.Key = function() { return this.go$val.Key(); };
	structType.Ptr.prototype.Key = function() { return this.rtype.Key(); };
	structType.prototype.Kind = function() { return this.go$val.Kind(); };
	structType.Ptr.prototype.Kind = function() { return this.rtype.Kind(); };
	structType.prototype.Len = function() { return this.go$val.Len(); };
	structType.Ptr.prototype.Len = function() { return this.rtype.Len(); };
	structType.prototype.Method = function(i) { return this.go$val.Method(i); };
	structType.Ptr.prototype.Method = function(i) { return this.rtype.Method(i); };
	structType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
	structType.Ptr.prototype.MethodByName = function(name) { return this.rtype.MethodByName(name); };
	structType.prototype.Name = function() { return this.go$val.Name(); };
	structType.Ptr.prototype.Name = function() { return this.rtype.Name(); };
	structType.prototype.NumField = function() { return this.go$val.NumField(); };
	structType.Ptr.prototype.NumField = function() { return this.rtype.NumField(); };
	structType.prototype.NumIn = function() { return this.go$val.NumIn(); };
	structType.Ptr.prototype.NumIn = function() { return this.rtype.NumIn(); };
	structType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
	structType.Ptr.prototype.NumMethod = function() { return this.rtype.NumMethod(); };
	structType.prototype.NumOut = function() { return this.go$val.NumOut(); };
	structType.Ptr.prototype.NumOut = function() { return this.rtype.NumOut(); };
	structType.prototype.Out = function(i) { return this.go$val.Out(i); };
	structType.Ptr.prototype.Out = function(i) { return this.rtype.Out(i); };
	structType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
	structType.Ptr.prototype.PkgPath = function() { return this.rtype.PkgPath(); };
	structType.prototype.Size = function() { return this.go$val.Size(); };
	structType.Ptr.prototype.Size = function() { return this.rtype.Size(); };
	structType.prototype.String = function() { return this.go$val.String(); };
	structType.Ptr.prototype.String = function() { return this.rtype.String(); };
	structType.prototype.common = function() { return this.go$val.common(); };
	structType.Ptr.prototype.common = function() { return this.rtype.common(); };
	structType.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
	structType.Ptr.prototype.ptrTo = function() { return this.rtype.ptrTo(); };
	structType.prototype.uncommon = function() { return this.go$val.uncommon(); };
	structType.Ptr.prototype.uncommon = function() { return this.rtype.uncommon(); };
Çã		structType.init([["", "reflect", rtype, "reflect:\"struct\""], ["fields", "reflect", (go$sliceType(structField)), ""]]);
		structType.methods = [["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
		(go$ptrType(structType)).methods = [["Align", "", [], [Go$Int], false], ["AssignableTo", "", [Type], [Go$Bool], false], ["Bits", "", [], [Go$Int], false], ["ChanDir", "", [], [ChanDir], false], ["ConvertibleTo", "", [Type], [Go$Bool], false], ["Elem", "", [], [Type], false], ["Field", "", [Go$Int], [StructField], false], ["FieldAlign", "", [], [Go$Int], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [StructField], false], ["FieldByName", "", [Go$String], [StructField, Go$Bool], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [StructField, Go$Bool], false], ["Implements", "", [Type], [Go$Bool], false], ["In", "", [Go$Int], [Type], false], ["IsVariadic", "", [], [Go$Bool], false], ["Key", "", [], [Type], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["Method", "", [Go$Int], [Method], false], ["MethodByName", "", [Go$String], [Method, Go$Bool], false], ["Name", "", [], [Go$String], false], ["NumField", "", [], [Go$Int], false], ["NumIn", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["NumOut", "", [], [Go$Int], false], ["Out", "", [Go$Int], [Type], false], ["PkgPath", "", [], [Go$String], false], ["Size", "", [], [Go$Uintptr], false], ["String", "", [], [Go$String], false], ["common", "reflect", [], [(go$ptrType(rtype))], false], ["ptrTo", "reflect", [], [(go$ptrType(rtype))], false], ["uncommon", "reflect", [], [(go$ptrType(uncommonType))], false]];
0Ç[ MethodÇ∞	Method = go$pkg.Method = go$newType(0, "Struct", "reflect.Method", "Method", "reflect", function(Name_, PkgPath_, Type_, Func_, Index_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.PkgPath = PkgPath_ !== undefined ? PkgPath_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Func = Func_ !== undefined ? Func_ : new Value.Ptr();
		this.Index = Index_ !== undefined ? Index_ : 0;
	});
Åö		Method.init([["Name", "", Go$String, ""], ["PkgPath", "", Go$String, ""], ["Type", "", Type, ""], ["Func", "", Value, ""], ["Index", "", Go$Int, ""]]);
0Ç` StructFieldÇX	StructField = go$pkg.StructField = go$newType(0, "Struct", "reflect.StructField", "StructField", "reflect", function(Name_, PkgPath_, Type_, Tag_, Offset_, Index_, Anonymous_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.PkgPath = PkgPath_ !== undefined ? PkgPath_ : "";
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Tag = Tag_ !== undefined ? Tag_ : "";
		this.Offset = Offset_ !== undefined ? Offset_ : 0;
		this.Index = Index_ !== undefined ? Index_ : (go$sliceType(Go$Int)).nil;
		this.Anonymous = Anonymous_ !== undefined ? Anonymous_ : false;
	});
ÅÚ		StructField.init([["Name", "", Go$String, ""], ["PkgPath", "", Go$String, ""], ["Type", "", Type, ""], ["Tag", "", StructTag, ""], ["Offset", "", Go$Uintptr, ""], ["Index", "", (go$sliceType(Go$Int)), ""], ["Anonymous", "", Go$Bool, ""]]);
0Ç 	StructTagl	StructTag = go$pkg.StructTag = go$newType(0, "String", "reflect.StructTag", "StructTag", "reflect", null);
Åö		StructTag.methods = [["Get", "", [Go$String], [Go$String], false]];
		(go$ptrType(StructTag)).methods = [["Get", "", [Go$String], [Go$String], false]];
0Ç∂ 	fieldScanÇ+	fieldScan = go$pkg.fieldScan = go$newType(0, "Struct", "reflect.fieldScan", "fieldScan", "reflect", function(typ_, index_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(structType)).nil;
		this.index = index_ !== undefined ? index_ : (go$sliceType(Go$Int)).nil;
	});
x		fieldScan.init([["typ", "reflect", (go$ptrType(structType)), ""], ["index", "reflect", (go$sliceType(Go$Int)), ""]]);
0Ç 	ptrDataGCÇW	ptrDataGC = go$pkg.ptrDataGC = go$newType(0, "Struct", "reflect.ptrDataGC", "ptrDataGC", "reflect", function(width_, op_, off_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
Å•		ptrDataGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
0Çc ptrGCÇÖ	ptrGC = go$pkg.ptrGC = go$newType(0, "Struct", "reflect.ptrGC", "ptrGC", "reflect", function(width_, op_, off_, elemgc_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.elemgc = elemgc_ !== undefined ? elemgc_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
ÅŒ		ptrGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["elemgc", "reflect", Go$UnsafePointer, ""], ["end", "reflect", Go$Uintptr, ""]]);
0ÇB cacheKeyÇ	cacheKey = go$pkg.cacheKey = go$newType(0, "Struct", "reflect.cacheKey", "cacheKey", "reflect", function(kind_, t1_, t2_, extra_) {
		this.go$val = this;
		this.kind = kind_ !== undefined ? kind_ : 0;
		this.t1 = t1_ !== undefined ? t1_ : (go$ptrType(rtype)).nil;
		this.t2 = t2_ !== undefined ? t2_ : (go$ptrType(rtype)).nil;
		this.extra = extra_ !== undefined ? extra_ : 0;
	});
Å∞		cacheKey.init([["kind", "reflect", Kind, ""], ["t1", "reflect", (go$ptrType(rtype)), ""], ["t2", "reflect", (go$ptrType(rtype)), ""], ["extra", "reflect", Go$Uintptr, ""]]);
0Çs chanGCÇì	chanGC = go$pkg.chanGC = go$newType(0, "Struct", "reflect.chanGC", "chanGC", "reflect", function(width_, op_, off_, typ_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.end = end_ !== undefined ? end_ : 0;
	});
Åœ		chanGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["end", "reflect", Go$Uintptr, ""]]);
0ÇO badGCÅÁ	badGC = go$pkg.badGC = go$newType(0, "Struct", "reflect.badGC", "badGC", "reflect", function(width_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
Z		badGC.init([["width", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
0Ço sliceGCÇç	sliceGC = go$pkg.sliceGC = go$newType(0, "Struct", "reflect.sliceGC", "sliceGC", "reflect", function(width_, op_, off_, elemgc_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.elemgc = elemgc_ !== undefined ? elemgc_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
Å–		sliceGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["elemgc", "reflect", Go$UnsafePointer, ""], ["end", "reflect", Go$Uintptr, ""]]);
0Ç" sliceEmptyGCÇc	sliceEmptyGC = go$pkg.sliceEmptyGC = go$newType(0, "Struct", "reflect.sliceEmptyGC", "sliceEmptyGC", "reflect", function(width_, op_, off_, end_) {
		this.go$val = this;
		this.width = width_ !== undefined ? width_ : 0;
		this.op = op_ !== undefined ? op_ : 0;
		this.off = off_ !== undefined ? off_ : 0;
		this.end = end_ !== undefined ? end_ : 0;
	});
Å®		sliceEmptyGC.init([["width", "reflect", Go$Uintptr, ""], ["op", "reflect", Go$Uintptr, ""], ["off", "reflect", Go$Uintptr, ""], ["end", "reflect", Go$Uintptr, ""]]);
0Ç∫ ValueÇÛ	Value = go$pkg.Value = go$newType(0, "Struct", "reflect.Value", "Value", "reflect", function(typ_, val_, flag_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.val = val_ !== undefined ? val_ : 0;
		this.flag = flag_ !== undefined ? flag_ : 0;
	});
	Value.prototype.kind = function() { return this.go$val.kind(); };
	Value.Ptr.prototype.kind = function() { return new flag(this.flag).kind(); };
	Value.prototype.mustBe = function(expected) { return this.go$val.mustBe(expected); };
	Value.Ptr.prototype.mustBe = function(expected) { return new flag(this.flag).mustBe(expected); };
	Value.prototype.mustBeAssignable = function() { return this.go$val.mustBeAssignable(); };
	Value.Ptr.prototype.mustBeAssignable = function() { return new flag(this.flag).mustBeAssignable(); };
	Value.prototype.mustBeExported = function() { return this.go$val.mustBeExported(); };
	Value.Ptr.prototype.mustBeExported = function() { return new flag(this.flag).mustBeExported(); };
Ç∂		Value.init([["typ", "reflect", (go$ptrType(rtype)), ""], ["val", "reflect", Go$UnsafePointer, ""], ["", "reflect", flag, ""]]);
		Value.methods = [["Addr", "", [], [Value], false], ["Bool", "", [], [Go$Bool], false], ["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Call", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CallSlice", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CanAddr", "", [], [Go$Bool], false], ["CanInterface", "", [], [Go$Bool], false], ["CanSet", "", [], [Go$Bool], false], ["Cap", "", [], [Go$Int], false], ["Close", "", [], [], false], ["Complex", "", [], [Go$Complex128], false], ["Convert", "", [Type], [Value], false], ["Elem", "", [], [Value], false], ["Field", "", [Go$Int], [Value], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [Value], false], ["FieldByName", "", [Go$String], [Value], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [Value], false], ["Float", "", [], [Go$Float64], false], ["Index", "", [Go$Int], [Value], false], ["Int", "", [], [Go$Int64], false], ["Interface", "", [], [go$emptyInterface], false], ["InterfaceData", "", [], [(go$arrayType(Go$Uintptr, 2))], false], ["IsNil", "", [], [Go$Bool], false], ["IsValid", "", [], [Go$Bool], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["MapIndex", "", [Value], [Value], false], ["MapKeys", "", [], [(go$sliceType(Value))], false], ["Method", "", [Go$Int], [Value], false], ["MethodByName", "", [Go$String], [Value], false], ["NumField", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["OverflowComplex", "", [Go$Complex128], [Go$Bool], false], ["OverflowFloat", "", [Go$Float64], [Go$Bool], false], ["OverflowInt", "", [Go$Int64], [Go$Bool], false], ["OverflowUint", "", [Go$Uint64], [Go$Bool], false], ["Pointer", "", [], [Go$Uintptr], false], ["Recv", "", [], [Value, Go$Bool], false], ["Send", "", [Value], [], false], ["Set", "", [Value], [], false], ["SetBool", "", [Go$Bool], [], false], ["SetBytes", "", [(go$sliceType(Go$Uint8))], [], false], ["SetCap", "", [Go$Int], [], false], ["SetComplex", "", [Go$Complex128], [], false], ["SetFloat", "", [Go$Float64], [], false], ["SetInt", "", [Go$Int64], [], false], ["SetLen", "", [Go$Int], [], false], ["SetMapIndex", "", [Value, Value], [], false], ["SetPointer", "", [Go$UnsafePointer], [], false], ["SetString", "", [Go$String], [], false], ["SetUint", "", [Go$Uint64], [], false], ["Slice", "", [Go$Int, Go$Int], [Value], false], ["Slice3", "", [Go$Int, Go$Int, Go$Int], [Value], false], ["String", "", [], [Go$String], false], ["TryRecv", "", [], [Value, Go$Bool], false], ["TrySend", "", [Value], [Go$Bool], false], ["Type", "", [], [Type], false], ["Uint", "", [], [Go$Uint64], false], ["UnsafeAddr", "", [], [Go$Uintptr], false], ["assignTo", "reflect", [Go$String, (go$ptrType(rtype)), (go$ptrType(go$emptyInterface))], [Value], false], ["call", "reflect", [Go$String, (go$sliceType(Value))], [(go$sliceType(Value))], false], ["iword", "reflect", [], [iword], false], ["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false], ["recv", "reflect", [Go$Bool], [Value, Go$Bool], false], ["runes", "reflect", [], [(go$sliceType(Go$Int32))], false], ["send", "reflect", [Value, Go$Bool], [Go$Bool], false], ["setRunes", "reflect", [(go$sliceType(Go$Int32))], [], false]];
		(go$ptrType(Value)).methods = [["Addr", "", [], [Value], false], ["Bool", "", [], [Go$Bool], false], ["Bytes", "", [], [(go$sliceType(Go$Uint8))], false], ["Call", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CallSlice", "", [(go$sliceType(Value))], [(go$sliceType(Value))], false], ["CanAddr", "", [], [Go$Bool], false], ["CanInterface", "", [], [Go$Bool], false], ["CanSet", "", [], [Go$Bool], false], ["Cap", "", [], [Go$Int], false], ["Close", "", [], [], false], ["Complex", "", [], [Go$Complex128], false], ["Convert", "", [Type], [Value], false], ["Elem", "", [], [Value], false], ["Field", "", [Go$Int], [Value], false], ["FieldByIndex", "", [(go$sliceType(Go$Int))], [Value], false], ["FieldByName", "", [Go$String], [Value], false], ["FieldByNameFunc", "", [(go$funcType([Go$String], [Go$Bool], false))], [Value], false], ["Float", "", [], [Go$Float64], false], ["Index", "", [Go$Int], [Value], false], ["Int", "", [], [Go$Int64], false], ["Interface", "", [], [go$emptyInterface], false], ["InterfaceData", "", [], [(go$arrayType(Go$Uintptr, 2))], false], ["IsNil", "", [], [Go$Bool], false], ["IsValid", "", [], [Go$Bool], false], ["Kind", "", [], [Kind], false], ["Len", "", [], [Go$Int], false], ["MapIndex", "", [Value], [Value], false], ["MapKeys", "", [], [(go$sliceType(Value))], false], ["Method", "", [Go$Int], [Value], false], ["MethodByName", "", [Go$String], [Value], false], ["NumField", "", [], [Go$Int], false], ["NumMethod", "", [], [Go$Int], false], ["OverflowComplex", "", [Go$Complex128], [Go$Bool], false], ["OverflowFloat", "", [Go$Float64], [Go$Bool], false], ["OverflowInt", "", [Go$Int64], [Go$Bool], false], ["OverflowUint", "", [Go$Uint64], [Go$Bool], false], ["Pointer", "", [], [Go$Uintptr], false], ["Recv", "", [], [Value, Go$Bool], false], ["Send", "", [Value], [], false], ["Set", "", [Value], [], false], ["SetBool", "", [Go$Bool], [], false], ["SetBytes", "", [(go$sliceType(Go$Uint8))], [], false], ["SetCap", "", [Go$Int], [], false], ["SetComplex", "", [Go$Complex128], [], false], ["SetFloat", "", [Go$Float64], [], false], ["SetInt", "", [Go$Int64], [], false], ["SetLen", "", [Go$Int], [], false], ["SetMapIndex", "", [Value, Value], [], false], ["SetPointer", "", [Go$UnsafePointer], [], false], ["SetString", "", [Go$String], [], false], ["SetUint", "", [Go$Uint64], [], false], ["Slice", "", [Go$Int, Go$Int], [Value], false], ["Slice3", "", [Go$Int, Go$Int, Go$Int], [Value], false], ["String", "", [], [Go$String], false], ["TryRecv", "", [], [Value, Go$Bool], false], ["TrySend", "", [Value], [Go$Bool], false], ["Type", "", [], [Type], false], ["Uint", "", [], [Go$Uint64], false], ["UnsafeAddr", "", [], [Go$Uintptr], false], ["assignTo", "reflect", [Go$String, (go$ptrType(rtype)), (go$ptrType(go$emptyInterface))], [Value], false], ["call", "reflect", [Go$String, (go$sliceType(Value))], [(go$sliceType(Value))], false], ["iword", "reflect", [], [iword], false], ["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false], ["recv", "reflect", [Go$Bool], [Value, Go$Bool], false], ["runes", "reflect", [], [(go$sliceType(Go$Int32))], false], ["send", "reflect", [Value, Go$Bool], [Go$Bool], false], ["setRunes", "reflect", [(go$sliceType(Go$Int32))], [], false]];
0Ç˚ flagY	flag = go$pkg.flag = go$newType(4, "Uintptr", "reflect.flag", "flag", "reflect", null);
Çî		flag.methods = [["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false]];
		(go$ptrType(flag)).methods = [["kind", "reflect", [], [Kind], false], ["mustBe", "reflect", [Kind], [], false], ["mustBeAssignable", "reflect", [], [], false], ["mustBeExported", "reflect", [], [], false]];
0Ç≥ 
ValueErrorÇ	ValueError = go$pkg.ValueError = go$newType(0, "Struct", "reflect.ValueError", "ValueError", "reflect", function(Method_, Kind_) {
		this.go$val = this;
		this.Method = Method_ !== undefined ? Method_ : "";
		this.Kind = Kind_ !== undefined ? Kind_ : 0;
	});
Åö		ValueError.init([["Method", "", Go$String, ""], ["Kind", "", Kind, ""]]);
		(go$ptrType(ValueError)).methods = [["Error", "", [], [Go$String], false]];
0p iwordc	iword = go$pkg.iword = go$newType(0, "UnsafePointer", "reflect.iword", "iword", "reflect", null);
 0Çõ emptyInterfaceÇ	emptyInterface = go$pkg.emptyInterface = go$newType(0, "Struct", "reflect.emptyInterface", "emptyInterface", "reflect", function(typ_, word_) {
		this.go$val = this;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.word = word_ !== undefined ? word_ : 0;
	});
f		emptyInterface.init([["typ", "reflect", (go$ptrType(rtype)), ""], ["word", "reflect", iword, ""]]);
0ÇÍ nonEmptyInterfaceÇH	nonEmptyInterface = go$pkg.nonEmptyInterface = go$newType(0, "Struct", "reflect.nonEmptyInterface", "nonEmptyInterface", "reflect", function(itab_, word_) {
		this.go$val = this;
		this.itab = itab_ !== undefined ? itab_ : (go$ptrType((go$structType([["ityp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["link", "reflect", Go$UnsafePointer, ""], ["bad", "reflect", Go$Int32, ""], ["unused", "reflect", Go$Int32, ""], ["fun", "reflect", (go$arrayType(Go$UnsafePointer, 100000)), ""]])))).nil;
		this.word = word_ !== undefined ? word_ : 0;
	});
ÇÖ		nonEmptyInterface.init([["itab", "reflect", (go$ptrType((go$structType([["ityp", "reflect", (go$ptrType(rtype)), ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["link", "reflect", Go$UnsafePointer, ""], ["bad", "reflect", Go$Int32, ""], ["unused", "reflect", Go$Int32, ""], ["fun", "reflect", (go$arrayType(Go$UnsafePointer, 100000)), ""]])))), ""], ["word", "reflect", iword, ""]]);
0Çb StringHeaderÅˇ	StringHeader = go$pkg.StringHeader = go$newType(0, "Struct", "reflect.StringHeader", "StringHeader", "reflect", function(Data_, Len_) {
		this.go$val = this;
		this.Data = Data_ !== undefined ? Data_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
	});
N		StringHeader.init([["Data", "", Go$Uintptr, ""], ["Len", "", Go$Int, ""]]);
0Ç® SliceHeaderÇ-	SliceHeader = go$pkg.SliceHeader = go$newType(0, "Struct", "reflect.SliceHeader", "SliceHeader", "reflect", function(Data_, Len_, Cap_) {
		this.go$val = this;
		this.Data = Data_ !== undefined ? Data_ : 0;
		this.Len = Len_ !== undefined ? Len_ : 0;
		this.Cap = Cap_ !== undefined ? Cap_ : 0;
	});
f		SliceHeader.init([["Data", "", Go$Uintptr, ""], ["Len", "", Go$Int, ""], ["Cap", "", Go$Int, ""]]);
0Ç3 runtimeSelectÇu	runtimeSelect = go$pkg.runtimeSelect = go$newType(0, "Struct", "reflect.runtimeSelect", "runtimeSelect", "reflect", function(dir_, typ_, ch_, val_) {
		this.go$val = this;
		this.dir = dir_ !== undefined ? dir_ : 0;
		this.typ = typ_ !== undefined ? typ_ : (go$ptrType(rtype)).nil;
		this.ch = ch_ !== undefined ? ch_ : 0;
		this.val = val_ !== undefined ? val_ : 0;
	});
Å¶		runtimeSelect.init([["dir", "reflect", Go$Uintptr, ""], ["typ", "reflect", (go$ptrType(rtype)), ""], ["ch", "reflect", iword, ""], ["val", "reflect", iword, ""]]);
0z 	SelectDiri	SelectDir = go$pkg.SelectDir = go$newType(4, "Int", "reflect.SelectDir", "SelectDir", "reflect", null);
 0Ç¿ 
SelectCaseÇI	SelectCase = go$pkg.SelectCase = go$newType(0, "Struct", "reflect.SelectCase", "SelectCase", "reflect", function(Dir_, Chan_, Send_) {
		this.go$val = this;
		this.Dir = Dir_ !== undefined ? Dir_ : 0;
		this.Chan = Chan_ !== undefined ? Chan_ : new Value.Ptr();
		this.Send = Send_ !== undefined ? Send_ : new Value.Ptr();
	});
c		SelectCase.init([["Dir", "", SelectDir, ""], ["Chan", "", Value, ""], ["Send", "", Value, ""]]);
0ÇU deepValueEqualÇ=	deepValueEqual = function(v1, v2, visited, depth) {
		var hard, addr1, addr2, _tuple, typ, v, _entry, _key, _struct, _ref, i, _struct$1, _struct$2, i$1, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7, _struct$8, _tuple$1, i$2, n, _struct$9, _struct$10, _ref$1, _i, _slice, _index, _struct$11, k, _struct$12, _struct$13, _struct$14, _struct$15, _struct$16, _struct$17;
		if (!v1.IsValid() || !v2.IsValid()) {
			return v1.IsValid() === v2.IsValid();
		}
		if (!(go$interfaceIsEqual(v1.Type(), v2.Type()))) {
			return false;
		}
		hard = (function(k) {
			var _ref;
			_ref = k;
			if (_ref === 17 || _ref === 21 || _ref === 23 || _ref === 25) {
				return true;
			}
			return false;
		});
		if (v1.CanAddr() && v2.CanAddr() && hard(v1.Kind())) {
			addr1 = v1.UnsafeAddr();
			addr2 = v2.UnsafeAddr();
			if (addr1 > addr2) {
				_tuple = [addr2, addr1], addr1 = _tuple[0], addr2 = _tuple[1];
			}
			if (addr1 === addr2) {
				return true;
			}
			typ = v1.Type();
			v = new visit.Ptr(addr1, addr2, typ);
			if ((_entry = visited[(new visit(v)).go$key()], _entry !== undefined ? _entry.v : false)) {
				return true;
			}
			_key = (_struct = v, new visit.Ptr(_struct.a1, _struct.a2, _struct.typ)), (visited || go$throwRuntimeError("assignment to entry in nil map"))[(new visit(_key)).go$key()] = { k: _key, v: true };
		}
		_ref = v1.Kind();
		if (_ref === 17) {
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			i = 0;
			while (i < v1.Len()) {
				if (!deepValueEqual((_struct$1 = v1.Index(i), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), (_struct$2 = v2.Index(i), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i = i + 1 >> 0;
			}
			return true;
		} else if (_ref === 23) {
			if (!(v1.IsNil() === v2.IsNil())) {
				return false;
			}
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			if (v1.Pointer() === v2.Pointer()) {
				return true;
			}
			i$1 = 0;
			while (i$1 < v1.Len()) {
				if (!deepValueEqual((_struct$3 = v1.Index(i$1), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), (_struct$4 = v2.Index(i$1), new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i$1 = i$1 + 1 >> 0;
			}
			return true;
		} else if (_ref === 20) {
			if (v1.IsNil() || v2.IsNil()) {
				return v1.IsNil() === v2.IsNil();
			}
			return deepValueEqual((_struct$5 = v1.Elem(), new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), (_struct$6 = v2.Elem(), new Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)), visited, depth + 1 >> 0);
		} else if (_ref === 22) {
			return deepValueEqual((_struct$7 = v1.Elem(), new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), (_struct$8 = v2.Elem(), new Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)), visited, depth + 1 >> 0);
		} else if (_ref === 25) {
			_tuple$1 = [0, v1.NumField()], i$2 = _tuple$1[0], n = _tuple$1[1];
			while (i$2 < n) {
				if (!deepValueEqual((_struct$9 = v1.Field(i$2), new Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag)), (_struct$10 = v2.Field(i$2), new Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				i$2 = i$2 + 1 >> 0;
			}
			return true;
		} else if (_ref === 21) {
			if (!(v1.IsNil() === v2.IsNil())) {
				return false;
			}
			if (!((v1.Len() === v2.Len()))) {
				return false;
			}
			if (v1.Pointer() === v2.Pointer()) {
				return true;
			}
			_ref$1 = v1.MapKeys();
			_i = 0;
			while (_i < _ref$1.length) {
				k = (_struct$11 = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag));
				if (!deepValueEqual((_struct$13 = v1.MapIndex((_struct$12 = k, new Value.Ptr(_struct$12.typ, _struct$12.val, _struct$12.flag))), new Value.Ptr(_struct$13.typ, _struct$13.val, _struct$13.flag)), (_struct$15 = v2.MapIndex((_struct$14 = k, new Value.Ptr(_struct$14.typ, _struct$14.val, _struct$14.flag))), new Value.Ptr(_struct$15.typ, _struct$15.val, _struct$15.flag)), visited, depth + 1 >> 0)) {
					return false;
				}
				_i++;
			}
			return true;
		} else if (_ref === 19) {
			if (v1.IsNil() && v2.IsNil()) {
				return true;
			}
			return false;
		} else {
			return go$interfaceIsEqual(valueInterface((_struct$16 = v1, new Value.Ptr(_struct$16.typ, _struct$16.val, _struct$16.flag)), false), valueInterface((_struct$17 = v2, new Value.Ptr(_struct$17.typ, _struct$17.val, _struct$17.flag)), false));
		}
	};
 0Ç 	DeepEqualÅ˚	DeepEqual = go$pkg.DeepEqual = function(a1, a2) {
			if (a1 === a2) {
				return true;
			}
			if (a1 === null || a2 === null || a1.constructor !== a2.constructor) {
				return false;
			}
			return deepValueEqual(ValueOf(a1), ValueOf(a2), []);
		};
 0ÇÏ MakeFuncÇ⁄	MakeFunc = go$pkg.MakeFunc = function(typ, fn) {
			var fv = function() {
				var args = new Go$Array(typ.NumIn()), i;
				for (i = 0; i < typ.NumIn(); i++) {
					var t = typ.In(i);
					args[i] = new Value.Ptr(t, arguments[i], t.Kind() << flagKindShift);
				}
				var resultsSlice = fn(new (go$sliceType(Value.Ptr))(args));
				switch (typ.NumOut()) {
				case 0:
					return;
				case 1:
					return resultsSlice.array[resultsSlice.offset].iword();
				default:
					var results = new Go$Array(typ.NumOut());
					for (i = 0; i < typ.NumOut(); i++) {
						results[i] = resultsSlice.array[resultsSlice.offset + i].iword();
					}
					return results;
				}
			}
		  return new Value.Ptr(typ, fv, Func << flagKindShift);
		};
 0x makeFuncStubd	makeFuncStub = function() {
		throw go$panic("Native function not implemented: makeFuncStub");
	};
 0Çø makeMethodValueÇ¶	makeMethodValue = function(op, v) {
			if ((v.flag & flagMethod) === 0) {
				throw go$panic("reflect: internal error: invalid use of makePartialFunc");
			}

			var tuple = methodReceiver(op, v, v.flag >> flagMethodShift);
			var fn = tuple[1];
			var rcvr = tuple[2];
			var fv = function() { return fn.apply(rcvr, arguments); };
			return new Value.Ptr(v.Type(), fv, (v.flag & flagRO) | (Func << flagKindShift));
		};
 0ÅÅ methodValueCallj	methodValueCall = function() {
		throw go$panic("Native function not implemented: methodValueCall");
	};
 0Ç∫  Ç∞	Kind.prototype.String = function() {
		var k, _slice, _index;
		k = this.go$val;
		if ((k >> 0) < kindNames.length) {
			return (_slice = kindNames, _index = k, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		return "kind" + strconv.Itoa((k >> 0));
	};
	go$ptrType(Kind).prototype.String = function() { return new Kind(this.go$get()).String(); };
 0Å¥  Å´	uncommonType.Ptr.prototype.uncommon = function() {
		var t;
		t = this;
		return t;
	};
	uncommonType.prototype.uncommon = function() { return this.go$val.uncommon(); };
 0Ç@  Ç6	uncommonType.Ptr.prototype.PkgPath = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil || go$pointerIsEqual(t.pkgPath, (go$ptrType(Go$String)).nil)) {
			return "";
		}
		return t.pkgPath.go$get();
	};
	uncommonType.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
 0Ç1  Ç'	uncommonType.Ptr.prototype.Name = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil || go$pointerIsEqual(t.name, (go$ptrType(Go$String)).nil)) {
			return "";
		}
		return t.name.go$get();
	};
	uncommonType.prototype.Name = function() { return this.go$val.Name(); };
 0Å∞  Åß	rtype.Ptr.prototype.String = function() {
		var t;
		t = this;
		return t.string.go$get();
	};
	rtype.prototype.String = function() { return this.go$val.String(); };
 0Åü  Åñ	rtype.Ptr.prototype.Size = function() {
		var t;
		t = this;
		return t.size;
	};
	rtype.prototype.Size = function() { return this.go$val.Size(); };
 0ÇÔ  ÇÂ	rtype.Ptr.prototype.Bits = function() {
		var t, k, x, x$1;
		t = this;
		if (t === (go$ptrType(rtype)).nil) {
			throw go$panic(new Go$String("reflect: Bits of nil Type"));
		}
		k = t.Kind();
		if (k < 2 || k > 16) {
			throw go$panic(new Go$String("reflect: Bits of non-arithmetic Type " + t.String()));
		}
		return (x = (t.size >> 0), x$1 = 8, (((x >>> 16 << 16) * x$1 >> 0) + (x << 16 >>> 16) * x$1) >> 0);
	};
	rtype.prototype.Bits = function() { return this.go$val.Bits(); };
 0Å™  Å°	rtype.Ptr.prototype.Align = function() {
		var t;
		t = this;
		return (t.align >> 0);
	};
	rtype.prototype.Align = function() { return this.go$val.Align(); };
 0Åæ  Åµ	rtype.Ptr.prototype.FieldAlign = function() {
		var t;
		t = this;
		return (t.fieldAlign >> 0);
	};
	rtype.prototype.FieldAlign = function() { return this.go$val.FieldAlign(); };
 0Å∑  ÅÆ	rtype.Ptr.prototype.Kind = function() {
		var t;
		t = this;
		return (((t.kind & 127) >>> 0) >>> 0);
	};
	rtype.prototype.Kind = function() { return this.go$val.Kind(); };
 0Å†  Åó	rtype.Ptr.prototype.common = function() {
		var t;
		t = this;
		return t;
	};
	rtype.prototype.common = function() { return this.go$val.common(); };
 0Ç.  Ç$	uncommonType.Ptr.prototype.Method = function(i) {
			if (this === uncommonType.Ptr.nil || i < 0 || i >= this.methods.length) {
				throw go$panic("reflect: Method index out of range");
			}
			var p = this.methods.array[i];
			var fl = Func << flagKindShift;
			var pkgPath = "";
			if (p.pkgPath.go$get !== go$throwNilPointerError) {
				pkgPath = p.pkgPath.go$get();
				fl |= flagRO;
			}
			var mt = p.typ;
			var name = p.name.go$get();
			if (go$reservedKeywords.indexOf(name) !== -1) {
				name += "$";
			}
			var fn = function(rcvr) {
				return rcvr[name].apply(rcvr, Go$Array.prototype.slice.apply(arguments, [1]));
			}
			return new Method.Ptr(p.name.go$get(), pkgPath, mt, new Value.Ptr(mt, fn, fl), i);
		};
	uncommonType.prototype.Method = function(i) { return this.go$val.Method(i); };
 0Ç  Å¸	uncommonType.Ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil) {
			return 0;
		}
		return t.methods.length;
	};
	uncommonType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
 0Ç~  Çt	uncommonType.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, _struct, _struct$1, p, _ref, _i, i, _slice, _index, _struct$2, _struct$3, _tuple, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t === (go$ptrType(uncommonType)).nil) {
			return [(_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok];
		}
		p = (go$ptrType(method)).nil;
		_ref = t.methods;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!(go$pointerIsEqual(p.name, (go$ptrType(Go$String)).nil)) && p.name.go$get() === name) {
				_tuple = [(_struct$2 = t.Method(i), new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), true], m = _tuple[0], ok = _tuple[1];
				return [(_struct$4 = m, new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok];
			}
			_i++;
		}
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	uncommonType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
 0Ç  Ç	rtype.Ptr.prototype.NumMethod = function() {
		var t, tt;
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			return tt.NumMethod();
		}
		return t.uncommonType.NumMethod();
	};
	rtype.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
 0Çy  Ço	rtype.Ptr.prototype.Method = function(i) {
		var m, t, tt, _struct, _struct$1, _struct$2, _struct$3, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			m = (_struct = tt.Method(i), new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index));
			return (_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index));
		}
		m = (_struct$4 = t.uncommonType.Method(i), new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index));
		return (_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index));
	};
	rtype.prototype.Method = function(i) { return this.go$val.Method(i); };
 0Ç$  Ç	rtype.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, tt, _tuple, _struct, _struct$1, _struct$2, _struct$3, _tuple$1, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t.Kind() === 20) {
			tt = t.interfaceType;
			_tuple = tt.MethodByName(name), m = (_struct = _tuple[0], new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok = _tuple[1];
			return [(_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), ok];
		}
		_tuple$1 = t.uncommonType.MethodByName(name), m = (_struct$4 = _tuple$1[0], new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok = _tuple$1[1];
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	rtype.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
 0Å∫  Å±	rtype.Ptr.prototype.PkgPath = function() {
		var t;
		t = this;
		return t.uncommonType.PkgPath();
	};
	rtype.prototype.PkgPath = function() { return this.go$val.PkgPath(); };
 0ÅÆ  Å•	rtype.Ptr.prototype.Name = function() {
		var t;
		t = this;
		return t.uncommonType.Name();
	};
	rtype.prototype.Name = function() { return this.go$val.Name(); };
 0Ç0  Ç&	rtype.Ptr.prototype.ChanDir = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 18))) {
			throw go$panic(new Go$String("reflect: ChanDir of non-chan type"));
		}
		tt = t.chanType;
		return (tt.dir >> 0);
	};
	rtype.prototype.ChanDir = function() { return this.go$val.ChanDir(); };
 0Ç;  Ç1	rtype.Ptr.prototype.IsVariadic = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: IsVariadic of non-func type"));
		}
		tt = t.funcType;
		return tt.dotdotdot;
	};
	rtype.prototype.IsVariadic = function() { return this.go$val.IsVariadic(); };
 0Çä  ÇÄ	rtype.Ptr.prototype.Elem = function() {
		var t, _ref, tt, tt$1, tt$2, tt$3, tt$4;
		t = this;
		_ref = t.Kind();
		if (_ref === 17) {
			tt = t.arrayType;
			return toType(tt.elem);
		} else if (_ref === 18) {
			tt$1 = t.chanType;
			return toType(tt$1.elem);
		} else if (_ref === 21) {
			tt$2 = t.mapType;
			return toType(tt$2.elem);
		} else if (_ref === 22) {
			tt$3 = t.ptrType;
			return toType(tt$3.elem);
		} else if (_ref === 23) {
			tt$4 = t.sliceType;
			return toType(tt$4.elem);
		}
		throw go$panic(new Go$String("reflect: Elem of invalid type"));
	};
	rtype.prototype.Elem = function() { return this.go$val.Elem(); };
 0Ç√  Çπ	rtype.Ptr.prototype.Field = function(i) {
		var t, tt, _struct;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: Field of non-struct type"));
		}
		tt = t.structType;
		return (_struct = tt.Field(i), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
	};
	rtype.prototype.Field = function(i) { return this.go$val.Field(i); };
 0Çˆ  ÇÏ	rtype.Ptr.prototype.FieldByIndex = function(index) {
		var t, tt, _struct;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByIndex of non-struct type"));
		}
		tt = t.structType;
		return (_struct = tt.FieldByIndex(index), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
	};
	rtype.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
 0ÇW  ÇM	rtype.Ptr.prototype.FieldByName = function(name) {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByName of non-struct type"));
		}
		tt = t.structType;
		return tt.FieldByName(name);
	};
	rtype.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
 0Ço  Çe	rtype.Ptr.prototype.FieldByNameFunc = function(match) {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: FieldByNameFunc of non-struct type"));
		}
		tt = t.structType;
		return tt.FieldByNameFunc(match);
	};
	rtype.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
 0Ç≈  Çª	rtype.Ptr.prototype.In = function(i) {
		var t, tt, _slice, _index;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: In of non-func type"));
		}
		tt = t.funcType;
		return toType((_slice = tt.in$2, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
	};
	rtype.prototype.In = function(i) { return this.go$val.In(i); };
 0Ç  Ç	rtype.Ptr.prototype.Key = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 21))) {
			throw go$panic(new Go$String("reflect: Key of non-map type"));
		}
		tt = t.mapType;
		return toType(tt.key);
	};
	rtype.prototype.Key = function() { return this.go$val.Key(); };
 0Ç"  Ç	rtype.Ptr.prototype.Len = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 17))) {
			throw go$panic(new Go$String("reflect: Len of non-array type"));
		}
		tt = t.arrayType;
		return (tt.len >> 0);
	};
	rtype.prototype.Len = function() { return this.go$val.Len(); };
 0Ç;  Ç1	rtype.Ptr.prototype.NumField = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 25))) {
			throw go$panic(new Go$String("reflect: NumField of non-struct type"));
		}
		tt = t.structType;
		return tt.fields.length;
	};
	rtype.prototype.NumField = function() { return this.go$val.NumField(); };
 0Ç)  Ç	rtype.Ptr.prototype.NumIn = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: NumIn of non-func type"));
		}
		tt = t.funcType;
		return tt.in$2.length;
	};
	rtype.prototype.NumIn = function() { return this.go$val.NumIn(); };
 0Ç,  Ç"	rtype.Ptr.prototype.NumOut = function() {
		var t, tt;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: NumOut of non-func type"));
		}
		tt = t.funcType;
		return tt.out.length;
	};
	rtype.prototype.NumOut = function() { return this.go$val.NumOut(); };
 0Ç»  Çæ	rtype.Ptr.prototype.Out = function(i) {
		var t, tt, _slice, _index;
		t = this;
		if (!((t.Kind() === 19))) {
			throw go$panic(new Go$String("reflect: Out of non-func type"));
		}
		tt = t.funcType;
		return toType((_slice = tt.out, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
	};
	rtype.prototype.Out = function(i) { return this.go$val.Out(i); };
 0Ç~  Çt	ChanDir.prototype.String = function() {
		var d, _ref;
		d = this.go$val;
		_ref = d;
		if (_ref === 2) {
			return "chan<-";
		} else if (_ref === 1) {
			return "<-chan";
		} else if (_ref === 3) {
			return "chan";
		}
		return "ChanDir" + strconv.Itoa((d >> 0));
	};
	go$ptrType(ChanDir).prototype.String = function() { return new ChanDir(this.go$get()).String(); };
 0Ç
  Ç 	interfaceType.Ptr.prototype.Method = function(i) {
		var m, t, _struct, _struct$1, _slice, _index, p, _struct$2, _struct$3;
		m = new Method.Ptr();
		t = this;
		if (i < 0 || i >= t.methods.length) {
			return (_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index));
		}
		p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		m.Name = p.name.go$get();
		if (!(go$pointerIsEqual(p.pkgPath, (go$ptrType(Go$String)).nil))) {
			m.PkgPath = p.pkgPath.go$get();
		}
		m.Type = toType(p.typ);
		m.Index = i;
		return (_struct$2 = m, new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index));
	};
	interfaceType.prototype.Method = function(i) { return this.go$val.Method(i); };
 0Å»  Åø	interfaceType.Ptr.prototype.NumMethod = function() {
		var t;
		t = this;
		return t.methods.length;
	};
	interfaceType.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
 0ÇE  Ç;	interfaceType.Ptr.prototype.MethodByName = function(name) {
		var m, ok, t, _struct, _struct$1, p, _ref, _i, i, _slice, _index, _struct$2, _struct$3, _tuple, _struct$4, _struct$5, _struct$6, _struct$7;
		m = new Method.Ptr();
		ok = false;
		t = this;
		if (t === (go$ptrType(interfaceType)).nil) {
			return [(_struct = m, new Method.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, (_struct$1 = _struct.Func, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), _struct.Index)), ok];
		}
		p = (go$ptrType(imethod)).nil;
		_ref = t.methods;
		_i = 0;
		while (_i < _ref.length) {
			i = _i;
			p = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (p.name.go$get() === name) {
				_tuple = [(_struct$2 = t.Method(i), new Method.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, (_struct$3 = _struct$2.Func, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), _struct$2.Index)), true], m = _tuple[0], ok = _tuple[1];
				return [(_struct$4 = m, new Method.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, (_struct$5 = _struct$4.Func, new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)), _struct$4.Index)), ok];
			}
			_i++;
		}
		return [(_struct$6 = m, new Method.Ptr(_struct$6.Name, _struct$6.PkgPath, _struct$6.Type, (_struct$7 = _struct$6.Func, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), _struct$6.Index)), ok];
	};
	interfaceType.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
 0Çî  Çä	StructTag.prototype.Get = function(key) {
		var tag, i, name, qvalue, _tuple, value;
		tag = this.go$val;
		while (!(tag === "")) {
			i = 0;
			while (i < tag.length && (tag.charCodeAt(i) === 32)) {
				i = i + 1 >> 0;
			}
			tag = tag.substring(i);
			if (tag === "") {
				break;
			}
			i = 0;
			while (i < tag.length && !((tag.charCodeAt(i) === 32)) && !((tag.charCodeAt(i) === 58)) && !((tag.charCodeAt(i) === 34))) {
				i = i + 1 >> 0;
			}
			if ((i + 1 >> 0) >= tag.length || !((tag.charCodeAt(i) === 58)) || !((tag.charCodeAt((i + 1 >> 0)) === 34))) {
				break;
			}
			name = tag.substring(0, i);
			tag = tag.substring((i + 1 >> 0));
			i = 1;
			while (i < tag.length && !((tag.charCodeAt(i) === 34))) {
				if (tag.charCodeAt(i) === 92) {
					i = i + 1 >> 0;
				}
				i = i + 1 >> 0;
			}
			if (i >= tag.length) {
				break;
			}
			qvalue = tag.substring(0, (i + 1 >> 0));
			tag = tag.substring((i + 1 >> 0));
			if (key === name) {
				_tuple = strconv.Unquote(qvalue), value = _tuple[0];
				return value;
			}
		}
		return "";
	};
	go$ptrType(StructTag).prototype.Get = function(key) { return new StructTag(this.go$get()).Get(key); };
 0Ç  Ç	structType.Ptr.prototype.Field = function(i) {
		var f, t, _struct, _slice, _index, p, t$1, _struct$1;
		f = new StructField.Ptr();
		t = this;
		if (i < 0 || i >= t.fields.length) {
			return (_struct = f, new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
		}
		p = (_slice = t.fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		f.Type = toType(p.typ);
		if (!(go$pointerIsEqual(p.name, (go$ptrType(Go$String)).nil))) {
			f.Name = p.name.go$get();
		} else {
			t$1 = f.Type;
			if (t$1.Kind() === 22) {
				t$1 = t$1.Elem();
			}
			f.Name = t$1.Name();
			f.Anonymous = true;
		}
		if (!(go$pointerIsEqual(p.pkgPath, (go$ptrType(Go$String)).nil))) {
			f.PkgPath = p.pkgPath.go$get();
		}
		if (!(go$pointerIsEqual(p.tag, (go$ptrType(Go$String)).nil))) {
			f.Tag = p.tag.go$get();
		}
		f.Offset = p.offset;
		f.Index = new (go$sliceType(Go$Int))([i]);
		return (_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
	};
	structType.prototype.Field = function(i) { return this.go$val.Field(i); };
 0Ç   Çˆ	structType.Ptr.prototype.FieldByIndex = function(index) {
		var f, t, _ref, _i, _slice, _index, x, i, ft, _struct, _struct$1;
		f = new StructField.Ptr();
		t = this;
		f.Type = toType(t.rtype);
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				ft = f.Type;
				if ((ft.Kind() === 22) && (ft.Elem().Kind() === 25)) {
					ft = ft.Elem();
				}
				f.Type = ft;
			}
			f = (_struct = f.Type.Field(x), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous));
			_i++;
		}
		return (_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous));
	};
	structType.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
 0Çb  ÇX	structType.Ptr.prototype.FieldByNameFunc = function(match) {
		var result, ok, t, current, next, nextCount, _map, _key, visited, _tuple, count, _ref, _i, _slice, _index, _struct, scan, t$1, _entry, _key$1, _ref$1, _i$1, i, _slice$1, _index$1, f, fname, ntyp, _entry$1, _tuple$1, _struct$1, _struct$2, styp, _entry$2, _key$2, _map$1, _key$3, _key$4, _entry$3, _key$5, index, _struct$3;
		result = new StructField.Ptr();
		ok = false;
		t = this;
		current = new (go$sliceType(fieldScan))([]);
		next = new (go$sliceType(fieldScan))([new fieldScan.Ptr(t, (go$sliceType(Go$Int)).nil)]);
		nextCount = false;
		visited = (_map = new Go$Map(), _map);
		while (next.length > 0) {
			_tuple = [next, go$subslice(current, 0, 0)], current = _tuple[0], next = _tuple[1];
			count = nextCount;
			nextCount = false;
			_ref = current;
			_i = 0;
			while (_i < _ref.length) {
				scan = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new fieldScan.Ptr(_struct.typ, _struct.index));
				t$1 = scan.typ;
				if ((_entry = visited[t$1.go$key()], _entry !== undefined ? _entry.v : false)) {
					_i++;
					continue;
				}
				_key$1 = t$1, (visited || go$throwRuntimeError("assignment to entry in nil map"))[_key$1.go$key()] = { k: _key$1, v: true };
				_ref$1 = t$1.fields;
				_i$1 = 0;
				while (_i$1 < _ref$1.length) {
					i = _i$1;
					f = (_slice$1 = t$1.fields, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
					fname = "";
					ntyp = (go$ptrType(rtype)).nil;
					if (!(go$pointerIsEqual(f.name, (go$ptrType(Go$String)).nil))) {
						fname = f.name.go$get();
					} else {
						ntyp = f.typ;
						if (ntyp.Kind() === 22) {
							ntyp = ntyp.Elem().common();
						}
						fname = ntyp.Name();
					}
					if (match(fname)) {
						if ((_entry$1 = count[t$1.go$key()], _entry$1 !== undefined ? _entry$1.v : 0) > 1 || ok) {
							_tuple$1 = [new StructField.Ptr("", "", null, "", 0, (go$sliceType(Go$Int)).nil, false), false], result = _tuple$1[0], ok = _tuple$1[1];
							return [(_struct$1 = result, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok];
						}
						result = (_struct$2 = t$1.Field(i), new StructField.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, _struct$2.Tag, _struct$2.Offset, _struct$2.Index, _struct$2.Anonymous));
						result.Index = (go$sliceType(Go$Int)).nil;
						result.Index = go$appendSlice(result.Index, scan.index);
						result.Index = go$append(result.Index, i);
						ok = true;
						_i$1++;
						continue;
					}
					if (ok || ntyp === (go$ptrType(rtype)).nil || !((ntyp.Kind() === 25))) {
						_i$1++;
						continue;
					}
					styp = ntyp.structType;
					if ((_entry$2 = nextCount[styp.go$key()], _entry$2 !== undefined ? _entry$2.v : 0) > 0) {
						_key$2 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$2.go$key()] = { k: _key$2, v: 2 };
						_i$1++;
						continue;
					}
					if (nextCount === false) {
						nextCount = (_map$1 = new Go$Map(), _map$1);
					}
					_key$4 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$4.go$key()] = { k: _key$4, v: 1 };
					if ((_entry$3 = count[t$1.go$key()], _entry$3 !== undefined ? _entry$3.v : 0) > 1) {
						_key$5 = styp, (nextCount || go$throwRuntimeError("assignment to entry in nil map"))[_key$5.go$key()] = { k: _key$5, v: 2 };
					}
					index = (go$sliceType(Go$Int)).nil;
					index = go$appendSlice(index, scan.index);
					index = go$append(index, i);
					next = go$append(next, new fieldScan.Ptr(styp, index));
					_i$1++;
				}
				_i++;
			}
			if (ok) {
				break;
			}
		}
		return [(_struct$3 = result, new StructField.Ptr(_struct$3.Name, _struct$3.PkgPath, _struct$3.Type, _struct$3.Tag, _struct$3.Offset, _struct$3.Index, _struct$3.Anonymous)), ok];
	};
	structType.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
 0ÇQ  ÇG	structType.Ptr.prototype.FieldByName = function(name) {
		var f, present, t, hasAnon, _ref, _i, i, _slice, _index, tf, _struct, _tuple, _struct$1, _struct$2, _tuple$1, _struct$3, _struct$4;
		f = new StructField.Ptr();
		present = false;
		t = this;
		hasAnon = false;
		if (!(name === "")) {
			_ref = t.fields;
			_i = 0;
			while (_i < _ref.length) {
				i = _i;
				tf = (_slice = t.fields, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (go$pointerIsEqual(tf.name, (go$ptrType(Go$String)).nil)) {
					hasAnon = true;
					_i++;
					continue;
				}
				if (tf.name.go$get() === name) {
					_tuple = [(_struct = t.Field(i), new StructField.Ptr(_struct.Name, _struct.PkgPath, _struct.Type, _struct.Tag, _struct.Offset, _struct.Index, _struct.Anonymous)), true], f = _tuple[0], present = _tuple[1];
					return [(_struct$1 = f, new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), present];
				}
				_i++;
			}
		}
		if (!hasAnon) {
			return [(_struct$2 = f, new StructField.Ptr(_struct$2.Name, _struct$2.PkgPath, _struct$2.Type, _struct$2.Tag, _struct$2.Offset, _struct$2.Index, _struct$2.Anonymous)), present];
		}
		_tuple$1 = t.FieldByNameFunc((function(s) {
			return s === name;
		})), f = (_struct$3 = _tuple$1[0], new StructField.Ptr(_struct$3.Name, _struct$3.PkgPath, _struct$3.Type, _struct$3.Tag, _struct$3.Offset, _struct$3.Index, _struct$3.Anonymous)), present = _tuple$1[1];
		return [(_struct$4 = f, new StructField.Ptr(_struct$4.Name, _struct$4.PkgPath, _struct$4.Type, _struct$4.Tag, _struct$4.Offset, _struct$4.Index, _struct$4.Anonymous)), present];
	};
	structType.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
 0ÅÔ TypeOfÅ‡	TypeOf = go$pkg.TypeOf = function(i) {
			if (i === null) {
				return null;
			}
			if (i.constructor.kind === undefined) { // js.Object
				return Go$String.reflectType();
			}
			return i.constructor.reflectType();
		};
 0Åº PtrToÅÆ	PtrTo = go$pkg.PtrTo = function(t) {
		return (t !== null && t.constructor === (go$ptrType(rtype)) ? t.go$val : go$typeAssertionFailed(t, (go$ptrType(rtype)))).ptrTo();
	};
 0ÅÆ  Å•	rtype.Ptr.prototype.ptrTo = function() {
			return go$ptrType(this.jsType).reflectType();
		};
	rtype.prototype.ptrTo = function() { return this.go$val.ptrTo(); };
 0Çµ fnv1Çß	fnv1 = function(x, list) {
		var _ref, _i, _slice, _index, b, x$1;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			x = ((x$1 = 16777619, (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0) ^ (b >>> 0)) >>> 0;
			_i++;
		}
		return x;
	};
 0Ç)  Ç	rtype.Ptr.prototype.Implements = function(u) {
		var t;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.Implements"));
		}
		if (!((u.Kind() === 20))) {
			throw go$panic(new Go$String("reflect: non-interface type passed to Type.Implements"));
		}
		return implements$1((u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype)))), t);
	};
	rtype.prototype.Implements = function(u) { return this.go$val.Implements(u); };
 0Ç‡  Ç÷	rtype.Ptr.prototype.AssignableTo = function(u) {
		var t, uu;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.AssignableTo"));
		}
		uu = (u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype))));
		return directlyAssignable(uu, t) || implements$1(uu, t);
	};
	rtype.prototype.AssignableTo = function(u) { return this.go$val.AssignableTo(u); };
 0Ç„  ÇŸ	rtype.Ptr.prototype.ConvertibleTo = function(u) {
		var t, uu;
		t = this;
		if (go$interfaceIsEqual(u, null)) {
			throw go$panic(new Go$String("reflect: nil type passed to Type.ConvertibleTo"));
		}
		uu = (u !== null && u.constructor === (go$ptrType(rtype)) ? u.go$val : go$typeAssertionFailed(u, (go$ptrType(rtype))));
		return !(convertOp(uu, t) === go$throwNilPointerError);
	};
	rtype.prototype.ConvertibleTo = function(u) { return this.go$val.ConvertibleTo(u); };
 0Ç	 implements$1ÇÛ	implements$1 = function(T, V) {
		var t, v, i, j, _slice, _index, tm, _slice$1, _index$1, vm, v$1, i$1, j$1, _slice$2, _index$2, tm$1, _slice$3, _index$3, vm$1;
		if (!((T.Kind() === 20))) {
			return false;
		}
		t = T.interfaceType;
		if (t.methods.length === 0) {
			return true;
		}
		if (V.Kind() === 20) {
			v = V.interfaceType;
			i = 0;
			j = 0;
			while (j < v.methods.length) {
				tm = (_slice = t.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				vm = (_slice$1 = v.methods, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (go$pointerIsEqual(vm.name, tm.name) && go$pointerIsEqual(vm.pkgPath, tm.pkgPath) && vm.typ === tm.typ) {
					if (i = i + 1 >> 0, i >= t.methods.length) {
						return true;
					}
				}
				j = j + 1 >> 0;
			}
			return false;
		}
		v$1 = V.uncommonType.uncommon();
		if (v$1 === (go$ptrType(uncommonType)).nil) {
			return false;
		}
		i$1 = 0;
		j$1 = 0;
		while (j$1 < v$1.methods.length) {
			tm$1 = (_slice$2 = t.methods, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			vm$1 = (_slice$3 = v$1.methods, _index$3 = j$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			if (go$pointerIsEqual(vm$1.name, tm$1.name) && go$pointerIsEqual(vm$1.pkgPath, tm$1.pkgPath) && vm$1.mtyp === tm$1.typ) {
				if (i$1 = i$1 + 1 >> 0, i$1 >= t.methods.length) {
					return true;
				}
			}
			j$1 = j$1 + 1 >> 0;
		}
		return false;
	};
 0Å¸ directlyAssignableÅ·	directlyAssignable = function(T, V) {
		if (T === V) {
			return true;
		}
		if (!(T.Name() === "") && !(V.Name() === "") || !((T.Kind() === V.Kind()))) {
			return false;
		}
		return haveIdenticalUnderlyingType(T, V);
	};
 0Çx haveIdenticalUnderlyingTypeÇS	haveIdenticalUnderlyingType = function(T, V) {
		var kind, _ref, t, v, _ref$1, _i, _slice, _index, typ, i, _slice$1, _index$1, _ref$2, _i$1, _slice$2, _index$2, typ$1, i$1, _slice$3, _index$3, t$1, v$1, t$2, v$2, _ref$3, _i$2, i$2, _slice$4, _index$4, tf, _slice$5, _index$5, vf;
		if (T === V) {
			return true;
		}
		kind = T.Kind();
		if (!((kind === V.Kind()))) {
			return false;
		}
		if (1 <= kind && kind <= 16 || (kind === 24) || (kind === 26)) {
			return true;
		}
		_ref = kind;
		if (_ref === 17) {
			return go$interfaceIsEqual(T.Elem(), V.Elem()) && (T.Len() === V.Len());
		} else if (_ref === 18) {
			if ((V.ChanDir() === 3) && go$interfaceIsEqual(T.Elem(), V.Elem())) {
				return true;
			}
			return (V.ChanDir() === T.ChanDir()) && go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 19) {
			t = T.funcType;
			v = V.funcType;
			if (!(t.dotdotdot === v.dotdotdot) || !((t.in$2.length === v.in$2.length)) || !((t.out.length === v.out.length))) {
				return false;
			}
			_ref$1 = t.in$2;
			_i = 0;
			while (_i < _ref$1.length) {
				typ = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				i = _i;
				if (!(typ === (_slice$1 = v.in$2, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")))) {
					return false;
				}
				_i++;
			}
			_ref$2 = t.out;
			_i$1 = 0;
			while (_i$1 < _ref$2.length) {
				typ$1 = (_slice$2 = _ref$2, _index$2 = _i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
				i$1 = _i$1;
				if (!(typ$1 === (_slice$3 = v.out, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")))) {
					return false;
				}
				_i$1++;
			}
			return true;
		} else if (_ref === 20) {
			t$1 = T.interfaceType;
			v$1 = V.interfaceType;
			if ((t$1.methods.length === 0) && (v$1.methods.length === 0)) {
				return true;
			}
			return false;
		} else if (_ref === 21) {
			return go$interfaceIsEqual(T.Key(), V.Key()) && go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 22 || _ref === 23) {
			return go$interfaceIsEqual(T.Elem(), V.Elem());
		} else if (_ref === 25) {
			t$2 = T.structType;
			v$2 = V.structType;
			if (!((t$2.fields.length === v$2.fields.length))) {
				return false;
			}
			_ref$3 = t$2.fields;
			_i$2 = 0;
			while (_i$2 < _ref$3.length) {
				i$2 = _i$2;
				tf = (_slice$4 = t$2.fields, _index$4 = i$2, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
				vf = (_slice$5 = v$2.fields, _index$5 = i$2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
				if (!(go$pointerIsEqual(tf.name, vf.name)) && (go$pointerIsEqual(tf.name, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.name, (go$ptrType(Go$String)).nil) || !(tf.name.go$get() === vf.name.go$get()))) {
					return false;
				}
				if (!(go$pointerIsEqual(tf.pkgPath, vf.pkgPath)) && (go$pointerIsEqual(tf.pkgPath, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.pkgPath, (go$ptrType(Go$String)).nil) || !(tf.pkgPath.go$get() === vf.pkgPath.go$get()))) {
					return false;
				}
				if (!(tf.typ === vf.typ)) {
					return false;
				}
				if (!(go$pointerIsEqual(tf.tag, vf.tag)) && (go$pointerIsEqual(tf.tag, (go$ptrType(Go$String)).nil) || go$pointerIsEqual(vf.tag, (go$ptrType(Go$String)).nil) || !(tf.tag.go$get() === vf.tag.go$get()))) {
					return false;
				}
				if (!((tf.offset === vf.offset))) {
					return false;
				}
				_i$2++;
			}
			return true;
		}
		return false;
	};
 0o 	typelinks^	typelinks = function() {
		throw go$panic("Native function not implemented: typelinks");
	};
 0Çz typesByStringÇc	typesByString = function(s) {
		var typ, _tuple, i, j, _q, h, _slice, _index, _slice$1, _index$1;
		typ = typelinks();
		_tuple = [0, typ.length], i = _tuple[0], j = _tuple[1];
		while (i < j) {
			h = i + (_q = ((j - i >> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0;
			if (!((_slice = typ, _index = h, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).string.go$get() >= s)) {
				i = h + 1 >> 0;
			} else {
				j = h;
			}
		}
		j = i;
		while (j < typ.length && (_slice$1 = typ, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).string.go$get() === s) {
			j = j + 1 >> 0;
		}
		return go$subslice(typ, i, j);
	};
 0Çâ cacheGetÇw	cacheGet = function(k) {
		var _entry, t, _entry$1;
		lookupCache.RWMutex.RLock();
		t = (_entry = lookupCache.m[(new cacheKey(k)).go$key()], _entry !== undefined ? _entry.v : (go$ptrType(rtype)).nil);
		lookupCache.RWMutex.RUnlock();
		if (!(t === (go$ptrType(rtype)).nil)) {
			return t;
		}
		lookupCache.RWMutex.Lock();
		t = (_entry$1 = lookupCache.m[(new cacheKey(k)).go$key()], _entry$1 !== undefined ? _entry$1.v : (go$ptrType(rtype)).nil);
		if (!(t === (go$ptrType(rtype)).nil)) {
			lookupCache.RWMutex.Unlock();
			return t;
		}
		if (lookupCache.m === false) {
			lookupCache.m = new Go$Map();
		}
		return null;
	};
 0ÇQ cachePutÇ?	cachePut = function(k, t) {
		var _key, _struct;
		_key = (_struct = k, new cacheKey.Ptr(_struct.kind, _struct.t1, _struct.t2, _struct.extra)), (lookupCache.m || go$throwRuntimeError("assignment to entry in nil map"))[(new cacheKey(_key)).go$key()] = { k: _key, v: t };
		lookupCache.RWMutex.Unlock();
		return t;
	};
 0Åí ChanOfÅÉ	ChanOf = go$pkg.ChanOf = function(dir, t) {
			return go$chanType(t.jsType, dir === SendDir, dir === RecvDir).reflectType();
		};
 0l ismapkey\	ismapkey = function() {
		throw go$panic("Native function not implemented: ismapkey");
	};
 0Ç MapOfÅˇ	MapOf = go$pkg.MapOf = function(key, elem) {
			switch (key.Kind()) {
			case Func:
			case Map:
			case Slice:
				throw go$panic("reflect.MapOf: invalid key type " + key.String());
			}
			return go$mapType(key.jsType, elem.jsType).reflectType();
		};
 0Ç0 bucketOfÇ	bucketOf = function(ktyp, etyp) {
		var x, x$1, ptrsize, gc, offset, x$2, x$3, _slice, _index, _slice$1, _index$1, b, s, v;
		if (ktyp.size > 128) {
			ktyp = (x = PtrTo(ktyp), (x !== null && x.constructor === (go$ptrType(rtype)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(rtype)))));
		}
		if (etyp.size > 128) {
			etyp = (x$1 = PtrTo(etyp), (x$1 !== null && x$1.constructor === (go$ptrType(rtype)) ? x$1.go$val : go$typeAssertionFailed(x$1, (go$ptrType(rtype)))));
		}
		ptrsize = 4;
		gc = (go$sliceType(Go$Uintptr)).make(1, 0, function() { return 0; });
		offset = 8;
		gc = go$append(gc, 1, offset, 0);
		offset = offset + (ptrsize) >>> 0;
		if (((ktyp.kind & 128) >>> 0) === 0) {
			gc = go$append(gc, 3, offset, 8, ktyp.size);
			gc = appendGCProgram(gc, ktyp);
			gc = go$append(gc, 4);
		}
		offset = offset + ((x$2 = ktyp.size, (((8 >>> 16 << 16) * x$2 >>> 0) + (8 << 16 >>> 16) * x$2) >>> 0)) >>> 0;
		if (((etyp.kind & 128) >>> 0) === 0) {
			gc = go$append(gc, 3, offset, 8, etyp.size);
			gc = appendGCProgram(gc, etyp);
			gc = go$append(gc, 4);
		}
		offset = offset + ((x$3 = etyp.size, (((8 >>> 16 << 16) * x$3 >>> 0) + (8 << 16 >>> 16) * x$3) >>> 0)) >>> 0;
		gc = go$append(gc, 0);
		_slice = gc, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = offset) : go$throwRuntimeError("index out of range");
		_slice$1 = gc, _index$1 = 3, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = go$sliceToArray(gc)) : go$throwRuntimeError("index out of range");
		b = new rtype.Ptr();
		b.size = offset;
		b.gc = go$sliceToArray(gc);
		s = "bucket(" + ktyp.string.go$get() + "," + etyp.string.go$get() + ")";
		b.string = new (go$ptrType(Go$String))(function() { return s; }, function(v) { s = v; });
		return b;
	};
 0Ç appendGCProgramÇˇ	appendGCProgram = function(gc, t) {
		var p, argcnt, _ref, i;
		p = t.gc;
		p = (p + 4 >>> 0);
		loop:
		while (true) {
			argcnt = 0;
			_ref = p.go$get();
			if (_ref === 0) {
				break loop;
			} else if (_ref === 4) {
				argcnt = 0;
			} else if (_ref === 2 || _ref === 7 || _ref === 8 || _ref === 9) {
				argcnt = 1;
			} else if (_ref === 1 || _ref === 5 || _ref === 6 || _ref === 10) {
				argcnt = 2;
			} else if (_ref === 3 || _ref === 11) {
				argcnt = 3;
			} else {
				throw go$panic(new Go$String("unknown GC program op for " + t.string.go$get() + ": " + strconv.FormatUint(p.go$get(), 10)));
			}
			i = 0;
			while (i < (argcnt + 1 >> 0)) {
				gc = go$append(gc, p.go$get());
				p = (p + 4 >>> 0);
				i = i + 1 >> 0;
			}
		}
		return gc;
	};
 0Ç› hMapOfÇÕ	hMapOf = function(bucket) {
		var ptrsize, gc, offset, x, _q, x$1, x$2, _q$1, _slice, _index, h, s, v;
		ptrsize = 4;
		gc = (go$sliceType(Go$Uintptr)).make(1, 0, function() { return 0; });
		offset = 4;
		offset = offset + 4 >>> 0;
		offset = offset + 4 >>> 0;
		offset = offset + 1 >>> 0;
		offset = offset + 1 >>> 0;
		offset = offset + 1 >>> 0;
		offset = (x = (_q = ((offset + 1 >>> 0)) / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero")), x$1 = 2, (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0);
		offset = offset + 2 >>> 0;
		offset = (x$2 = (_q$1 = (((offset + ptrsize >>> 0) - 1 >>> 0)) / ptrsize, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >>> 0 : go$throwRuntimeError("integer divide by zero")), (((x$2 >>> 16 << 16) * ptrsize >>> 0) + (x$2 << 16 >>> 16) * ptrsize) >>> 0);
		gc = go$append(gc, 1, offset, bucket.gc);
		offset = offset + (ptrsize) >>> 0;
		gc = go$append(gc, 1, offset, bucket.gc);
		offset = offset + (ptrsize) >>> 0;
		offset = offset + (ptrsize) >>> 0;
		gc = go$append(gc, 0);
		_slice = gc, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = offset) : go$throwRuntimeError("index out of range");
		h = new rtype.Ptr();
		h.size = offset;
		h.gc = go$sliceToArray(gc);
		s = "hmap(" + bucket.string.go$get() + ")";
		h.string = new (go$ptrType(Go$String))(function() { return s; }, function(v) { s = v; });
		return h;
	};
 0n SliceOf_	SliceOf = go$pkg.SliceOf = function(t) {
			return go$sliceType(t.jsType).reflectType();
		};
 0c arrayOfT	arrayOf = function(n, t) {
			return go$arrayType(t.jsType, n).reflectType();
		};
 0q toTypec	toType = function(t) {
		if (t === (go$ptrType(rtype)).nil) {
			return null;
		}
		return t;
	};
 0ÇZ memmoveÇI	memmove = function(adst, asrc, n) {
		var dst, src, i, i$1, i$2;
		dst = adst;
		src = asrc;
		if (src < dst && (src + n >>> 0) > dst) {
			i = n;
			while (i > 0) {
				i = i - 1 >>> 0;
				(dst + i >>> 0).go$set((src + i >>> 0).go$get());
			}
		} else if (!(((((((((n | src) >>> 0) | dst) >>> 0)) & 3) >>> 0) === 0))) {
			i$1 = 0;
			while (i$1 < n) {
				(dst + i$1 >>> 0).go$set((src + i$1 >>> 0).go$get());
				i$1 = i$1 + 1 >>> 0;
			}
		} else {
			i$2 = 0;
			while (i$2 < n) {
				(dst + i$2 >>> 0).go$set((src + i$2 >>> 0).go$get());
				i$2 = i$2 + 4 >>> 0;
			}
		}
	};
 0Å⁄  Å—	flag.prototype.kind = function() {
		var f;
		f = this.go$val;
		return (((((f >>> 4 >>> 0)) & 31) >>> 0) >>> 0);
	};
	go$ptrType(flag).prototype.kind = function() { return new flag(this.go$get()).kind(); };
 0ÇN  ÇD	ValueError.Ptr.prototype.Error = function() {
		var e;
		e = this;
		if (e.Kind === 0) {
			return "reflect: call of " + e.Method + " on zero Value";
		}
		return "reflect: call of " + e.Method + " on " + (new Kind(e.Kind)).String() + " Value";
	};
	ValueError.prototype.Error = function() { return this.go$val.Error(); };
 0G 
methodName5	methodName = function() {
			return "?FIXME?";
		};
 0Ç  Ç	Value.Ptr.prototype.iword = function() {
			if ((this.flag & flagIndir) !== 0 && this.typ.Kind() !== Array && this.typ.Kind() !== Struct) {
				return this.val.go$get();
			}
			return this.val;
		};
	Value.prototype.iword = function() { return this.go$val.iword(); };
 0Ç◊ 	loadIwordÇƒ	loadIword = function(p, n) {
		var w, _ref, v, v$1, v$2, v$3, v$4, v$5, v$6, v$7;
		w = 0;
		_ref = n;
		if (_ref === 0) {
		} else if (_ref === 1) {
			new (go$ptrType(iword))(function() { return w; }, function(v) { w = v; }).go$set(p.go$get());
		} else if (_ref === 2) {
			new (go$ptrType(iword))(function() { return w; }, function(v$1) { w = v$1; }).go$set(p.go$get());
		} else if (_ref === 3) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$2) { w = v$2; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 4) {
			new (go$ptrType(iword))(function() { return w; }, function(v$3) { w = v$3; }).go$set(p.go$get());
		} else if (_ref === 5) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$4) { w = v$4; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 6) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$5) { w = v$5; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 7) {
			go$copyArray(new (go$ptrType(iword))(function() { return w; }, function(v$6) { w = v$6; }), go$mapArray(p, function(entry) { return entry; }));
		} else if (_ref === 8) {
			new (go$ptrType(iword))(function() { return w; }, function(v$7) { w = v$7; }).go$set(p.go$get());
		} else {
			throw go$panic(new Go$String("reflect: internal error: loadIword of " + strconv.Itoa((n >> 0)) + "-byte value"));
		}
		return w;
	};
 0Ç 
storeIwordÇ	storeIword = function(p, w, n) {
		var _ref;
		_ref = n;
		if (_ref === 0) {
		} else if (_ref === 1) {
			p.go$set(w);
		} else if (_ref === 2) {
			p.go$set(w);
		} else if (_ref === 3) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 4) {
			p.go$set(w);
		} else if (_ref === 5) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 6) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 7) {
			go$copyArray(p, go$mapArray(w, function(entry) { return entry; }));
		} else if (_ref === 8) {
			p.go$set(w);
		} else {
			throw go$panic(new Go$String("reflect: internal error: storeIword of " + strconv.Itoa((n >> 0)) + "-byte value"));
		}
	};
 0Ç>  Ç4	flag.prototype.mustBe = function(expected) {
		var f, k;
		f = this.go$val;
		k = (new flag(f)).kind();
		if (!((k === expected))) {
			throw go$panic(new ValueError.Ptr(methodName(), k));
		}
	};
	go$ptrType(flag).prototype.mustBe = function(expected) { return new flag(this.go$get()).mustBe(expected); };
 0Ç™  Ç†	flag.prototype.mustBeExported = function() {
		var f;
		f = this.go$val;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr(methodName(), 0));
		}
		if (!((((f & 1) >>> 0) === 0))) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
	};
	go$ptrType(flag).prototype.mustBeExported = function() { return new flag(this.go$get()).mustBeExported(); };
 0Ç0  Ç&	flag.prototype.mustBeAssignable = function() {
		var f;
		f = this.go$val;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr(methodName(), 0));
		}
		if (!((((f & 1) >>> 0) === 0))) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using value obtained using unexported field"));
		}
		if (((f & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect: " + methodName() + " using unaddressable value"));
		}
	};
	go$ptrType(flag).prototype.mustBeAssignable = function() { return new flag(this.go$get()).mustBeAssignable(); };
 0Ç¶  Çú	Value.Ptr.prototype.Addr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (((v.flag & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect.Value.Addr of unaddressable value"));
		}
		return new Value.Ptr(v.typ.ptrTo(), v.val, ((((v.flag & 1) >>> 0)) | 352) >>> 0);
	};
	Value.prototype.Addr = function() { return this.go$val.Addr(); };
 0ÇR  ÇH	Value.Ptr.prototype.Bool = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(1);
		if (!((((v.flag & 2) >>> 0) === 0))) {
			return v.val.go$get();
		}
		return v.val;
	};
	Value.prototype.Bool = function() { return this.go$val.Bool(); };
 0Ç  Ç	Value.Ptr.prototype.Bytes = function() {
			this.mustBe(Slice);
			if (this.typ.Elem().Kind() !== Uint8) {
				throw go$panic("reflect.Value.Bytes of non-byte slice");
			}
			return this.iword();
		};
	Value.prototype.Bytes = function() { return this.go$val.Bytes(); };
 0Ç  Ç	Value.Ptr.prototype.runes = function() {
			this.mustBe(Slice);
			if (this.typ.Elem().Kind() !== Int32) {
				throw new go$panic("reflect.Value.Bytes of non-rune slice");
			}
			return this.iword();
		};
	Value.prototype.runes = function() { return this.go$val.runes(); };
 0Ç  Ç	Value.Ptr.prototype.CanAddr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return !((((v.flag & 4) >>> 0) === 0));
	};
	Value.prototype.CanAddr = function() { return this.go$val.CanAddr(); };
 0Ç  Å¸	Value.Ptr.prototype.CanSet = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return ((v.flag & 5) >>> 0) === 4;
	};
	Value.prototype.CanSet = function() { return this.go$val.CanSet(); };
 0ÇN  ÇD	Value.Ptr.prototype.Call = function(in$1) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(19);
		(new flag(v.flag)).mustBeExported();
		return v.call("Call", in$1);
	};
	Value.prototype.Call = function(in$1) { return this.go$val.Call(in$1); };
 0Çb  ÇX	Value.Ptr.prototype.CallSlice = function(in$1) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(19);
		(new flag(v.flag)).mustBeExported();
		return v.call("CallSlice", in$1);
	};
	Value.prototype.CallSlice = function(in$1) { return this.go$val.CallSlice(in$1); };
 0Ç
Ï  Ç
‚	Value.Ptr.prototype.call = function(op, args) {
			var t = this.typ, fn, rcvr;

			if ((this.flag & flagMethod) !== 0) {
				var tuple = methodReceiver(op, this, this.flag >> flagMethodShift);
				t = tuple[0];
				fn = tuple[1];
				rcvr = tuple[2];
			} else {
				fn = this.iword();
			}

			if (fn === go$throwNilPointerError) {
				throw go$panic("reflect.Value.Call: call of nil function");
			}

			var isSlice = (op === "CallSlice");
			var n = t.NumIn();
			if (isSlice) {
				if (!t.IsVariadic()) {
					throw go$panic("reflect: CallSlice of non-variadic function");
				}
				if (args.length < n) {
					throw go$panic("reflect: CallSlice with too few input arguments");
				}
				if (args.length > n) {
					throw go$panic("reflect: CallSlice with too many input arguments");
				}
			} else {
				if (t.IsVariadic()) {
					n--;
				}
				if (args.length < n) {
					throw go$panic("reflect: Call with too few input arguments");
				}
				if (!t.IsVariadic() && args.length > n) {
					throw go$panic("reflect: Call with too many input arguments");
				}
			}
			var i;
			for (i = 0; i < args.length; i++) {
				if (args.array[args.offset + i].Kind() === Invalid) {
					throw go$panic("reflect: " + op + " using zero Value argument");
				}
			}
			for (i = 0; i < n; i++) {
				var xt = args.array[args.offset + i].Type(), targ = t.In(i);
				if (!xt.AssignableTo(targ)) {
					throw go$panic("reflect: " + op + " using " + xt.String() + " as type " + targ.String());
				}
			}
			if (!isSlice && t.IsVariadic()) {
				var m = args.length - n;
				var slice = MakeSlice(t.In(n), m, m);
				var elem = t.In(n).Elem();
				for (i = 0; i < m; i++) {
					var x = args.array[args.offset + n + i];
					var xt = x.Type();
					if (!xt.AssignableTo(elem)) {
						throw go$panic("reflect: cannot use " + xt.String() + " as type " + elem.String() + " in " + op);
					}
					slice.Index(i).Set(x);
				}
				args = new (go$sliceType(Value))(go$sliceToArray(args).slice(0, n).concat([slice]));
			}

			if (args.length !== t.NumIn()) {
				throw go$panic("reflect.Value.Call: wrong argument count");
			}

			var argsArray = new Go$Array(t.NumIn());
			for (i = 0; i < t.NumIn(); i++) {
				argsArray[i] = args.array[args.offset + i].assignTo("reflect.Value.Call", t.In(i), go$ptrType(go$emptyInterface).nil).iword();
			}
			var results = fn.apply(rcvr, argsArray);
			if (t.NumOut() === 0) {
				results = [];
			} else if (t.NumOut() === 1) {
				results = [results];
			}
			for (i = 0; i < t.NumOut(); i++) {
				var typ = t.Out(i);
				var flag = typ.Kind() << flagKindShift;
				results[i] = new Value.Ptr(typ, results[i], flag);
			}
			return new (go$sliceType(Value))(results);
		};
	Value.prototype.call = function(op, in$1) { return this.go$val.call(op, in$1); };
 0Ç callReflectÇ
ˇ	callReflect = function(ctxt, frame) {
		var ftyp, f, ptr, off, in$1, _ref, _i, _slice, _index, arg, typ, v, _struct, out, _ref$1, _i$1, _slice$1, _index$1, arg$1, i, typ$1, _slice$2, _index$2, _struct$1, v$1, _slice$3, _index$3, addr;
		ftyp = ctxt.typ;
		f = ctxt.fn;
		ptr = frame;
		off = 0;
		in$1 = (go$sliceType(Value)).make(0, ftyp.in$2.length, function() { return new Value.Ptr(); });
		_ref = ftyp.in$2;
		_i = 0;
		while (_i < _ref.length) {
			arg = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			typ = arg;
			off = off + ((((-off >>> 0) & ((typ.align - 1 << 24 >>> 24) >>> 0)) >>> 0)) >>> 0;
			v = new Value.Ptr(typ, 0, (typ.Kind() >>> 0) << 4 >>> 0);
			if (typ.size <= 4) {
				v.val = loadIword((ptr + off >>> 0), typ.size);
			} else {
				v.val = unsafe_New(typ);
				memmove(v.val, (ptr + off >>> 0), typ.size);
				v.flag = (v.flag | 2) >>> 0;
			}
			in$1 = go$append(in$1, (_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
			off = off + (typ.size) >>> 0;
			_i++;
		}
		out = f(in$1);
		if (!((out.length === ftyp.out.length))) {
			throw go$panic(new Go$String("reflect: wrong return count from function created by MakeFunc"));
		}
		if (ftyp.out.length > 0) {
			off = off + ((((-off >>> 0) & 3) >>> 0)) >>> 0;
			_ref$1 = ftyp.out;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				arg$1 = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				i = _i$1;
				typ$1 = arg$1;
				v$1 = (_struct$1 = (_slice$2 = out, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				if (!(v$1.typ === typ$1)) {
					throw go$panic(new Go$String("reflect: function created by MakeFunc using " + funcName(f) + " returned wrong type: have " + (_slice$3 = out, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).typ.String() + " for " + typ$1.String()));
				}
				if (!((((v$1.flag & 1) >>> 0) === 0))) {
					throw go$panic(new Go$String("reflect: function created by MakeFunc using " + funcName(f) + " returned value obtained from unexported field"));
				}
				off = off + ((((-off >>> 0) & ((typ$1.align - 1 << 24 >>> 24) >>> 0)) >>> 0)) >>> 0;
				addr = (ptr + off >>> 0);
				if (((v$1.flag & 2) >>> 0) === 0) {
					storeIword(addr, v$1.val, typ$1.size);
				} else {
					memmove(addr, v$1.val, typ$1.size);
				}
				off = off + (typ$1.size) >>> 0;
				_i$1++;
			}
		}
	};
 0Çˆ methodReceiverÇﬁ	methodReceiver = function(op, v, i) {
			var m, t;
			if (v.typ.Kind() === Interface) {
				var tt = v.typ.interfaceType;
				if (i < 0 || i >= tt.methods.length) {
					throw go$panic("reflect: internal error: invalid method index");
				}
				if (v.IsNil()) {
					throw go$panic("reflect: " + op + " of method on nil interface value");
				}
				m = tt.methods.array[i];
				t = m.typ;
			} else {
				var ut = v.typ.uncommon();
				if (ut === uncommonType.Ptr.nil || i < 0 || i >= ut.methods.length) {
					throw go$panic("reflect: internal error: invalid method index");
				}
				m = ut.methods.array[i];
				t = m.mtyp;
			}
			if (m.pkgPath.go$get !== go$throwNilPointerError) {
				throw go$panic("reflect: " + op + " of unexported method");
			}
			var name = m.name.go$get()
			if (go$reservedKeywords.indexOf(name) !== -1) {
				name += "$";
			}
			var rcvr = v.iword();
			if (isWrapped(v.typ)) {
				rcvr = new v.typ.jsType(rcvr);
			}
			return [t, rcvr[name], rcvr];
		};
 0d alignW	align = function(x, n) {
		return (((x + n >>> 0) - 1 >>> 0)) & ~((n - 1 >>> 0));
	};
 0ÇF 	frameSizeÇ3	frameSize = function(t, rcvr) {
		var total, in$1, outOffset, out, nin, i, tv, nout, i$1, tv$1;
		total = 0;
		in$1 = 0;
		outOffset = 0;
		out = 0;
		if (rcvr) {
			total = total + 4 >>> 0;
		}
		nin = t.NumIn();
		in$1 = -total >>> 0;
		i = 0;
		while (i < nin) {
			tv = t.In(i);
			total = align(total, (tv.Align() >>> 0));
			total = total + (tv.Size()) >>> 0;
			i = i + 1 >> 0;
		}
		in$1 = in$1 + (total) >>> 0;
		total = align(total, 4);
		nout = t.NumOut();
		outOffset = total;
		out = -total >>> 0;
		i$1 = 0;
		while (i$1 < nout) {
			tv$1 = t.Out(i$1);
			total = align(total, (tv$1.Align() >>> 0));
			total = total + (tv$1.Size()) >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		out = out + (total) >>> 0;
		if (total < 4) {
			total = 4;
		}
		total = align(total, 4);
		return [total, in$1, outOffset, out];
	};
 0Ç 
callMethodÇÔ	callMethod = function(ctxt, frame) {
		var _tuple, _struct, t, fn, rcvr, _tuple$1, total, in$1, outOffset, out, _q, args, _slice, _index, base;
		_tuple = methodReceiver("call", (_struct = ctxt.rcvr, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), ctxt.method), t = _tuple[0], fn = _tuple[1], rcvr = _tuple[2];
		_tuple$1 = frameSize(t, true), total = _tuple$1[0], in$1 = _tuple$1[1], outOffset = _tuple$1[2], out = _tuple$1[3];
		args = (go$sliceType(Go$UnsafePointer)).make((_q = total / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >>> 0 : go$throwRuntimeError("integer divide by zero")), 0, function() { return 0; });
		_slice = args, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = rcvr) : go$throwRuntimeError("index out of range");
		base = go$sliceToArray(args);
		memmove((base + 4 >>> 0), frame, in$1);
		call(fn, go$sliceToArray(args), (total >>> 0));
		memmove(((frame + outOffset >>> 0) - 4 >>> 0), (base + outOffset >>> 0), out);
	};
 0Åƒ funcNameÅ≥	funcName = function(f) {
		var pc, rf;
		pc = f;
		rf = runtime.FuncForPC(pc);
		if (!(rf === (go$ptrType(runtime.Func)).nil)) {
			return rf.Name();
		}
		return "closure";
	};
 0Ç  Ç	Value.Ptr.prototype.Cap = function() {
			var k = this.kind();
			switch (k) {
			case Slice:
				return this.iword().capacity;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Cap", k));
		};
	Value.prototype.Cap = function() { return this.go$val.Cap(); };
 0Ç>  Ç4	Value.Ptr.prototype.Close = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		chanclose(v.iword());
	};
	Value.prototype.Close = function() { return this.go$val.Close(); };
 0Åõ  Åí	Value.Ptr.prototype.Complex = function() {
			return this.iword();
		};
	Value.prototype.Complex = function() { return this.go$val.Complex(); };
 0Ç¢  Çò	Value.Ptr.prototype.Elem = function() {
			switch (this.kind()) {
			case Interface:
				var val = this.iword();
				if (val === null) {
					return new Value.Ptr();
				}
				if (val.constructor.kind === undefined) { // js.Object
					return new Value.Ptr(Go$String.reflectType(), String(val), String << flagKindShift);
				}
				var typ = val.constructor.reflectType();
				var fl = this.flag & flagRO;
				fl |= typ.Kind() << flagKindShift;
				return new Value.Ptr(typ, val.go$val, fl);

			case Ptr:
				var val = this.iword();
				if (this.IsNil()) {
					return new Value.Ptr();
				}
				var tt = this.typ.ptrType;
				var fl = (this.flag & flagRO) | flagIndir | flagAddr;
				fl |= tt.elem.Kind() << flagKindShift;
				return new Value.Ptr(tt.elem, val, fl);
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Elem", this.kind()));
		};
	Value.prototype.Elem = function() { return this.go$val.Elem(); };
 0Çd  ÇZ	Value.Ptr.prototype.Field = function(i) {
			this.mustBe(Struct);
			var tt = this.typ.structType;
			if (i < 0 || i >= tt.fields.length) {
				throw go$panic("reflect: Field index out of range");
			}
			var field = tt.fields.array[i];
			var name = fieldName(field, i);
			var typ = field.typ;
			var fl = this.flag & (flagRO | flagIndir | flagAddr);
			if (field.pkgPath.go$get !== go$throwNilPointerError) {
				fl |= flagRO;
			}
			fl |= typ.Kind() << flagKindShift;
			if ((this.flag & flagIndir) !== 0 && typ.Kind() !== Array && typ.Kind() !== Struct) {
				var struct = this.val;
				return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return struct[name]; }, function(v) { struct[name] = v; }), fl);
			}
			return new Value.Ptr(typ, this.val[name], fl);
		};
	Value.prototype.Field = function(i) { return this.go$val.Field(i); };
 0Çº  Ç≤	Value.Ptr.prototype.FieldByIndex = function(index) {
		var _struct, v, _ref, _i, _slice, _index, x, i, _struct$1, _struct$2, _struct$3;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		_ref = index;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (i > 0) {
				if ((v.Kind() === 22) && (v.Elem().Kind() === 25)) {
					v = (_struct$1 = v.Elem(), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
				}
			}
			v = (_struct$2 = v.Field(x), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
			_i++;
		}
		return (_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	Value.prototype.FieldByIndex = function(index) { return this.go$val.FieldByIndex(index); };
 0Ç’  ÇÀ	Value.Ptr.prototype.FieldByName = function(name) {
		var _struct, v, ok, _tuple, _struct$1, f, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		if (_tuple = v.typ.FieldByName(name), f = (_struct$1 = _tuple[0], new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok = _tuple[1], ok) {
			return (_struct$2 = v.FieldByIndex(f.Index), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
	};
	Value.prototype.FieldByName = function(name) { return this.go$val.FieldByName(name); };
 0ÇÈ  Çﬂ	Value.Ptr.prototype.FieldByNameFunc = function(match) {
		var _struct, v, ok, _tuple, _struct$1, f, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		if (_tuple = v.typ.FieldByNameFunc(match), f = (_struct$1 = _tuple[0], new StructField.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, _struct$1.Tag, _struct$1.Offset, _struct$1.Index, _struct$1.Anonymous)), ok = _tuple[1], ok) {
			return (_struct$2 = v.FieldByIndex(f.Index), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
	};
	Value.prototype.FieldByNameFunc = function(match) { return this.go$val.FieldByNameFunc(match); };
 0Çá  Ç}	Value.Ptr.prototype.Float = function() {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			if (!((((v.flag & 2) >>> 0) === 0))) {
				return go$float32frombits(go$float32bits(v.val.go$get()));
			}
			return go$float32frombits(go$float32bits(v.val));
		} else if (_ref === 14) {
			if (!((((v.flag & 2) >>> 0) === 0))) {
				return v.val.go$get();
			}
			return v.val;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Float", k));
	};
	Value.prototype.Float = function() { return this.go$val.Float(); };
 0ÇX  ÇN	Value.Ptr.prototype.Index = function(i) {
			var k = this.kind();
			switch (k) {
			case Array:
				var tt = this.typ.arrayType;
				if (i < 0 || i >= tt.len) {
					throw go$panic("reflect: array index out of range");
				}
				var typ = tt.elem;
				var fl = this.flag & (flagRO | flagIndir | flagAddr);
				fl |= typ.Kind() << flagKindShift;
				if ((this.flag & flagIndir) !== 0 && typ.Kind() !== Array && typ.Kind() !== Struct) {
					var array = this.val;
					return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return array[i]; }, function(v) { array[i] = v; }), fl);
				}
				return new Value.Ptr(typ, this.iword()[i], fl);
			case Slice:
				if (i < 0 || i >= this.iword().length) {
					throw go$panic("reflect: slice index out of range");
				}
				var typ = this.typ.sliceType.elem;
				var fl = flagAddr | flagIndir | (this.flag & flagRO);
				fl |= typ.Kind() << flagKindShift;
				i += this.iword().offset;
				var array = this.iword().array;
				if (typ.Kind() === Struct) {
					return new Value.Ptr(typ, array[i], fl);
				}
				return new Value.Ptr(typ, new (go$ptrType(typ.jsType))(function() { return array[i]; }, function(v) { array[i] = v; }), fl);
			case String:
				var string = this.iword();
				if (i < 0 || i >= string.length) {
					throw go$panic("reflect: string index out of range");
				}
				var fl = (this.flag & flagRO) | (Uint8 << flagKindShift);
				return new Value.Ptr(uint8Type, string.charCodeAt(i), fl);
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Index", k));
		};
	Value.prototype.Index = function(i) { return this.go$val.Index(i); };
 0ÇB  Ç8	Value.Ptr.prototype.Int = function() {
		var _struct, v, k, p, v$1, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		p = 0;
		if (!((((v.flag & 2) >>> 0) === 0))) {
			p = v.val;
		} else {
			p = new (go$ptrType(Go$UnsafePointer))(function() { return v.val; }, function(v$1) { v.val = v$1; });
		}
		_ref = k;
		if (_ref === 2) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 3) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 4) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 5) {
			return new Go$Int64(0, p.go$get());
		} else if (_ref === 6) {
			return p.go$get();
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Int", k));
	};
	Value.prototype.Int = function() { return this.go$val.Int(); };
 0Çz  Çp	Value.Ptr.prototype.CanInterface = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.flag === 0) {
			throw go$panic(new ValueError.Ptr("reflect.Value.CanInterface", 0));
		}
		return ((v.flag & 1) >>> 0) === 0;
	};
	Value.prototype.CanInterface = function() { return this.go$val.CanInterface(); };
 0Çz  Çp	Value.Ptr.prototype.Interface = function() {
		var i, _struct, v, _struct$1;
		i = null;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		i = valueInterface((_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), true);
		return i;
	};
	Value.prototype.Interface = function() { return this.go$val.Interface(); };
 0ÇÒ valueInterfaceÇŸ	valueInterface = function(v, safe) {
			if (v.flag === 0) {
				throw go$panic(new ValueError.Ptr("reflect.Value.Interface", 0));
			}
			if (safe && (v.flag & flagRO) !== 0) {
				throw go$panic("reflect.Value.Interface: cannot return value obtained from unexported field or method")
			}
			if ((v.flag & flagMethod) !== 0) {
				v = makeMethodValue("Interface", v);
			}
			if (isWrapped(v.typ)) {
				return new v.typ.jsType(v.iword());
			}
			return v.iword();
		};
 0ÇW  ÇM	Value.Ptr.prototype.InterfaceData = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(20);
		return go$mapArray(v.val, function(entry) { return entry; });
	};
	Value.prototype.InterfaceData = function() { return this.go$val.InterfaceData(); };
 0ÇÎ  Ç·	Value.Ptr.prototype.IsNil = function() {
			switch (this.kind()) {
			case Chan:
			case Ptr:
			case Slice:
				return this.iword() === this.typ.jsType.nil;
			case Func:
				return this.iword() === go$throwNilPointerError;
			case Map:
				return this.iword() === false;
			case Interface:
				return this.iword() === null;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.IsNil", this.kind()));
		};
	Value.prototype.IsNil = function() { return this.go$val.IsNil(); };
 0Åˇ  Åˆ	Value.Ptr.prototype.IsValid = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return !((v.flag === 0));
	};
	Value.prototype.IsValid = function() { return this.go$val.IsValid(); };
 0Å˛  Åı	Value.Ptr.prototype.Kind = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		return (new flag(v.flag)).kind();
	};
	Value.prototype.Kind = function() { return this.go$val.Kind(); };
 0Çh  Ç^	Value.Ptr.prototype.Len = function() {
			var k = this.kind();
			switch (k) {
			case Array:
			case Slice:
			case String:
				return this.iword().length;
			case Map:
				return go$keys(this.iword()).length;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Len", k));
		};
	Value.prototype.Len = function() { return this.go$val.Len(); };
 0Çl  Çb	Value.Ptr.prototype.MapIndex = function(key) {
		var _struct, v, tt, _struct$1, _tuple, word, ok, typ, fl;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		tt = v.typ.mapType;
		key = (_struct$1 = key.assignTo("reflect.Value.MapIndex", tt.key, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		_tuple = mapaccess(v.typ, v.iword(), key.iword()), word = _tuple[0], ok = _tuple[1];
		if (!ok) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		typ = tt.elem;
		fl = ((((v.flag | key.flag) >>> 0)) & 1) >>> 0;
		if (typ.size > 4) {
			fl = (fl | 2) >>> 0;
		}
		fl = (fl | (((typ.Kind() >>> 0) << 4 >>> 0))) >>> 0;
		return new Value.Ptr(typ, word, fl);
	};
	Value.prototype.MapIndex = function(key) { return this.go$val.MapIndex(key); };
 0ÇS  ÇI	Value.Ptr.prototype.MapKeys = function() {
		var _struct, v, tt, keyType, fl, m, mlen, it, a, i, _tuple, keyWord, ok, _slice, _index;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		tt = v.typ.mapType;
		keyType = tt.key;
		fl = (v.flag & 1) >>> 0;
		fl = (fl | (((keyType.Kind() >>> 0) << 4 >>> 0))) >>> 0;
		if (keyType.size > 4) {
			fl = (fl | 2) >>> 0;
		}
		m = v.iword();
		mlen = 0;
		if (!(m === 0)) {
			mlen = maplen(m);
		}
		it = mapiterinit(v.typ, m);
		a = (go$sliceType(Value)).make(mlen, 0, function() { return new Value.Ptr(); });
		i = 0;
		i = 0;
		while (i < a.length) {
			_tuple = mapiterkey(it), keyWord = _tuple[0], ok = _tuple[1];
			if (!ok) {
				break;
			}
			_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = new Value.Ptr(keyType, keyWord, fl)) : go$throwRuntimeError("index out of range");
			mapiternext(it);
			i = i + 1 >> 0;
		}
		return go$subslice(a, 0, i);
	};
	Value.prototype.MapKeys = function() { return this.go$val.MapKeys(); };
 0Ç  Ç˝	Value.Ptr.prototype.Method = function(i) {
		var _struct, v, fl;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.Method", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0)) || i < 0 || i >= v.typ.NumMethod()) {
			throw go$panic(new Go$String("reflect: Method index out of range"));
		}
		if ((v.typ.Kind() === 20) && v.IsNil()) {
			throw go$panic(new Go$String("reflect: Method on nil interface value"));
		}
		fl = (v.flag & 3) >>> 0;
		fl = (fl | 304) >>> 0;
		fl = (fl | (((((i >>> 0) << 9 >>> 0) | 8) >>> 0))) >>> 0;
		return new Value.Ptr(v.typ, v.val, fl);
	};
	Value.prototype.Method = function(i) { return this.go$val.Method(i); };
 0Ç¥  Ç™	Value.Ptr.prototype.NumMethod = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.NumMethod", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0))) {
			return 0;
		}
		return v.typ.NumMethod();
	};
	Value.prototype.NumMethod = function() { return this.go$val.NumMethod(); };
 0Çº  Ç≤	Value.Ptr.prototype.MethodByName = function(name) {
		var _struct, v, _tuple, _struct$1, _struct$2, m, ok, _struct$3;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.MethodByName", 0));
		}
		if (!((((v.flag & 8) >>> 0) === 0))) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		_tuple = v.typ.MethodByName(name), m = (_struct$1 = _tuple[0], new Method.Ptr(_struct$1.Name, _struct$1.PkgPath, _struct$1.Type, (_struct$2 = _struct$1.Func, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), _struct$1.Index)), ok = _tuple[1];
		if (!ok) {
			return new Value.Ptr((go$ptrType(rtype)).nil, 0, 0);
		}
		return (_struct$3 = v.Method(m.Index), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
	Value.prototype.MethodByName = function(name) { return this.go$val.MethodByName(name); };
 0Ç@  Ç6	Value.Ptr.prototype.NumField = function() {
		var _struct, v, tt;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(25);
		tt = v.typ.structType;
		return tt.fields.length;
	};
	Value.prototype.NumField = function() { return this.go$val.NumField(); };
 0Ç  Ç˘	Value.Ptr.prototype.OverflowComplex = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 15) {
			return overflowFloat32(x.real) || overflowFloat32(x.imag);
		} else if (_ref === 16) {
			return false;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowComplex", k));
	};
	Value.prototype.OverflowComplex = function(x) { return this.go$val.OverflowComplex(x); };
 0Ç€  Ç—	Value.Ptr.prototype.OverflowFloat = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			return overflowFloat32(x);
		} else if (_ref === 14) {
			return false;
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowFloat", k));
	};
	Value.prototype.OverflowFloat = function(x) { return this.go$val.OverflowFloat(x); };
 0Å† overflowFloat32Åà	overflowFloat32 = function(x) {
		if (x < 0) {
			x = -x;
		}
		return 3.4028234663852886e+38 < x && x <= 1.7976931348623157e+308;
	};
 0ÇÈ  Çﬂ	Value.Ptr.prototype.OverflowInt = function(x) {
		var _struct, v, k, _ref, x$1, x$2, bitSize, trunc;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			bitSize = (x$1 = v.typ.size, x$2 = 8, (((x$1 >>> 16 << 16) * x$2 >>> 0) + (x$1 << 16 >>> 16) * x$2) >>> 0);
			trunc = go$shiftRightInt64((go$shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.high === trunc.high && x.low === trunc.low));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowInt", k));
	};
	Value.prototype.OverflowInt = function(x) { return this.go$val.OverflowInt(x); };
 0Çˇ  Çı	Value.Ptr.prototype.OverflowUint = function(x) {
		var _struct, v, k, _ref, x$1, x$2, bitSize, trunc;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 7 || _ref === 12 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11) {
			bitSize = (x$1 = v.typ.size, x$2 = 8, (((x$1 >>> 16 << 16) * x$2 >>> 0) + (x$1 << 16 >>> 16) * x$2) >>> 0);
			trunc = go$shiftRightUint64((go$shiftLeft64(x, ((64 - bitSize >>> 0)))), ((64 - bitSize >>> 0)));
			return !((x.high === trunc.high && x.low === trunc.low));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.OverflowUint", k));
	};
	Value.prototype.OverflowUint = function(x) { return this.go$val.OverflowUint(x); };
 0Ç—  Ç«	Value.Ptr.prototype.Pointer = function() {
			var k = this.kind();
			switch (k) {
			case Chan:
			case Map:
			case Ptr:
			case Slice:
			case UnsafePointer:
				if (this.IsNil()) {
					return 0;
				}
				return this.iword();
			case Func:
				if (this.IsNil()) {
					return 0;
				}
				return 1;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.Pointer", k));
		};
	Value.prototype.Pointer = function() { return this.go$val.Pointer(); };
 0ÇN  ÇD	Value.Ptr.prototype.Recv = function() {
		var x, ok, _struct, v, _tuple, _struct$1, _struct$2;
		x = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		_tuple = v.recv(false), x = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok = _tuple[1];
		return [(_struct$2 = x, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), ok];
	};
	Value.prototype.Recv = function() { return this.go$val.Recv(); };
 0Ç4  Ç*	Value.Ptr.prototype.recv = function(nb) {
		var val, ok, _struct, v, tt, _tuple, word, selected, typ, fl, _struct$1;
		val = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		tt = v.typ.chanType;
		if (((tt.dir >> 0) & 1) === 0) {
			throw go$panic(new Go$String("reflect: recv on send-only channel"));
		}
		_tuple = chanrecv(v.typ, v.iword(), nb), word = _tuple[0], selected = _tuple[1], ok = _tuple[2];
		if (selected) {
			typ = tt.elem;
			fl = (typ.Kind() >>> 0) << 4 >>> 0;
			if (typ.size > 4) {
				fl = (fl | 2) >>> 0;
			}
			val = new Value.Ptr(typ, word, fl);
		}
		return [(_struct$1 = val, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok];
	};
	Value.prototype.recv = function(nb) { return this.go$val.recv(nb); };
 0Çê  ÇÜ	Value.Ptr.prototype.Send = function(x) {
		var _struct, v, _struct$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		v.send((_struct$1 = x, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), false);
	};
	Value.prototype.Send = function(x) { return this.go$val.Send(x); };
 0Ç∞  Ç¶	Value.Ptr.prototype.send = function(x, nb) {
		var selected, _struct, v, tt, _struct$1;
		selected = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		tt = v.typ.chanType;
		if (((tt.dir >> 0) & 2) === 0) {
			throw go$panic(new Go$String("reflect: send on recv-only channel"));
		}
		(new flag(x.flag)).mustBeExported();
		x = (_struct$1 = x.assignTo("reflect.Value.Send", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		selected = chansend(v.typ, v.iword(), x.iword(), nb);
		return selected;
	};
	Value.prototype.send = function(x, nb) { return this.go$val.send(x, nb); };
 0Ç,  Ç"	Value.Ptr.prototype.Set = function(x) {
			this.mustBeAssignable();
			x.mustBeExported();
			if ((this.flag & flagIndir) !== 0) {
				switch (this.typ.Kind()) {
				case Array:
					go$copyArray(this.val, x.val);
					return;
				case Interface:
					this.val.go$set(valueInterface(x, false));
					return;
				case Struct:
					copyStruct(this.val, x.val, this.typ);
					return;
				default:
					this.val.go$set(x.iword());
					return;
				}
			}
			this.val = x.val;
		};
	Value.prototype.Set = function(x) { return this.go$val.Set(x); };
 0ÇC  Ç9	Value.Ptr.prototype.SetBool = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(1);
		v.val.go$set(x);
	};
	Value.prototype.SetBool = function(x) { return this.go$val.SetBool(x); };
 0Ç¡  Ç∑	Value.Ptr.prototype.SetBytes = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(23);
		if (!((v.typ.Elem().Kind() === 8))) {
			throw go$panic(new Go$String("reflect.Value.SetBytes of non-byte slice"));
		}
		v.val.go$set(x);
	};
	Value.prototype.SetBytes = function(x) { return this.go$val.SetBytes(x); };
 0Ç¡  Ç∑	Value.Ptr.prototype.setRunes = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(23);
		if (!((v.typ.Elem().Kind() === 5))) {
			throw go$panic(new Go$String("reflect.Value.setRunes of non-rune slice"));
		}
		v.val.go$set(x);
	};
	Value.prototype.setRunes = function(x) { return this.go$val.setRunes(x); };
 0Çå  ÇÇ	Value.Ptr.prototype.SetComplex = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Complex64:
			case Complex128:
				this.val.go$set(new this.typ.jsType(x.real, x.imag));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetComplex", k));
		};
	Value.prototype.SetComplex = function(x) { return this.go$val.SetComplex(x); };
 0Çı  ÇÎ	Value.Ptr.prototype.SetFloat = function(x) {
		var _struct, v, k, _ref;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		k = (new flag(v.flag)).kind();
		_ref = k;
		if (_ref === 13) {
			v.val.go$set(x);
		} else if (_ref === 14) {
			v.val.go$set(x);
		} else {
			throw go$panic(new ValueError.Ptr("reflect.Value.SetFloat", k));
		}
	};
	Value.prototype.SetFloat = function(x) { return this.go$val.SetFloat(x); };
 0ÇŒ  Çƒ	Value.Ptr.prototype.SetInt = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Int:
			case Int8:
			case Int16:
			case Int32:
				this.val.go$set(go$flatten64(x));
				return;
			case Int64:
				this.val.go$set(new this.typ.jsType(x.high, x.low));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetInt", k));
		};
	Value.prototype.SetInt = function(x) { return this.go$val.SetInt(x); };
 0ÇË  Çﬁ	Value.Ptr.prototype.SetLen = function(n) {
			this.mustBeAssignable();
			this.mustBe(Slice);
			var s = this.val.go$get();
			if (n < 0 || n > s.capacity) {
				throw go$panic("reflect: slice length out of range in SetLen");
			}
			var newSlice = new this.typ.jsType(s.array);
			newSlice.offset = s.offset;
			newSlice.length = n;
			newSlice.capacity = s.capacity;
			this.val.go$set(newSlice);
		};
	Value.prototype.SetLen = function(n) { return this.go$val.SetLen(n); };
 0ÇÔ  ÇÂ	Value.Ptr.prototype.SetCap = function(n) {
			this.mustBeAssignable();
			this.mustBe(Slice);
			var s = this.val.go$get();
			if (n < s.length || n > s.capacity) {
				throw go$panic("reflect: slice capacity out of range in SetCap");
			}
			var newSlice = new this.typ.jsType(s.array);
			newSlice.offset = s.offset;
			newSlice.length = s.length;
			newSlice.capacity = n;
			this.val.go$set(newSlice);
		};
	Value.prototype.SetCap = function(n) { return this.go$val.SetCap(n); };
 0Ç¿  Ç∂	Value.Ptr.prototype.SetMapIndex = function(key, val) {
		var _struct, v, tt, _struct$1, _struct$2;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(21);
		(new flag(v.flag)).mustBeExported();
		(new flag(key.flag)).mustBeExported();
		tt = v.typ.mapType;
		key = (_struct$1 = key.assignTo("reflect.Value.SetMapIndex", tt.key, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		if (!(val.typ === (go$ptrType(rtype)).nil)) {
			(new flag(val.flag)).mustBeExported();
			val = (_struct$2 = val.assignTo("reflect.Value.SetMapIndex", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		mapassign(v.typ, v.iword(), key.iword(), val.iword(), !(val.typ === (go$ptrType(rtype)).nil));
	};
	Value.prototype.SetMapIndex = function(key, val) { return this.go$val.SetMapIndex(key, val); };
 0Çﬁ  Ç‘	Value.Ptr.prototype.SetUint = function(x) {
			this.mustBeAssignable();
			var k = this.kind();
			switch (k) {
			case Uint:
			case Uint8:
			case Uint16:
			case Uint32:
			case Uintptr:
				this.val.go$set(x.low);
				return;
			case Uint64:
				this.val.go$set(new this.typ.jsType(x.high, x.low));
				return;
			}
			throw go$panic(new ValueError.Ptr("reflect.Value.SetUint", k));
		};
	Value.prototype.SetUint = function(x) { return this.go$val.SetUint(x); };
 0ÇM  ÇC	Value.Ptr.prototype.SetPointer = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(26);
		v.val.go$set(x);
	};
	Value.prototype.SetPointer = function(x) { return this.go$val.SetPointer(x); };
 0ÇJ  Ç@	Value.Ptr.prototype.SetString = function(x) {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBeAssignable();
		(new flag(v.flag)).mustBe(24);
		v.val.go$set(x);
	};
	Value.prototype.SetString = function(x) { return this.go$val.SetString(x); };
 0Çb  ÇX	Value.Ptr.prototype.Slice = function(i, j) {
			var typ, s, cap;
			var kind = this.kind();
			switch (kind) {
			case Array:
				if ((this.flag & flagAddr) === 0) {
					throw go$panic("reflect.Value.Slice: slice of unaddressable array");
				}
				var tt = this.typ.arrayType;
				cap = tt.len;
				typ = SliceOf(tt.elem);
				s = new typ.jsType(this.iword());
				break;
			case Slice:
				typ = this.typ.sliceType;
				s = this.iword();
				cap = s.capacity;
				break;
			case String:
				s = this.iword();
				if (i < 0 || j < i || j > s.length) {
					throw go$panic("reflect.Value.Slice: string slice index out of bounds");
				}
				return new Value.Ptr(this.typ, s.substring(i, j), this.flag);
			default:
				throw go$panic(new ValueError.Ptr("reflect.Value.Slice", kind));
			}

			if (i < 0 || j < i || j > cap) {
				throw go$panic("reflect.Value.Slice: slice index out of bounds");
			}

			var fl = (this.flag & flagRO) | (Slice << flagKindShift);
			return new Value.Ptr(typ.common(), go$subslice(s, i, j), fl);
		};
	Value.prototype.Slice = function(i, j) { return this.go$val.Slice(i, j); };
 0Çó  Çç	Value.Ptr.prototype.Slice3 = function(i, j, k) {
			var typ, s, cap;
			var kind = this.kind();
			switch (kind) {
			case Array:
				if ((this.flag & flagAddr) === 0) {
					throw go$panic("reflect.Value.Slice3: slice of unaddressable array");
				}
				var tt = this.typ.arrayType;
				cap = tt.len;
				typ = SliceOf(tt.elem);
				s = new typ.jsType(this.iword());
				break;
			case Slice:
				typ = this.typ.sliceType;
				s = this.iword();
				cap = s.capacity;
				break;
			default:
				throw go$panic(new ValueError.Ptr("reflect.Value.Slice3", kind));
			}

			if (i < 0 || j < i || k < j || k > cap) {
				throw go$panic("reflect.Value.Slice3: slice index out of bounds");
			}

			var fl = (this.flag & flagRO) | (Slice << flagKindShift);
			return new Value.Ptr(typ.common(), go$subslice(s, i, j, k), fl);
		};
	Value.prototype.Slice3 = function(i, j, k) { return this.go$val.Slice3(i, j, k); };
 0Ç'  Ç	Value.Ptr.prototype.String = function() {
			switch (this.kind()) {
			case Invalid:
				return "<invalid Value>";
			case String:
				return this.iword();
			}
			return "<" + this.typ.String() + " Value>";
		};
	Value.prototype.String = function() { return this.go$val.String(); };
 0ÇV  ÇL	Value.Ptr.prototype.TryRecv = function() {
		var x, ok, _struct, v, _tuple, _struct$1, _struct$2;
		x = new Value.Ptr();
		ok = false;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		_tuple = v.recv(true), x = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), ok = _tuple[1];
		return [(_struct$2 = x, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), ok];
	};
	Value.prototype.TryRecv = function() { return this.go$val.TryRecv(); };
 0Çü  Çï	Value.Ptr.prototype.TrySend = function(x) {
		var _struct, v, _struct$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		(new flag(v.flag)).mustBe(18);
		(new flag(v.flag)).mustBeExported();
		return v.send((_struct$1 = x, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), true);
	};
	Value.prototype.TrySend = function(x) { return this.go$val.TrySend(x); };
 0Çﬁ  Ç‘	Value.Ptr.prototype.Type = function() {
		var _struct, v, f, i, tt, _slice, _index, m, ut, _slice$1, _index$1, m$1;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		f = v.flag;
		if (f === 0) {
			throw go$panic(new ValueError.Ptr("reflect.Value.Type", 0));
		}
		if (((f & 8) >>> 0) === 0) {
			return v.typ;
		}
		i = (v.flag >> 0) >> 9 >> 0;
		if (v.typ.Kind() === 20) {
			tt = v.typ.interfaceType;
			if (i < 0 || i >= tt.methods.length) {
				throw go$panic(new Go$String("reflect: internal error: invalid method index"));
			}
			m = (_slice = tt.methods, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			return m.typ;
		}
		ut = v.typ.uncommonType.uncommon();
		if (ut === (go$ptrType(uncommonType)).nil || i < 0 || i >= ut.methods.length) {
			throw go$panic(new Go$String("reflect: internal error: invalid method index"));
		}
		m$1 = (_slice$1 = ut.methods, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
		return m$1.mtyp;
	};
	Value.prototype.Type = function() { return this.go$val.Type(); };
 0Çª  Ç±	Value.Ptr.prototype.Uint = function() {
		var _struct, v, k, p, v$1, _ref, x;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		k = (new flag(v.flag)).kind();
		p = 0;
		if (!((((v.flag & 2) >>> 0) === 0))) {
			p = v.val;
		} else {
			p = new (go$ptrType(Go$UnsafePointer))(function() { return v.val; }, function(v$1) { v.val = v$1; });
		}
		_ref = k;
		if (_ref === 7) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 8) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 9) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 10) {
			return new Go$Uint64(0, p.go$get());
		} else if (_ref === 11) {
			return p.go$get();
		} else if (_ref === 12) {
			return (x = p.go$get(), new Go$Uint64(0, x.constructor === Number ? x : 1));
		}
		throw go$panic(new ValueError.Ptr("reflect.Value.Uint", k));
	};
	Value.prototype.Uint = function() { return this.go$val.Uint(); };
 0ÇÔ  ÇÂ	Value.Ptr.prototype.UnsafeAddr = function() {
		var _struct, v;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (v.typ === (go$ptrType(rtype)).nil) {
			throw go$panic(new ValueError.Ptr("reflect.Value.UnsafeAddr", 0));
		}
		if (((v.flag & 4) >>> 0) === 0) {
			throw go$panic(new Go$String("reflect.Value.UnsafeAddr of unaddressable value"));
		}
		return v.val;
	};
	Value.prototype.UnsafeAddr = function() { return this.go$val.UnsafeAddr(); };
 0Å∆ typesMustMatchÅØ	typesMustMatch = function(what, t1, t2) {
		if (!(go$interfaceIsEqual(t1, t2))) {
			throw go$panic(new Go$String(what + ": " + t1.String() + " != " + t2.String()));
		}
	};
 0Ç growÇ˘	grow = function(s, extra) {
		var i0, i1, m, _struct, _q, _struct$1, t, _struct$2, _struct$3, _struct$4;
		i0 = s.Len();
		i1 = i0 + extra >> 0;
		if (i1 < i0) {
			throw go$panic(new Go$String("reflect.Append: slice overflow"));
		}
		m = s.Cap();
		if (i1 <= m) {
			return [(_struct = s.Slice(0, i1), new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), i0, i1];
		}
		if (m === 0) {
			m = extra;
		} else {
			while (m < i1) {
				if (i0 < 1024) {
					m = m + (m) >> 0;
				} else {
					m = m + ((_q = m / 4, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"))) >> 0;
				}
			}
		}
		t = (_struct$1 = MakeSlice(s.Type(), i1, m), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		Copy((_struct$2 = t, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), (_struct$3 = s, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
		return [(_struct$4 = t, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag)), i0, i1];
	};
 0Çä AppendÇz	Append = go$pkg.Append = function(s, x) {
		var _tuple, _struct, _struct$1, i0, i1, _tuple$1, i, j, _tuple$2, _slice, _index, _struct$2, _struct$3;
		(new flag(s.flag)).mustBe(23);
		_tuple = grow((_struct = s, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), x.length), s = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), i0 = _tuple[1], i1 = _tuple[2];
		_tuple$1 = [i0, 0], i = _tuple$1[0], j = _tuple$1[1];
		while (i < i1) {
			s.Index(i).Set((_struct$2 = (_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)));
			_tuple$2 = [i + 1 >> 0, j + 1 >> 0], i = _tuple$2[0], j = _tuple$2[1];
		}
		return (_struct$3 = s, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
 0Ç	 AppendSliceÇÙ	AppendSlice = go$pkg.AppendSlice = function(s, t) {
		var _tuple, _struct, _struct$1, i0, i1, _struct$2, _struct$3, _struct$4;
		(new flag(s.flag)).mustBe(23);
		(new flag(t.flag)).mustBe(23);
		typesMustMatch("reflect.AppendSlice", s.Type().Elem(), t.Type().Elem());
		_tuple = grow((_struct = s, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), t.Len()), s = (_struct$1 = _tuple[0], new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), i0 = _tuple[1], i1 = _tuple[2];
		Copy((_struct$2 = s.Slice(i0, i1), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), (_struct$3 = t, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
		return (_struct$4 = s, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
	};
 0Ç CopyÇ˘	Copy = go$pkg.Copy = function(dst, src) {
			var dk = dst.kind();
			if (dk !== Array && dk !== Slice) {
				throw go$panic(new ValueError.Ptr("reflect.Copy", dk));
			}
			if (dk === Array) {
				dst.mustBeAssignable();
			}
			dst.mustBeExported();

			var sk = src.kind();
			if (sk !== Array && sk != Slice) {
				throw go$panic(new ValueError.Ptr("reflect.Copy", sk));
			}
			src.mustBeExported();

			typesMustMatch("reflect.Copy", dst.typ.Elem(), src.typ.Elem());

			var dstVal = dst.iword();
			if (dk === Array) {
				dstVal = new (go$sliceType(dst.typ.Elem().jsType))(dstVal);
			}
			var srcVal = src.iword();
			if (sk === Array) {
				srcVal = new (go$sliceType(src.typ.Elem().jsType))(srcVal);
			}
			return go$copySlice(dstVal, srcVal);
		};
 0i rselectZ	rselect = function() {
		throw go$panic("Native function not implemented: rselect");
	};
 0Ç< SelectÇ,	Select = go$pkg.Select = function(cases) {
		var chosen, recv, recvOK, runcases, haveDefault, _ref, _i, _slice, _index, _struct, _struct$1, _struct$2, c, i, _slice$1, _index$1, rc, _ref$1, _struct$3, ch, tt, _struct$4, v, _struct$5, _struct$6, ch$1, tt$1, _tuple, word, _slice$2, _index$2, _slice$3, _index$3, tt$2, typ, fl, _struct$7, _tuple$1, _struct$8;
		chosen = 0;
		recv = new Value.Ptr();
		recvOK = false;
		runcases = (go$sliceType(runtimeSelect)).make(cases.length, 0, function() { return new runtimeSelect.Ptr(); });
		haveDefault = false;
		_ref = cases;
		_i = 0;
		while (_i < _ref.length) {
			c = (_struct = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new SelectCase.Ptr(_struct.Dir, (_struct$1 = _struct.Chan, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)), (_struct$2 = _struct.Send, new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag))));
			i = _i;
			rc = (_slice$1 = runcases, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			rc.dir = (c.Dir >>> 0);
			_ref$1 = c.Dir;
			switch (0) { default: if (_ref$1 === 3) {
				if (haveDefault) {
					throw go$panic(new Go$String("reflect.Select: multiple default cases"));
				}
				haveDefault = true;
				if (c.Chan.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: default case has Chan value"));
				}
				if (c.Send.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: default case has Send value"));
				}
			} else if (_ref$1 === 1) {
				ch = (_struct$3 = c.Chan, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
				if (!ch.IsValid()) {
					break;
				}
				(new flag(ch.flag)).mustBe(18);
				(new flag(ch.flag)).mustBeExported();
				tt = ch.typ.chanType;
				if (((tt.dir >> 0) & 2) === 0) {
					throw go$panic(new Go$String("reflect.Select: SendDir case using recv-only channel"));
				}
				rc.ch = ch.iword();
				rc.typ = tt.rtype;
				v = (_struct$4 = c.Send, new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
				if (!v.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: SendDir case missing Send value"));
				}
				(new flag(v.flag)).mustBeExported();
				v = (_struct$5 = v.assignTo("reflect.Select", tt.elem, (go$ptrType(go$emptyInterface)).nil), new Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag));
				rc.val = v.iword();
			} else if (_ref$1 === 2) {
				if (c.Send.IsValid()) {
					throw go$panic(new Go$String("reflect.Select: RecvDir case has Send value"));
				}
				ch$1 = (_struct$6 = c.Chan, new Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag));
				if (!ch$1.IsValid()) {
					break;
				}
				(new flag(ch$1.flag)).mustBe(18);
				(new flag(ch$1.flag)).mustBeExported();
				tt$1 = ch$1.typ.chanType;
				rc.typ = tt$1.rtype;
				if (((tt$1.dir >> 0) & 1) === 0) {
					throw go$panic(new Go$String("reflect.Select: RecvDir case using send-only channel"));
				}
				rc.ch = ch$1.iword();
			} else {
				throw go$panic(new Go$String("reflect.Select: invalid Dir"));
			} }
			_i++;
		}
		_tuple = rselect(runcases), chosen = _tuple[0], word = _tuple[1], recvOK = _tuple[2];
		if ((_slice$2 = runcases, _index$2 = chosen, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).dir === 2) {
			tt$2 = (_slice$3 = runcases, _index$3 = chosen, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).typ.chanType;
			typ = tt$2.elem;
			fl = (typ.Kind() >>> 0) << 4 >>> 0;
			if (typ.size > 4) {
				fl = (fl | 2) >>> 0;
			}
			recv = new Value.Ptr(typ, word, fl);
		}
		_tuple$1 = [chosen, (_struct$7 = recv, new Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)), recvOK], chosen = _tuple$1[0], recv = _tuple$1[1], recvOK = _tuple$1[2];
		return [chosen, (_struct$8 = recv, new Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)), recvOK];
	};
 0Å˘ 
unsafe_NewÅÊ	unsafe_New = function(typ) {
			switch (typ.Kind()) {
			case Struct:
				return new typ.jsType.Ptr();
			case Array:
				return zeroVal(typ);
			default:
				return go$newDataPointer(zeroVal(typ), typ.ptrTo().jsType);
			}
		};
 0ÅÅ unsafe_NewArrayj	unsafe_NewArray = function() {
		throw go$panic("Native function not implemented: unsafe_NewArray");
	};
 0Ç  	MakeSliceÇ	MakeSlice = go$pkg.MakeSlice = function(typ, len, cap) {
			if (typ.Kind() !== Slice) {
				throw go$panic("reflect.MakeSlice of non-slice type");
			}
			if (len < 0) {
				throw go$panic("reflect.MakeSlice: negative len");
			}
			if (cap < 0) {
				throw go$panic("reflect.MakeSlice: negative cap");
			}
			if (len > cap) {
				throw go$panic("reflect.MakeSlice: len > cap");
			}
			return new Value.Ptr(typ.common(), typ.jsType.make(len, cap, function() { return zeroVal(typ.Elem()); }), Slice << flagKindShift);
		};
 0Çs MakeChanÇa	MakeChan = go$pkg.MakeChan = function(typ, buffer) {
		var ch;
		if (!((typ.Kind() === 18))) {
			throw go$panic(new Go$String("reflect.MakeChan of non-chan type"));
		}
		if (buffer < 0) {
			throw go$panic(new Go$String("reflect.MakeChan: negative buffer size"));
		}
		if (!((typ.ChanDir() === 3))) {
			throw go$panic(new Go$String("reflect.MakeChan: unidirectional channel type"));
		}
		ch = makechan((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))), new Go$Uint64(0, buffer));
		return new Value.Ptr(typ.common(), ch, 288);
	};
 0Çk MakeMapÇZ	MakeMap = go$pkg.MakeMap = function(typ) {
		var m;
		if (!((typ.Kind() === 21))) {
			throw go$panic(new Go$String("reflect.MakeMap of non-map type"));
		}
		m = makemap((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))));
		return new Value.Ptr(typ.common(), m, 336);
	};
 0Ç, IndirectÇ	Indirect = go$pkg.Indirect = function(v) {
		var _struct, _struct$1;
		if (!((v.Kind() === 22))) {
			return (_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		}
		return (_struct$1 = v.Elem(), new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
 0Çy ValueOfÇh	ValueOf = go$pkg.ValueOf = function(i) {
			if (i === null) {
				return new Value.Ptr();
			}
			if (i.constructor.kind === undefined) { // js.Object
				return new Value.Ptr(Go$String.reflectType(), String(i), String << flagKindShift);
			}
			var typ = i.constructor.reflectType();
			return new Value.Ptr(typ, i.go$val, typ.Kind() << flagKindShift);
		};
 0ÅÄ Zerot	Zero = go$pkg.Zero = function(typ) {
			return new Value.Ptr(typ, zeroVal(typ), typ.Kind() << flagKindShift);
		};
 0Çy NewÇl	New = go$pkg.New = function(typ) {
		var ptr, fl;
		if (go$interfaceIsEqual(typ, null)) {
			throw go$panic(new Go$String("reflect: New(nil)"));
		}
		ptr = unsafe_New((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))));
		fl = 352;
		return new Value.Ptr(typ.common().ptrTo(), ptr, fl);
	};
 0Åá NewAtz	NewAt = go$pkg.NewAt = function(typ, p) {
		var fl;
		fl = 352;
		return new Value.Ptr(typ.common().ptrTo(), p, fl);
	};
 0Ç  Ç
	Value.Ptr.prototype.assignTo = function(context, dst, target) {
		var _struct, v, _struct$1, _struct$2, fl, _struct$3, x;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (!((((v.flag & 8) >>> 0) === 0))) {
			v = (_struct$2 = makeMethodValue(context, (_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		if (directlyAssignable(dst, v.typ)) {
			v.typ = dst;
			fl = (v.flag & 7) >>> 0;
			fl = (fl | (((dst.Kind() >>> 0) << 4 >>> 0))) >>> 0;
			return new Value.Ptr(dst, v.val, fl);
		} else if (implements$1(dst, v.typ)) {
			if (target === (go$ptrType(go$emptyInterface)).nil) {
				target = go$newDataPointer(null, (go$ptrType(go$emptyInterface)));
			}
			x = valueInterface((_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), false);
			if (dst.NumMethod() === 0) {
				target.go$set(x);
			} else {
				ifaceE2I(dst, x, target);
			}
			return new Value.Ptr(dst, target, 322);
		}
		throw go$panic(new Go$String(context + ": value of type " + v.typ.String() + " is not assignable to type " + dst.String()));
	};
	Value.prototype.assignTo = function(context, dst, target) { return this.go$val.assignTo(context, dst, target); };
 0ÇÖ  Ç{	Value.Ptr.prototype.Convert = function(t) {
		var _struct, v, _struct$1, _struct$2, op, _struct$3, _struct$4;
		v = (_struct = this, new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		if (!((((v.flag & 8) >>> 0) === 0))) {
			v = (_struct$2 = makeMethodValue("Convert", (_struct$1 = v, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag))), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
		}
		op = convertOp(t.common(), v.typ);
		if (op === go$throwNilPointerError) {
			throw go$panic(new Go$String("reflect.Value.Convert: value of type " + v.typ.String() + " cannot be converted to type " + t.String()));
		}
		return (_struct$4 = op((_struct$3 = v, new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)), t), new Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag));
	};
	Value.prototype.Convert = function(t) { return this.go$val.Convert(t); };
 0Ç	ù 	convertOpÇ	ä	convertOp = function(dst, src) {
		var _ref, _ref$1, _ref$2, _ref$3, _ref$4, _ref$5, _ref$6;
		_ref = src.Kind();
		if (_ref === 2 || _ref === 3 || _ref === 4 || _ref === 5 || _ref === 6) {
			_ref$1 = dst.Kind();
			if (_ref$1 === 2 || _ref$1 === 3 || _ref$1 === 4 || _ref$1 === 5 || _ref$1 === 6 || _ref$1 === 7 || _ref$1 === 8 || _ref$1 === 9 || _ref$1 === 10 || _ref$1 === 11 || _ref$1 === 12) {
				return cvtInt;
			} else if (_ref$1 === 13 || _ref$1 === 14) {
				return cvtIntFloat;
			} else if (_ref$1 === 24) {
				return cvtIntString;
			}
		} else if (_ref === 7 || _ref === 8 || _ref === 9 || _ref === 10 || _ref === 11 || _ref === 12) {
			_ref$2 = dst.Kind();
			if (_ref$2 === 2 || _ref$2 === 3 || _ref$2 === 4 || _ref$2 === 5 || _ref$2 === 6 || _ref$2 === 7 || _ref$2 === 8 || _ref$2 === 9 || _ref$2 === 10 || _ref$2 === 11 || _ref$2 === 12) {
				return cvtUint;
			} else if (_ref$2 === 13 || _ref$2 === 14) {
				return cvtUintFloat;
			} else if (_ref$2 === 24) {
				return cvtUintString;
			}
		} else if (_ref === 13 || _ref === 14) {
			_ref$3 = dst.Kind();
			if (_ref$3 === 2 || _ref$3 === 3 || _ref$3 === 4 || _ref$3 === 5 || _ref$3 === 6) {
				return cvtFloatInt;
			} else if (_ref$3 === 7 || _ref$3 === 8 || _ref$3 === 9 || _ref$3 === 10 || _ref$3 === 11 || _ref$3 === 12) {
				return cvtFloatUint;
			} else if (_ref$3 === 13 || _ref$3 === 14) {
				return cvtFloat;
			}
		} else if (_ref === 15 || _ref === 16) {
			_ref$4 = dst.Kind();
			if (_ref$4 === 15 || _ref$4 === 16) {
				return cvtComplex;
			}
		} else if (_ref === 24) {
			if ((dst.Kind() === 23) && dst.Elem().PkgPath() === "") {
				_ref$5 = dst.Elem().Kind();
				if (_ref$5 === 8) {
					return cvtStringBytes;
				} else if (_ref$5 === 5) {
					return cvtStringRunes;
				}
			}
		} else if (_ref === 23) {
			if ((dst.Kind() === 24) && src.Elem().PkgPath() === "") {
				_ref$6 = src.Elem().Kind();
				if (_ref$6 === 8) {
					return cvtBytesString;
				} else if (_ref$6 === 5) {
					return cvtRunesString;
				}
			}
		}
		if (haveIdenticalUnderlyingType(dst, src)) {
			return cvtDirect;
		}
		if ((dst.Kind() === 22) && dst.Name() === "" && (src.Kind() === 22) && src.Name() === "" && haveIdenticalUnderlyingType(dst.Elem().common(), src.Elem().common())) {
			return cvtDirect;
		}
		if (implements$1(dst, src)) {
			if (src.Kind() === 20) {
				return cvtI2I;
			}
			return cvtT2I;
		}
		return go$throwNilPointerError;
	};
 0ÇP makeIntÇ?	makeInt = function(f, bits, typ) {
			var val;
			switch (typ.Kind()) {
			case Int8:
				val = bits.low << 24 >> 24;
				break;
			case Int16:
				val = bits.low << 16 >> 16;
				break;
			case Int:
			case Int32:
				val = bits.low >> 0;
				break;
			case Int64:
				return new Value.Ptr(typ, go$newDataPointer(new Go$Int64(bits.high, bits.low), typ.ptrTo().jsType), f | flagIndir | (Int64 << flagKindShift));
			case Uint8:
				val = bits.low << 24 >>> 24;
				break;
			case Uint16:
				val = bits.low << 16 >>> 16;
				break;
			case Uint64:
				return new Value.Ptr(typ, go$newDataPointer(bits, typ.ptrTo().jsType), f | flagIndir | (Int64 << flagKindShift));
			case Uint:
			case Uint32:
			case Uintptr:
				val = bits.low >>> 0;
				break;
			}
			return new Value.Ptr(typ, val, f | (typ.Kind() << flagKindShift));
		};
 0Çg 	makeFloatÇT	makeFloat = function(f, v, t) {
		var typ, ptr, w, _ref, v$1, v$2;
		typ = t.common();
		if (typ.size > 4) {
			ptr = unsafe_New(typ);
			ptr.go$set(v);
			return new Value.Ptr(typ, ptr, (((f | 2) >>> 0) | ((typ.Kind() >>> 0) << 4 >>> 0)) >>> 0);
		}
		w = 0;
		_ref = typ.size;
		if (_ref === 4) {
			new (go$ptrType(iword))(function() { return w; }, function(v$1) { w = v$1; }).go$set(v);
		} else if (_ref === 8) {
			new (go$ptrType(iword))(function() { return w; }, function(v$2) { w = v$2; }).go$set(v);
		}
		return new Value.Ptr(typ, w, (f | ((typ.Kind() >>> 0) << 4 >>> 0)) >>> 0);
	};
 0Åü makeComplexÅã	makeComplex = function(f, v, typ) {
			return new Value.Ptr(typ, new typ.jsType(v.real, v.imag), f | (typ.Kind() << flagKindShift));
		};
 0ÇJ 
makeStringÇ6	makeString = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.SetString(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
 0ÇG 	makeBytesÇ4	makeBytes = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.SetBytes(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
 0ÇG 	makeRunesÇ4	makeRunes = function(f, v, t) {
		var _struct, ret, _struct$1;
		ret = (_struct = New(t).Elem(), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
		ret.setRunes(v);
		ret.flag = ((ret.flag & ~4) | f) >>> 0;
		return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
	};
 0ÅŸ cvtIntÅ 	cvtInt = function(v, t) {
		var x, _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, (x = v.Int(), new Go$Uint64(x.high, x.low)), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Åµ cvtUintÅ•	cvtUint = function(v, t) {
		var _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, v.Uint(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Åˆ cvtFloatIntÅ‚	cvtFloatInt = function(v, t) {
		var x, _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, (x = new Go$Int64(0, v.Float()), new Go$Uint64(x.high, x.low)), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å“ cvtFloatUintÅΩ	cvtFloatUint = function(v, t) {
		var _struct;
		return (_struct = makeInt((v.flag & 1) >>> 0, new Go$Uint64(0, v.Float()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0ÅÃ cvtIntFloatÅ∏	cvtIntFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, go$flatten64(v.Int()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Åœ cvtUintFloatÅ∫	cvtUintFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, go$flatten64(v.Uint()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å∫ cvtFloatÅ©	cvtFloat = function(v, t) {
		var _struct;
		return (_struct = makeFloat((v.flag & 1) >>> 0, v.Float(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å¬ 
cvtComplexÅØ	cvtComplex = function(v, t) {
		var _struct;
		return (_struct = makeComplex((v.flag & 1) >>> 0, v.Complex(), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å‘ cvtIntStringÅø	cvtIntString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$encodeRune(v.Int().low), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å◊ cvtUintStringÅ¡	cvtUintString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$encodeRune(v.Uint().low), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0ÅŸ cvtBytesStringÅ¬	cvtBytesString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$bytesToString(v.Bytes()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å∫ cvtStringBytesÅ£	cvtStringBytes = function(v, typ) {
			return new Value.Ptr(typ, new typ.jsType(go$stringToBytes(v.iword())), (v.flag & flagRO) | (Slice << flagKindShift));
		};
 0ÅŸ cvtRunesStringÅ¬	cvtRunesString = function(v, t) {
		var _struct;
		return (_struct = makeString((v.flag & 1) >>> 0, go$runesToString(v.runes()), t), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
	};
 0Å∫ cvtStringRunesÅ£	cvtStringRunes = function(v, typ) {
			return new Value.Ptr(typ, new typ.jsType(go$stringToRunes(v.iword())), (v.flag & flagRO) | (Slice << flagKindShift));
		};
 0Ç 	cvtDirectÇ	cvtDirect = function(v, typ) {
			var srcVal = v.iword();
			if (srcVal === v.typ.jsType.nil) {
				return new Value.Ptr(typ, typ.jsType.nil, v.flag);
			}

			var val;
			switch (typ.Kind()) {
			case Chan:
				val = new typ.jsType();
				break;
			case Slice:
				val = new typ.jsType(srcVal.array);
				val.length = srcVal.length;
				val.cap = srcVal.cap;
				break;
			case Ptr:
				if (typ.Elem().Kind() === Struct) {
					if (typ.Elem() === v.typ.Elem()) {
						val = srcVal;
					}
					val = new typ.jsType();
					copyStruct(val, srcVal, typ.Elem());
					break;
				}
				val = new typ.jsType(srcVal.go$get, srcVal.go$set);
				break;
			case Struct:
				val = new typ.jsType.Ptr();
				copyStruct(val, srcVal, typ);
				break;
			case Array:
			case Func:
			case Interface:
			case Map:
			case String:
				val = srcVal;
				break;
			default:
				throw go$panic(new ValueError.Ptr("reflect.Convert", typ.Kind()));
			}
			return new Value.Ptr(typ, val, (v.flag & flagRO) | (typ.Kind() << flagKindShift));
		};
 0Ç) cvtT2IÇ	cvtT2I = function(v, typ) {
		var target, _struct, x;
		target = go$newDataPointer(null, (go$ptrType(go$emptyInterface)));
		x = valueInterface((_struct = v, new Value.Ptr(_struct.typ, _struct.val, _struct.flag)), false);
		if (typ.NumMethod() === 0) {
			target.go$set(x);
		} else {
			ifaceE2I((typ !== null && typ.constructor === (go$ptrType(rtype)) ? typ.go$val : go$typeAssertionFailed(typ, (go$ptrType(rtype)))), x, target);
		}
		return new Value.Ptr(typ.common(), target, (((((v.flag & 1) >>> 0) | 2) >>> 0) | 320) >>> 0);
	};
 0Ç cvtI2IÇ	cvtI2I = function(v, typ) {
		var _struct, ret, _struct$1, _struct$2, _struct$3;
		if (v.IsNil()) {
			ret = (_struct = Zero(typ), new Value.Ptr(_struct.typ, _struct.val, _struct.flag));
			ret.flag = (ret.flag | (((v.flag & 1) >>> 0))) >>> 0;
			return (_struct$1 = ret, new Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag));
		}
		return (_struct$3 = cvtT2I((_struct$2 = v.Elem(), new Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag)), typ), new Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag));
	};
 0I chancap:	chancap = function(ch) { go$notSupported("channels"); };
 0M 	chanclose<	chanclose = function(ch) { go$notSupported("channels"); };
 0I chanlen:	chanlen = function(ch) { go$notSupported("channels"); };
 0R chanrecvB	chanrecv = function(t, ch, nb) { go$notSupported("channels"); };
 0W chansendG	chansend = function(t, ch, val, nb) { go$notSupported("channels"); };
 0S makechanC	makechan = function(typ, size) {
			return new typ.jsType();
		};
 0E makemap6	makemap = function(t) {
			return new Go$Map();
		};
 0Åﬂ 	mapaccessÅÕ	mapaccess = function(t, m, key) {
			var entry = m[key.go$key ? key.go$key() : key];
			if (entry === undefined) {
				return [undefined, false];
			}
			return [makeIndir(t.Elem(), entry.v), true];
		};
 0ÇD 	mapassignÇ1	mapassign = function(t, m, key, val, ok) {
			if (!ok) {
				delete m[key.go$key ? key.go$key() : key];
				return;
			}
			if (t.Elem().kind === Struct) {
				var newVal = {};
				copyStruct(newVal, val, t.Elem());
				val = newVal;
			}
			m[key.go$key ? key.go$key() : key] = { k: key, v: val };
		};
 0h mapiterinitU	mapiterinit = function(t, m) {
			return {t: t, m: m, keys: go$keys(m), i: 0};
		};
 0ÅÜ 
mapiterkeyt	mapiterkey = function(it) {
			var key = it.keys[it.i];
			return [makeIndir(it.t.Key(), it.m[key].k), true];
		};
 0A mapiternext.	mapiternext = function(it) {
			it.i++;
		};
 0H maplen:	maplen = function(m) {
			return go$keys(m).length;
		};
 0j call^	call = function(fn, arg, n) {
		throw go$panic("Native function not implemented: call");
	};
 0M ifaceE2I=	ifaceE2I = function(t, src, dst) {
			dst.go$set(src);
		};
 0Q escapesB	escapes = function(x) {
		if (dummy.b) {
			dummy.x = x;
		}
	};
 0 	kindNames  0Å¿ ptrMap Å±		ptrMap = new (go$structType([["", "", sync.RWMutex, ""], ["m", "reflect", (go$mapType((go$ptrType(rtype)), (go$ptrType(ptrType)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
0 ptrDataGCProg  0ÅΩ lookupCache Å©		lookupCache = new (go$structType([["", "", sync.RWMutex, ""], ["m", "reflect", (go$mapType(cacheKey, (go$ptrType(rtype)))), ""]])).Ptr(new sync.RWMutex.Ptr(), false);
0 sliceEmptyGCProg  0 	uint8Type  0Åá dummy z		dummy = new (go$structType([["b", "reflect", Go$Bool, ""], ["x", "reflect", go$emptyInterface, ""]])).Ptr(false, null);
0ÇD   Ç:		kindNames = new (go$sliceType(Go$String))(["invalid", "bool", "int", "int8", "int16", "int32", "int64", "uint", "uint8", "uint16", "uint32", "uint64", "uintptr", "float32", "float64", "complex64", "complex128", "array", "chan", "func", "interface", "map", "ptr", "slice", "string", "struct", "unsafe.Pointer"]);
09   1		ptrDataGCProg = new ptrDataGC.Ptr(4, 2, 0, 0);
0@   8		sliceEmptyGCProg = new sliceEmptyGC.Ptr(12, 2, 0, 0);
0Å≤   Å©		var x;
		uint8Type = (x = TypeOf(new Go$Uint8(0)), (x !== null && x.constructor === (go$ptrType(rtype)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(rtype)))));
0Ço  Çe
			var Invalid = 0;
			var Bool = 1;
			var Int = 2;
			var Int8 = 3;
			var Int16 = 4;
			var Int32 = 5;
			var Int64 = 6;
			var Uint = 7;
			var Uint8 = 8;
			var Uint16 = 9;
			var Uint32 = 10;
			var Uint64 = 11;
			var Uintptr = 12;
			var Float32 = 13;
			var Float64 = 14;
			var Complex64 = 15;
			var Complex128 = 16;
			var Array = 17;
			var Chan = 18;
			var Func = 19;
			var Interface = 20;
			var Map = 21;
			var Ptr = 22;
			var Slice = 23;
			var String = 24;
			var Struct = 25;
			var UnsafePointer = 26;

			var RecvDir = 1;
			var SendDir = 2;
			var BothDir = 3;

			var flagRO = 1;
			var flagIndir = 2;
			var flagAddr = 4;
			var flagMethod = 8;
			var flagKindShift = 4;
			var flagKindWidth = 5;
			var flagKindMask = 31;
			var flagMethodShift = 9;

			go$reflect = {
				rtype: rtype.Ptr, uncommonType: uncommonType.Ptr, method: method.Ptr, arrayType: arrayType.Ptr, chanType: chanType.Ptr, funcType: funcType.Ptr, interfaceType: interfaceType.Ptr, mapType: mapType.Ptr, ptrType: ptrType.Ptr, sliceType: sliceType.Ptr, structType: structType.Ptr,
				imethod: imethod.Ptr, structField: structField.Ptr,
				kinds: { Bool: Bool, Int: Int, Int8: Int8, Int16: Int16, Int32: Int32, Int64: Int64, Uint: Uint, Uint8: Uint8, Uint16: Uint16, Uint32: Uint32, Uint64: Uint64, Uintptr: Uintptr, Float32: Float32, Float64: Float64, Complex64: Complex64, Complex128: Complex128, Array: Array, Chan: Chan, Func: Func, Interface: Interface, Map: Map, Ptr: Ptr, Slice: Slice, String: String, Struct: Struct, UnsafePointer: UnsafePointer },
				RecvDir: RecvDir, SendDir: SendDir, BothDir: BothDir
			};

			var isWrapped = function(typ) {
				switch (typ.Kind()) {
				case Bool:
				case Int:
				case Int8:
				case Int16:
				case Int32:
				case Uint:
				case Uint8:
				case Uint16:
				case Uint32:
				case Uintptr:
				case Float32:
				case Float64:
				case Array:
				case Map:
				case Func:
				case String:
				case Struct:
					return true;
				case Ptr:
					return typ.Elem().Kind() === Array;
				}
				return false;
			};
			var fieldName = function(field, i) {
				if (field.name.go$get === go$throwNilPointerError) {
					var ntyp = field.typ;
					if (ntyp.Kind() === Ptr) {
						ntyp = ntyp.Elem().common();
					}
					return ntyp.Name();
				}
				var name = field.name.go$get();
				if (name === "_" || go$reservedKeywords.indexOf(name) != -1) {
					return name + "$" + i;
				}
				return name;
			};
			var copyStruct = function(dst, src, typ) {
				var fields = typ.structType.fields.array, i;
				for (i = 0; i < fields.length; i++) {
					var field = fields[i];
					var name = fieldName(field, i);
					dst[name] = src[name];
				}
			};
			var deepValueEqual = function(v1, v2, visited) {
				if (!v1.IsValid() || !v2.IsValid()) {
					return !v1.IsValid() && !v2.IsValid();
				}
				if (v1.Type() !== v2.Type()) {
					return false;
				}

				var i;
				switch(v1.Kind()) {
				case Array:
				case Map:
				case Slice:
				case Struct:
					for (i = 0; i < visited.length; i++) {
						var entry = visited[i];
						if (v1.val === entry[0] && v2.val === entry[1]) {
							return true;
						}
					}
					visited.push([v1.val, v2.val]);
				}

				switch(v1.Kind()) {
				case Array:
				case Slice:
					if (v1.Kind() === Slice) {
						if (v1.IsNil() !== v2.IsNil()) {
							return false;
						}
						if (v1.iword() === v2.iword()) {
							return true;
						}
					}
					var n = v1.Len();
					if (n !== v2.Len()) {
						return false;
					}
					for (i = 0; i < n; i++) {
						if (!deepValueEqual(v1.Index(i), v2.Index(i), visited)) {
							return false;
						}
					}
					return true;
				case Interface:
					if (v1.IsNil() || v2.IsNil()) {
						return v1.IsNil() && v2.IsNil();
					}
					return deepValueEqual(v1.Elem(), v2.Elem(), visited);
				case Ptr:
					return deepValueEqual(v1.Elem(), v2.Elem(), visited);
				case Struct:
					var n = v1.NumField();
					for (i = 0; i < n; i++) {
						if (!deepValueEqual(v1.Field(i), v2.Field(i), visited)) {
							return false;
						}
					}
					return true;
				case Map:
					if (v1.IsNil() !== v2.IsNil()) {
						return false;
					}
					if (v1.iword() === v2.iword()) {
						return true;
					}
					var keys = v1.MapKeys();
					if (keys.length !== v2.Len()) {
						return false;
					}
					for (i = 0; i < keys.length; i++) {
						var k = keys.array[i];
						if (!deepValueEqual(v1.MapIndex(k), v2.MapIndex(k), visited)) {
							return false;
						}
					}
					return true;
				case Func:
					return v1.IsNil() && v2.IsNil();
				}

				return go$interfaceIsEqual(valueInterface(v1, false), valueInterface(v2, false));
			};
			var zeroVal = function(typ) {
				switch (typ.Kind()) {
				case Bool:
					return false;
				case Int:
				case Int8:
				case Int16:
				case Int32:
				case Uint:
				case Uint8:
				case Uint16:
				case Uint32:
				case Uintptr:
				case Float32:
				case Float64:
					return 0;
				case Int64:
				case Uint64:
				case Complex64:
				case Complex128:
					return new typ.jsType(0, 0);
				case Array:
					var elemType = typ.Elem();
					return go$makeNativeArray(elemType.jsType.kind, typ.Len(), function() { return zeroVal(elemType); });
				case Func:
					return go$throwNilPointerError;
				case Interface:
					return null;
				case Map:
					return false;
				case Chan:
				case Ptr:
				case Slice:
					return typ.jsType.nil;
				case String:
					return "";
				case Struct:
					return new typ.jsType.Ptr();
				default:
					throw go$panic(new ValueError.Ptr("reflect.Zero", this.kind()));
				}
			};
			var makeIndir = function(t, v) {
				if (t.size > 4) {
					return go$newDataPointer(v, t.ptrTo().jsType);
				}
				return v;
			};
		 0    0 