0ÇÆ*crypto/cipherÇlpackage cipher
import subtle "crypto/subtle"
import errors "errors"
import io "io"
type @"".AEAD interface { @"".NonceSize() (? int); @"".Open(@"".dst []byte, @"".nonce []byte, @"".ciphertext []byte, @"".data []byte) (? []byte, ? error); @"".Overhead() (? int); @"".Seal(@"".dst []byte, @"".nonce []byte, @"".plaintext []byte, @"".data []byte) (? []byte) }
type @"".Block interface { @"".BlockSize() (? int); @"".Decrypt(@"".dst []byte, @"".src []byte) (); @"".Encrypt(@"".dst []byte, @"".src []byte) () }
type @"".BlockMode interface { @"".BlockSize() (? int); @"".CryptBlocks(@"".dst []byte, @"".src []byte) () }
func @"".NewCBCDecrypter(@"".b @"".Block, @"".iv []byte) (? @"".BlockMode)
func @"".NewCBCEncrypter(@"".b @"".Block, @"".iv []byte) (? @"".BlockMode)
func @"".NewCFBDecrypter(@"".block @"".Block, @"".iv []byte) (? @"".Stream)
func @"".NewCFBEncrypter(@"".block @"".Block, @"".iv []byte) (? @"".Stream)
func @"".NewCTR(@"".block @"".Block, @"".iv []byte) (? @"".Stream)
func @"".NewGCM(@"".cipher @"".Block) (? @"".AEAD, ? error)
func @"".NewOFB(@"".b @"".Block, @"".iv []byte) (? @"".Stream)
type @"".Stream interface { @"".XORKeyStream(@"".dst []byte, @"".src []byte) () }
type @"".StreamReader struct { @"".S @"".Stream; @"".R @"io".Reader }
func (? @"".StreamReader) @"".Read(@"".dst []byte) (@"".n int, @"".err error)
func (? *@"".StreamReader) @"".Read(@"".dst []byte) (@"".n int, @"".err error)
type @"".StreamWriter struct { @"".S @"".Stream; @"".W @"io".Writer; @"".Err error }
func (? @"".StreamWriter) @"".Close() (? error)
func (? @"".StreamWriter) @"".Write(@"".src []byte) (@"".n int, @"".err error)
func (? *@"".StreamWriter) @"".Close() (? error)
func (? *@"".StreamWriter) @"".Write(@"".src []byte) (@"".n int, @"".err error)
type @"".cbc struct { @"".b @"".Block; @"".blockSize int; @"".iv []byte; @"".tmp []byte }
type @"".cbcDecrypter struct { @"".b @"".Block; @"".blockSize int; @"".iv []byte; @"".tmp []byte }
func (? *@"".cbcDecrypter) @"".BlockSize() (? int)
func (? *@"".cbcDecrypter) @"".CryptBlocks(@"".dst []byte, @"".src []byte) ()
func (? *@"".cbcDecrypter) @"".SetIV(@"".iv []byte) ()
type @"".cbcEncrypter struct { @"".b @"".Block; @"".blockSize int; @"".iv []byte; @"".tmp []byte }
func (? *@"".cbcEncrypter) @"".BlockSize() (? int)
func (? *@"".cbcEncrypter) @"".CryptBlocks(@"".dst []byte, @"".src []byte) ()
func (? *@"".cbcEncrypter) @"".SetIV(@"".iv []byte) ()
type @"".cfb struct { @"".b @"".Block; @"".out []byte; @"".outUsed int; @"".decrypt bool }
func (? *@"".cfb) @"".XORKeyStream(@"".dst []byte, @"".src []byte) ()
type @"".ctr struct { @"".b @"".Block; @"".ctr []byte; @"".out []byte; @"".outUsed int }
func (? *@"".ctr) @"".XORKeyStream(@"".dst []byte, @"".src []byte) ()
type @"".gcm struct { @"".cipher @"".Block; @"".productTable [16]@"".gcmFieldElement }
func (? *@"".gcm) @"".NonceSize() (? int)
func (? *@"".gcm) @"".Open(@"".dst []byte, @"".nonce []byte, @"".ciphertext []byte, @"".data []byte) (? []byte, ? error)
func (? *@"".gcm) @"".Overhead() (? int)
func (? *@"".gcm) @"".Seal(@"".dst []byte, @"".nonce []byte, @"".plaintext []byte, @"".data []byte) (? []byte)
func (? *@"".gcm) @"".auth(@"".out []byte, @"".ciphertext []byte, @"".additionalData []byte, @"".tagMask *[16]byte) ()
func (? *@"".gcm) @"".counterCrypt(@"".out []byte, @"".in []byte, @"".counter *[16]byte) ()
func (? *@"".gcm) @"".mul(@"".y *@"".gcmFieldElement) ()
func (? *@"".gcm) @"".update(@"".y *@"".gcmFieldElement, @"".data []byte) ()
func (? *@"".gcm) @"".updateBlocks(@"".y *@"".gcmFieldElement, @"".blocks []byte) ()
type @"".gcmFieldElement struct { @"".low uint64; @"".high uint64 }
type @"".ofb struct { @"".b @"".Block; @"".out []byte; @"".outUsed int }
func (? *@"".ofb) @"".XORKeyStream(@"".dst []byte, @"".src []byte) ()
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"io".Writer interface { @"io".Write(@"".p []byte) (@"".n int, @"".err error) }
$$
0Fruntimecrypto/subtleerrorssync/atomicsynciocrypto/cipher050crypto/subtlesubtle0errorserrors0ioioÇ#Õ	var cbc;
	cbc = go$newType(0, "Struct", "cipher.cbc", "cbc", "crypto/cipher", function(b_, blockSize_, iv_, tmp_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.blockSize = blockSize_ !== undefined ? blockSize_ : 0;
		this.iv = iv_ !== undefined ? iv_ : (go$sliceType(Go$Uint8)).nil;
		this.tmp = tmp_ !== undefined ? tmp_ : (go$sliceType(Go$Uint8)).nil;
	});
	go$pkg.cbc = cbc;
	var cbcEncrypter;
	cbcEncrypter = go$newType(0, "Struct", "cipher.cbcEncrypter", "cbcEncrypter", "crypto/cipher", function(b_, blockSize_, iv_, tmp_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.blockSize = blockSize_ !== undefined ? blockSize_ : 0;
		this.iv = iv_ !== undefined ? iv_ : (go$sliceType(Go$Uint8)).nil;
		this.tmp = tmp_ !== undefined ? tmp_ : (go$sliceType(Go$Uint8)).nil;
	});
	go$pkg.cbcEncrypter = cbcEncrypter;
	var cbcDecrypter;
	cbcDecrypter = go$newType(0, "Struct", "cipher.cbcDecrypter", "cbcDecrypter", "crypto/cipher", function(b_, blockSize_, iv_, tmp_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.blockSize = blockSize_ !== undefined ? blockSize_ : 0;
		this.iv = iv_ !== undefined ? iv_ : (go$sliceType(Go$Uint8)).nil;
		this.tmp = tmp_ !== undefined ? tmp_ : (go$sliceType(Go$Uint8)).nil;
	});
	go$pkg.cbcDecrypter = cbcDecrypter;
	var cfb;
	cfb = go$newType(0, "Struct", "cipher.cfb", "cfb", "crypto/cipher", function(b_, out_, outUsed_, decrypt_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.out = out_ !== undefined ? out_ : (go$sliceType(Go$Uint8)).nil;
		this.outUsed = outUsed_ !== undefined ? outUsed_ : 0;
		this.decrypt = decrypt_ !== undefined ? decrypt_ : false;
	});
	go$pkg.cfb = cfb;
	var Block;
	Block = go$newType(0, "Interface", "cipher.Block", "Block", "crypto/cipher", null);
	go$pkg.Block = Block;
	var Stream;
	Stream = go$newType(0, "Interface", "cipher.Stream", "Stream", "crypto/cipher", null);
	go$pkg.Stream = Stream;
	var BlockMode;
	BlockMode = go$newType(0, "Interface", "cipher.BlockMode", "BlockMode", "crypto/cipher", null);
	go$pkg.BlockMode = BlockMode;
	var ctr;
	ctr = go$newType(0, "Struct", "cipher.ctr", "ctr", "crypto/cipher", function(b_, ctr_, out_, outUsed_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.ctr = ctr_ !== undefined ? ctr_ : (go$sliceType(Go$Uint8)).nil;
		this.out = out_ !== undefined ? out_ : (go$sliceType(Go$Uint8)).nil;
		this.outUsed = outUsed_ !== undefined ? outUsed_ : 0;
	});
	go$pkg.ctr = ctr;
	var AEAD;
	AEAD = go$newType(0, "Interface", "cipher.AEAD", "AEAD", "crypto/cipher", null);
	go$pkg.AEAD = AEAD;
	var gcmFieldElement;
	gcmFieldElement = go$newType(0, "Struct", "cipher.gcmFieldElement", "gcmFieldElement", "crypto/cipher", function(low_, high_) {
		this.go$val = this;
		this.low = low_ !== undefined ? low_ : new Go$Uint64(0, 0);
		this.high = high_ !== undefined ? high_ : new Go$Uint64(0, 0);
	});
	go$pkg.gcmFieldElement = gcmFieldElement;
	var gcm;
	gcm = go$newType(0, "Struct", "cipher.gcm", "gcm", "crypto/cipher", function(cipher_, productTable_) {
		this.go$val = this;
		this.cipher = cipher_ !== undefined ? cipher_ : null;
		this.productTable = productTable_ !== undefined ? productTable_ : go$makeNativeArray("Struct", 16, function() { return new gcmFieldElement.Ptr(); });
	});
	go$pkg.gcm = gcm;
	var StreamReader;
	StreamReader = go$newType(0, "Struct", "cipher.StreamReader", "StreamReader", "crypto/cipher", function(S_, R_) {
		this.go$val = this;
		this.S = S_ !== undefined ? S_ : null;
		this.R = R_ !== undefined ? R_ : null;
	});
	go$pkg.StreamReader = StreamReader;
	var StreamWriter;
	StreamWriter = go$newType(0, "Struct", "cipher.StreamWriter", "StreamWriter", "crypto/cipher", function(S_, W_, Err_) {
		this.go$val = this;
		this.S = S_ !== undefined ? S_ : null;
		this.W = W_ !== undefined ? W_ : null;
		this.Err = Err_ !== undefined ? Err_ : null;
	});
	go$pkg.StreamWriter = StreamWriter;
	var ofb;
	ofb = go$newType(0, "Struct", "cipher.ofb", "ofb", "crypto/cipher", function(b_, out_, outUsed_) {
		this.go$val = this;
		this.b = b_ !== undefined ? b_ : null;
		this.out = out_ !== undefined ? out_ : (go$sliceType(Go$Uint8)).nil;
		this.outUsed = outUsed_ !== undefined ? outUsed_ : 0;
	});
	go$pkg.ofb = ofb;
	cbc.init([["b", "crypto/cipher", Block, ""], ["blockSize", "crypto/cipher", Go$Int, ""], ["iv", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["tmp", "crypto/cipher", (go$sliceType(Go$Uint8)), ""]]);
	cbcEncrypter.init([["b", "crypto/cipher", Block, ""], ["blockSize", "crypto/cipher", Go$Int, ""], ["iv", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["tmp", "crypto/cipher", (go$sliceType(Go$Uint8)), ""]]);
	(go$ptrType(cbcEncrypter)).methods = [["BlockSize", "", [], [Go$Int], false], ["CryptBlocks", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["SetIV", "", [(go$sliceType(Go$Uint8))], [], false]];
	cbcDecrypter.init([["b", "crypto/cipher", Block, ""], ["blockSize", "crypto/cipher", Go$Int, ""], ["iv", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["tmp", "crypto/cipher", (go$sliceType(Go$Uint8)), ""]]);
	(go$ptrType(cbcDecrypter)).methods = [["BlockSize", "", [], [Go$Int], false], ["CryptBlocks", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false], ["SetIV", "", [(go$sliceType(Go$Uint8))], [], false]];
	cfb.init([["b", "crypto/cipher", Block, ""], ["out", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["outUsed", "crypto/cipher", Go$Int, ""], ["decrypt", "crypto/cipher", Go$Bool, ""]]);
	(go$ptrType(cfb)).methods = [["XORKeyStream", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false]];
	Block.init([["BlockSize", "", (go$funcType([], [Go$Int], false))], ["Decrypt", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false))], ["Encrypt", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false))]]);
	Stream.init([["XORKeyStream", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false))]]);
	BlockMode.init([["BlockSize", "", (go$funcType([], [Go$Int], false))], ["CryptBlocks", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false))]]);
	ctr.init([["b", "crypto/cipher", Block, ""], ["ctr", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["out", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["outUsed", "crypto/cipher", Go$Int, ""]]);
	(go$ptrType(ctr)).methods = [["XORKeyStream", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false]];
	AEAD.init([["NonceSize", "", (go$funcType([], [Go$Int], false))], ["Open", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [(go$sliceType(Go$Uint8)), go$error], false))], ["Overhead", "", (go$funcType([], [Go$Int], false))], ["Seal", "", (go$funcType([(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [(go$sliceType(Go$Uint8))], false))]]);
	gcmFieldElement.init([["low", "crypto/cipher", Go$Uint64, ""], ["high", "crypto/cipher", Go$Uint64, ""]]);
	gcm.init([["cipher", "crypto/cipher", Block, ""], ["productTable", "crypto/cipher", (go$arrayType(gcmFieldElement, 16)), ""]]);
	(go$ptrType(gcm)).methods = [["NonceSize", "", [], [Go$Int], false], ["Open", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [(go$sliceType(Go$Uint8)), go$error], false], ["Overhead", "", [], [Go$Int], false], ["Seal", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [(go$sliceType(Go$Uint8))], false], ["auth", "crypto/cipher", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$ptrType((go$arrayType(Go$Uint8, 16))))], [], false], ["counterCrypt", "crypto/cipher", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8)), (go$ptrType((go$arrayType(Go$Uint8, 16))))], [], false], ["mul", "crypto/cipher", [(go$ptrType(gcmFieldElement))], [], false], ["update", "crypto/cipher", [(go$ptrType(gcmFieldElement)), (go$sliceType(Go$Uint8))], [], false], ["updateBlocks", "crypto/cipher", [(go$ptrType(gcmFieldElement)), (go$sliceType(Go$Uint8))], [], false]];
	StreamReader.init([["S", "", Stream, ""], ["R", "", io.Reader, ""]]);
	StreamReader.methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	(go$ptrType(StreamReader)).methods = [["Read", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	StreamWriter.init([["S", "", Stream, ""], ["W", "", io.Writer, ""], ["Err", "", go$error, ""]]);
	StreamWriter.methods = [["Close", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	(go$ptrType(StreamWriter)).methods = [["Close", "", [], [go$error], false], ["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false]];
	ofb.init([["b", "crypto/cipher", Block, ""], ["out", "crypto/cipher", (go$sliceType(Go$Uint8)), ""], ["outUsed", "crypto/cipher", Go$Int, ""]]);
	(go$ptrType(ofb)).methods = [["XORKeyStream", "", [(go$sliceType(Go$Uint8)), (go$sliceType(Go$Uint8))], [], false]];
0 0	errOpen0gcmReductionTable0Çz50Å´newCBCÅ†	var newCBC = function(b, iv) {
		return new cbc.Ptr(b, b.BlockSize(), dup(iv), (go$sliceType(Go$Uint8)).make(b.BlockSize(), 0, function() { return 0; }));
	};
0ÇfNewCBCEncrypterÇQ	var NewCBCEncrypter = go$pkg.NewCBCEncrypter = function(b, iv) {
		var _struct;
		if (!((iv.length === b.BlockSize()))) {
			throw go$panic(new Go$String("cipher.NewCBCEncrypter: IV length must equal block size"));
		}
		return (_struct = newCBC(b, iv), new cbcEncrypter.Ptr(_struct.b, _struct.blockSize, _struct.iv, _struct.tmp));
	};
0Å∆	BlockSizeÅ∏	cbcEncrypter.Ptr.prototype.BlockSize = function() {
		var x;
		x = this;
		return x.blockSize;
	};
	cbcEncrypter.prototype.BlockSize = function() { return this.go$val.BlockSize(); };
0Ç!CryptBlocksÇ	cbcEncrypter.Ptr.prototype.CryptBlocks = function(dst, src) {
		var x, _r, i, _lhs, _index, _slice, _index$1, _slice$1, _index$2, _slice$2, _index$3, i$1, _slice$3, _index$4, _slice$4, _index$5;
		x = this;
		if (!(((_r = src.length % x.blockSize, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0))) {
			throw go$panic(new Go$String("crypto/cipher: input not full blocks"));
		}
		if (dst.length < src.length) {
			throw go$panic(new Go$String("crypto/cipher: output smaller than input"));
		}
		while (src.length > 0) {
			i = 0;
			while (i < x.blockSize) {
				_lhs = x.iv, _index = i, _slice$2 = _lhs, _index$3 = _index, (_index$3 >= 0 && _index$3 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$3] = ((_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) ^ ((_slice$1 = src, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$2] : go$throwRuntimeError("index out of range")))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
			}
			x.b.Encrypt(x.iv, x.iv);
			i$1 = 0;
			while (i$1 < x.blockSize) {
				_slice$4 = dst, _index$5 = i$1, (_index$5 >= 0 && _index$5 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$5] = (_slice$3 = x.iv, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$4] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
				i$1 = i$1 + 1 >> 0;
			}
			src = go$subslice(src, x.blockSize);
			dst = go$subslice(dst, x.blockSize);
		}
	};
	cbcEncrypter.prototype.CryptBlocks = function(dst, src) { return this.go$val.CryptBlocks(dst, src); };
0Ç.SetIVÇ#	cbcEncrypter.Ptr.prototype.SetIV = function(iv) {
		var x;
		x = this;
		if (!((iv.length === x.iv.length))) {
			throw go$panic(new Go$String("cipher: incorrect length IV"));
		}
		go$copySlice(x.iv, iv);
	};
	cbcEncrypter.prototype.SetIV = function(iv) { return this.go$val.SetIV(iv); };
0ÇfNewCBCDecrypterÇQ	var NewCBCDecrypter = go$pkg.NewCBCDecrypter = function(b, iv) {
		var _struct;
		if (!((iv.length === b.BlockSize()))) {
			throw go$panic(new Go$String("cipher.NewCBCDecrypter: IV length must equal block size"));
		}
		return (_struct = newCBC(b, iv), new cbcDecrypter.Ptr(_struct.b, _struct.blockSize, _struct.iv, _struct.tmp));
	};
0Å∆	BlockSizeÅ∏	cbcDecrypter.Ptr.prototype.BlockSize = function() {
		var x;
		x = this;
		return x.blockSize;
	};
	cbcDecrypter.prototype.BlockSize = function() { return this.go$val.BlockSize(); };
0ÇpCryptBlocksÇ_	cbcDecrypter.Ptr.prototype.CryptBlocks = function(dst, src) {
		var x, _r, i, _lhs, _index, _slice, _index$1, _slice$1, _index$2, _slice$2, _index$3, _slice$3, _index$4, _slice$4, _index$5, _slice$5, _index$6, _slice$6, _index$7;
		x = this;
		if (!(((_r = src.length % x.blockSize, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")) === 0))) {
			throw go$panic(new Go$String("crypto/cipher: input not full blocks"));
		}
		if (dst.length < src.length) {
			throw go$panic(new Go$String("crypto/cipher: output smaller than input"));
		}
		while (src.length > 0) {
			x.b.Decrypt(x.tmp, go$subslice(src, 0, x.blockSize));
			i = 0;
			while (i < x.blockSize) {
				_lhs = x.tmp, _index = i, _slice$2 = _lhs, _index$3 = _index, (_index$3 >= 0 && _index$3 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$3] = ((_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) ^ ((_slice$1 = x.iv, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$2] : go$throwRuntimeError("index out of range")))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				_slice$4 = x.iv, _index$5 = i, (_index$5 >= 0 && _index$5 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$5] = (_slice$3 = src, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$4] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
				_slice$6 = dst, _index$7 = i, (_index$7 >= 0 && _index$7 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$7] = (_slice$5 = x.tmp, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$6] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
			}
			src = go$subslice(src, x.blockSize);
			dst = go$subslice(dst, x.blockSize);
		}
	};
	cbcDecrypter.prototype.CryptBlocks = function(dst, src) { return this.go$val.CryptBlocks(dst, src); };
0Ç.SetIVÇ#	cbcDecrypter.Ptr.prototype.SetIV = function(iv) {
		var x;
		x = this;
		if (!((iv.length === x.iv.length))) {
			throw go$panic(new Go$String("cipher: incorrect length IV"));
		}
		go$copySlice(x.iv, iv);
	};
	cbcDecrypter.prototype.SetIV = function(iv) { return this.go$val.SetIV(iv); };
0ÇNewCFBEncrypterÅ¸	var NewCFBEncrypter = go$pkg.NewCFBEncrypter = function(block, iv) {
		if (!((iv.length === block.BlockSize()))) {
			throw go$panic(new Go$String("cipher.NewCBFEncrypter: IV length must equal block size"));
		}
		return newCFB(block, iv, false);
	};
0ÇNewCFBDecrypterÅ˚	var NewCFBDecrypter = go$pkg.NewCFBDecrypter = function(block, iv) {
		if (!((iv.length === block.BlockSize()))) {
			throw go$panic(new Go$String("cipher.NewCBFEncrypter: IV length must equal block size"));
		}
		return newCFB(block, iv, true);
	};
0ÇAnewCFBÇ5	var newCFB = function(block, iv, decrypt) {
		var blockSize, x;
		blockSize = block.BlockSize();
		if (!((iv.length === blockSize))) {
			return null;
		}
		x = new cfb.Ptr(block, (go$sliceType(Go$Uint8)).make(blockSize, 0, function() { return 0; }), 0, decrypt);
		block.Encrypt(x.out, iv);
		return x;
	};
0Ç	ûXORKeyStreamÇ	å	cfb.Ptr.prototype.XORKeyStream = function(dst, src) {
		var x, i, _slice, _index, t, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _lhs, _index$5, _slice$5, _index$6, _slice$6, _index$7, _slice$7, _index$8, _slice$8, _index$9, _slice$9, _index$10;
		x = this;
		i = 0;
		while (i < src.length) {
			if (x.outUsed === x.out.length) {
				x.b.Encrypt(x.out, x.out);
				x.outUsed = 0;
			}
			if (x.decrypt) {
				t = (_slice = src, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				_slice$3 = dst, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = ((_slice$1 = src, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) ^ (_slice$2 = x.out, _index$2 = x.outUsed, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				_slice$4 = x.out, _index$4 = x.outUsed, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = t) : go$throwRuntimeError("index out of range");
			} else {
				_lhs = x.out, _index$5 = x.outUsed, _slice$7 = _lhs, _index$8 = _index$5, (_index$8 >= 0 && _index$8 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$8] = ((_slice$5 = _lhs, _index$6 = _index$5, (_index$6 >= 0 && _index$6 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$6] : go$throwRuntimeError("index out of range")) ^ ((_slice$6 = src, _index$7 = i, (_index$7 >= 0 && _index$7 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$7] : go$throwRuntimeError("index out of range")))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				_slice$9 = dst, _index$10 = i, (_index$10 >= 0 && _index$10 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$10] = (_slice$8 = x.out, _index$9 = x.outUsed, (_index$9 >= 0 && _index$9 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$9] : go$throwRuntimeError("index out of range"))) : go$throwRuntimeError("index out of range");
			}
			x.outUsed = x.outUsed + 1 >> 0;
			i = i + 1 >> 0;
		}
	};
	cfb.prototype.XORKeyStream = function(dst, src) { return this.go$val.XORKeyStream(dst, src); };
0Ç
shift1Ç˛	var shift1 = function(dst, src) {
		var b, i, _slice, _index, bb, _slice$1, _index$1, _slice$2, _index$2;
		b = 0;
		i = src.length - 1 >> 0;
		while (i >= 0) {
			bb = (_slice = src, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >>> 7 << 24 >>> 24;
			_slice$2 = dst, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = (((_slice$1 = src, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) << 1 << 24 >>> 24) | b) >>> 0) : go$throwRuntimeError("index out of range");
			b = bb;
			i = i - 1 >> 0;
		}
		return b;
	};
0ÅúdupÅî	var dup = function(p) {
		var q;
		q = (go$sliceType(Go$Uint8)).make(p.length, 0, function() { return 0; });
		go$copySlice(q, p);
		return q;
	};
0ÇBNewCTRÇ6	var NewCTR = go$pkg.NewCTR = function(block, iv) {
		if (!((iv.length === block.BlockSize()))) {
			throw go$panic(new Go$String("cipher.NewCTR: IV length must equal block size"));
		}
		return new ctr.Ptr(block, dup(iv), (go$sliceType(Go$Uint8)).make(iv.length, 0, function() { return 0; }), iv.length);
	};
0ÇŸXORKeyStreamÇ«	ctr.Ptr.prototype.XORKeyStream = function(dst, src) {
		var x, i, i$1, _lhs, _index, _slice, _index$1, _slice$1, _index$2, _slice$2, _index$3, _slice$3, _index$4, _slice$4, _index$5, _slice$5, _index$6;
		x = this;
		i = 0;
		while (i < src.length) {
			if (x.outUsed === x.ctr.length) {
				x.b.Encrypt(x.out, x.ctr);
				x.outUsed = 0;
				i$1 = x.ctr.length - 1 >> 0;
				while (i$1 >= 0) {
					_lhs = x.ctr, _index = i$1, _slice$1 = _lhs, _index$2 = _index, (_index$2 >= 0 && _index$2 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$2] = (_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) + 1 << 24 >>> 24) : go$throwRuntimeError("index out of range");
					if (!(((_slice$2 = x.ctr, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$3] : go$throwRuntimeError("index out of range")) === 0))) {
						break;
					}
					i$1 = i$1 - 1 >> 0;
				}
			}
			_slice$5 = dst, _index$6 = i, (_index$6 >= 0 && _index$6 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$6] = ((_slice$3 = src, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$4] : go$throwRuntimeError("index out of range")) ^ (_slice$4 = x.out, _index$5 = x.outUsed, (_index$5 >= 0 && _index$5 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$5] : go$throwRuntimeError("index out of range"))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
			x.outUsed = x.outUsed + 1 >> 0;
			i = i + 1 >> 0;
		}
	};
	ctr.prototype.XORKeyStream = function(dst, src) { return this.go$val.XORKeyStream(dst, src); };
0ÇÍNewGCMÇﬁ	var NewGCM = go$pkg.NewGCM = function(cipher) {
		var key, g, x, _struct, i, _q, _struct$1, _struct$2;
		if (!((cipher.BlockSize() === 16))) {
			return [null, errors.New("cipher: NewGCM requires 128-bit block cipher")];
		}
		key = go$makeNativeArray("Uint8", 16, function() { return 0; });
		cipher.Encrypt(new (go$sliceType(Go$Uint8))(key), new (go$sliceType(Go$Uint8))(key));
		g = new gcm.Ptr(cipher, go$makeNativeArray("Struct", 16, function() { return new gcmFieldElement.Ptr(); }));
		x = new gcmFieldElement.Ptr(getUint64(go$subslice(new (go$sliceType(Go$Uint8))(key), 0, 8)), getUint64(go$subslice(new (go$sliceType(Go$Uint8))(key), 8)));
		g.productTable[reverseBits(1)] = (_struct = x, new gcmFieldElement.Ptr(_struct.low, _struct.high));
		i = 2;
		while (i < 16) {
			g.productTable[reverseBits(i)] = (_struct$1 = gcmDouble(g.productTable[reverseBits((_q = i / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero")))]), new gcmFieldElement.Ptr(_struct$1.low, _struct$1.high));
			g.productTable[reverseBits(i + 1 >> 0)] = (_struct$2 = gcmAdd(g.productTable[reverseBits(i)], x), new gcmFieldElement.Ptr(_struct$2.low, _struct$2.high));
			i = i + 2 >> 0;
		}
		return [g, null];
	};
0Åñ	NonceSizeÅà	gcm.Ptr.prototype.NonceSize = function() {
		return 12;
	};
	gcm.prototype.NonceSize = function() { return this.go$val.NonceSize(); };
0ÅíOverheadÅÖ	gcm.Ptr.prototype.Overhead = function() {
		return 16;
	};
	gcm.prototype.Overhead = function() { return this.go$val.Overhead(); };
0Ç˜SealÇÌ	gcm.Ptr.prototype.Seal = function(dst, nonce, plaintext, data) {
		var g, _tuple, ret, out, _tuple$1, counter, tagMask;
		g = this;
		if (!((nonce.length === 12))) {
			throw go$panic(new Go$String("cipher: incorrect nonce length given to GCM"));
		}
		_tuple = sliceForAppend(dst, plaintext.length + 16 >> 0), ret = _tuple[0], out = _tuple[1];
		_tuple$1 = [go$makeNativeArray("Uint8", 16, function() { return 0; }), go$makeNativeArray("Uint8", 16, function() { return 0; })], counter = _tuple$1[0], tagMask = _tuple$1[1];
		go$copySlice(new (go$sliceType(Go$Uint8))(counter), nonce);
		counter[15] = 1;
		g.cipher.Encrypt(new (go$sliceType(Go$Uint8))(tagMask), new (go$sliceType(Go$Uint8))(counter));
		gcmInc32(counter);
		g.counterCrypt(out, plaintext, counter);
		g.auth(go$subslice(out, plaintext.length), go$subslice(out, 0, plaintext.length), data, tagMask);
		return ret;
	};
	gcm.prototype.Seal = function(dst, nonce, plaintext, data) { return this.go$val.Seal(dst, nonce, plaintext, data); };
0Ç∫OpenÇ∞	gcm.Ptr.prototype.Open = function(dst, nonce, ciphertext, data) {
		var g, tag, _tuple, counter, tagMask, expectedTag, _tuple$1, ret, out;
		g = this;
		if (!((nonce.length === 12))) {
			throw go$panic(new Go$String("cipher: incorrect nonce length given to GCM"));
		}
		if (ciphertext.length < 16) {
			return [(go$sliceType(Go$Uint8)).nil, errOpen];
		}
		tag = go$subslice(ciphertext, (ciphertext.length - 16 >> 0));
		ciphertext = go$subslice(ciphertext, 0, (ciphertext.length - 16 >> 0));
		_tuple = [go$makeNativeArray("Uint8", 16, function() { return 0; }), go$makeNativeArray("Uint8", 16, function() { return 0; })], counter = _tuple[0], tagMask = _tuple[1];
		go$copySlice(new (go$sliceType(Go$Uint8))(counter), nonce);
		counter[15] = 1;
		g.cipher.Encrypt(new (go$sliceType(Go$Uint8))(tagMask), new (go$sliceType(Go$Uint8))(counter));
		gcmInc32(counter);
		expectedTag = go$makeNativeArray("Uint8", 16, function() { return 0; });
		g.auth(new (go$sliceType(Go$Uint8))(expectedTag), ciphertext, data, tagMask);
		if (!((subtle.ConstantTimeCompare(new (go$sliceType(Go$Uint8))(expectedTag), tag) === 1))) {
			return [(go$sliceType(Go$Uint8)).nil, errOpen];
		}
		_tuple$1 = sliceForAppend(dst, ciphertext.length), ret = _tuple$1[0], out = _tuple$1[1];
		g.counterCrypt(out, ciphertext, counter);
		return [ret, null];
	};
	gcm.prototype.Open = function(dst, nonce, ciphertext, data) { return this.go$val.Open(dst, nonce, ciphertext, data); };
0ÅµreverseBitsÅ•	var reverseBits = function(i) {
		i = ((((i << 2 >> 0)) & 12)) | ((((i >> 2 >> 0)) & 3));
		i = ((((i << 1 >> 0)) & 10)) | ((((i >> 1 >> 0)) & 5));
		return i;
	};
0Ç#gcmAddÇ	var gcmAdd = function(x, y) {
		var x$1, x$2, x$3, x$4;
		return new gcmFieldElement.Ptr((x$1 = x.low, x$2 = y.low, new Go$Uint64(x$1.high ^ x$2.high, (x$1.low ^ x$2.low) >>> 0)), (x$3 = x.high, x$4 = y.high, new Go$Uint64(x$3.high ^ x$4.high, (x$3.low ^ x$4.low) >>> 0)));
	};
0Ç¡	gcmDoubleÇ≤	var gcmDouble = function(x) {
		var double$1, x$1, x$2, msbSet, x$3, x$4, x$5, _struct;
		double$1 = new gcmFieldElement.Ptr();
		msbSet = (x$1 = (x$2 = x.high, new Go$Uint64(x$2.high & 0, (x$2.low & 1) >>> 0)), (x$1.high === 0 && x$1.low === 1));
		double$1.high = go$shiftRightUint64(x.high, 1);
		double$1.high = (x$3 = double$1.high, x$4 = go$shiftLeft64(x.low, 63), new Go$Uint64(x$3.high | x$4.high, (x$3.low | x$4.low) >>> 0));
		double$1.low = go$shiftRightUint64(x.low, 1);
		if (msbSet) {
			double$1.low = (x$5 = double$1.low, new Go$Uint64(x$5.high ^ 3774873600, (x$5.low ^ 0) >>> 0));
		}
		return (_struct = double$1, new gcmFieldElement.Ptr(_struct.low, _struct.high));
	};
0ÇŒmulÇ≈	gcm.Ptr.prototype.mul = function(y) {
		var g, z, i, word, j, x, msw, x$1, x$2, x$3, x$4, _slice, _index, t, x$5, x$6, x$7, x$8, _struct, l, r;
		g = this;
		z = new gcmFieldElement.Ptr();
		i = 0;
		while (i < 2) {
			word = y.high;
			if (i === 1) {
				word = y.low;
			}
			j = 0;
			while (j < 64) {
				msw = (x = z.high, new Go$Uint64(x.high & 0, (x.low & 15) >>> 0));
				z.high = go$shiftRightUint64(z.high, 4);
				z.high = (x$1 = z.high, x$2 = go$shiftLeft64(z.low, 60), new Go$Uint64(x$1.high | x$2.high, (x$1.low | x$2.low) >>> 0));
				z.low = go$shiftRightUint64(z.low, 4);
				z.low = (x$3 = z.low, x$4 = go$shiftLeft64(new Go$Uint64(0, (_slice = gcmReductionTable, _index = go$flatten64(msw), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))), 48), new Go$Uint64(x$3.high ^ x$4.high, (x$3.low ^ x$4.low) >>> 0));
				t = g.productTable[go$flatten64(new Go$Uint64(word.high & 0, (word.low & 15) >>> 0))];
				z.low = (x$5 = z.low, x$6 = t.low, new Go$Uint64(x$5.high ^ x$6.high, (x$5.low ^ x$6.low) >>> 0));
				z.high = (x$7 = z.high, x$8 = t.high, new Go$Uint64(x$7.high ^ x$8.high, (x$7.low ^ x$8.low) >>> 0));
				word = go$shiftRightUint64(word, 4);
				j = j + 4 >> 0;
			}
			i = i + 1 >> 0;
		}
		l = y, r = (_struct = z, new gcmFieldElement.Ptr(_struct.low, _struct.high)), l.low = r.low, l.high = r.high;
	};
	gcm.prototype.mul = function(y) { return this.go$val.mul(y); };
0ÇupdateBlocksÇ
	gcm.Ptr.prototype.updateBlocks = function(y, blocks) {
		var g, x, x$1, x$2, x$3;
		g = this;
		while (blocks.length > 0) {
			y.low = (x = y.low, x$1 = getUint64(blocks), new Go$Uint64(x.high ^ x$1.high, (x.low ^ x$1.low) >>> 0));
			y.high = (x$2 = y.high, x$3 = getUint64(go$subslice(blocks, 8)), new Go$Uint64(x$2.high ^ x$3.high, (x$2.low ^ x$3.low) >>> 0));
			g.mul(y);
			blocks = go$subslice(blocks, 16);
		}
	};
	gcm.prototype.updateBlocks = function(y, blocks) { return this.go$val.updateBlocks(y, blocks); };
0ÇEupdateÇ9	gcm.Ptr.prototype.update = function(y, data) {
		var g, fullBlocks, partialBlock;
		g = this;
		fullBlocks = ((data.length >> 4 >> 0)) << 4 >> 0;
		g.updateBlocks(y, go$subslice(data, 0, fullBlocks));
		if (!((data.length === fullBlocks))) {
			partialBlock = go$makeNativeArray("Uint8", 16, function() { return 0; });
			go$copySlice(new (go$sliceType(Go$Uint8))(partialBlock), go$subslice(data, fullBlocks));
			g.updateBlocks(y, new (go$sliceType(Go$Uint8))(partialBlock));
		}
	};
	gcm.prototype.update = function(y, data) { return this.go$val.update(y, data); };
0ÅÈgcmInc32Å‹	var gcmInc32 = function(counterBlock) {
		var c, i;
		c = 1;
		i = 15;
		while (i >= 12) {
			c = c + ((counterBlock[i] >> 0)) >> 0;
			counterBlock[i] = (c << 24 >>> 24);
			c = c >> 8 >> 0;
			i = i - 1 >> 0;
		}
	};
0Ç«sliceForAppendÇ≥	var sliceForAppend = function(in$1, n) {
		var head, tail, total;
		head = (go$sliceType(Go$Uint8)).nil;
		tail = (go$sliceType(Go$Uint8)).nil;
		if (total = in$1.length + n >> 0, in$1.capacity >= total) {
			head = go$subslice(in$1, 0, total);
		} else {
			head = (go$sliceType(Go$Uint8)).make(total, 0, function() { return 0; });
			go$copySlice(head, in$1);
		}
		tail = go$subslice(head, in$1.length);
		return [head, tail];
	};
0ÇácounterCryptÇu	gcm.Ptr.prototype.counterCrypt = function(out, in$1, counter) {
		var g, mask, _ref, _i, i, _slice, _index, _slice$1, _index$1, _ref$1, _i$1, i$1, _slice$2, _index$2, _slice$3, _index$3;
		g = this;
		mask = go$makeNativeArray("Uint8", 16, function() { return 0; });
		while (in$1.length >= 16) {
			g.cipher.Encrypt(new (go$sliceType(Go$Uint8))(mask), new (go$sliceType(Go$Uint8))(counter));
			gcmInc32(counter);
			_ref = mask;
			_i = 0;
			while (_i < 16) {
				i = _i;
				_slice$1 = out, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = ((_slice = in$1, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) ^ mask[i]) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				_i++;
			}
			out = go$subslice(out, 16);
			in$1 = go$subslice(in$1, 16);
		}
		if (in$1.length > 0) {
			g.cipher.Encrypt(new (go$sliceType(Go$Uint8))(mask), new (go$sliceType(Go$Uint8))(counter));
			gcmInc32(counter);
			_ref$1 = in$1;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				i$1 = _i$1;
				_slice$3 = out, _index$3 = i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = ((_slice$2 = in$1, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")) ^ mask[i$1]) << 24 >>> 24) : go$throwRuntimeError("index out of range");
				_i$1++;
			}
		}
	};
	gcm.prototype.counterCrypt = function(out, in$1, counter) { return this.go$val.counterCrypt(out, in$1, counter); };
0ÇauthÇ	gcm.Ptr.prototype.auth = function(out, ciphertext, additionalData, tagMask) {
		var g, y, x, x$1, x$2, x$3, _ref, _i, i, _lhs, _index, _slice, _index$1, _slice$1, _index$2;
		g = this;
		y = new gcmFieldElement.Ptr();
		g.update(y, additionalData);
		g.update(y, ciphertext);
		y.low = (x = y.low, x$1 = go$mul64(new Go$Uint64(0, additionalData.length), new Go$Uint64(0, 8)), new Go$Uint64(x.high ^ x$1.high, (x.low ^ x$1.low) >>> 0));
		y.high = (x$2 = y.high, x$3 = go$mul64(new Go$Uint64(0, ciphertext.length), new Go$Uint64(0, 8)), new Go$Uint64(x$2.high ^ x$3.high, (x$2.low ^ x$3.low) >>> 0));
		g.mul(y);
		putUint64(out, y.low);
		putUint64(go$subslice(out, 8), y.high);
		_ref = tagMask;
		_i = 0;
		while (_i < 16) {
			i = _i;
			_lhs = out, _index = i, _slice$1 = _lhs, _index$2 = _index, (_index$2 >= 0 && _index$2 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$2] = ((_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) ^ (tagMask[i])) << 24 >>> 24) : go$throwRuntimeError("index out of range");
			_i++;
		}
	};
	gcm.prototype.auth = function(out, ciphertext, additionalData, tagMask) { return this.go$val.auth(out, ciphertext, additionalData, tagMask); };
0Ç	∞	getUint64Ç	°	var getUint64 = function(data) {
		var x, x$1, x$2, x$3, x$4, x$5, x$6, _slice, _index, x$7, _slice$1, _index$1, x$8, _slice$2, _index$2, x$9, _slice$3, _index$3, x$10, _slice$4, _index$4, x$11, _slice$5, _index$5, x$12, _slice$6, _index$6, x$13, _slice$7, _index$7, r;
		r = (x = (x$1 = (x$2 = (x$3 = (x$4 = (x$5 = (x$6 = go$shiftLeft64(new Go$Uint64(0, (_slice = data, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"))), 56), x$7 = go$shiftLeft64(new Go$Uint64(0, (_slice$1 = data, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))), 48), new Go$Uint64(x$6.high | x$7.high, (x$6.low | x$7.low) >>> 0)), x$8 = go$shiftLeft64(new Go$Uint64(0, (_slice$2 = data, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"))), 40), new Go$Uint64(x$5.high | x$8.high, (x$5.low | x$8.low) >>> 0)), x$9 = go$shiftLeft64(new Go$Uint64(0, (_slice$3 = data, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"))), 32), new Go$Uint64(x$4.high | x$9.high, (x$4.low | x$9.low) >>> 0)), x$10 = go$shiftLeft64(new Go$Uint64(0, (_slice$4 = data, _index$4 = 4, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"))), 24), new Go$Uint64(x$3.high | x$10.high, (x$3.low | x$10.low) >>> 0)), x$11 = go$shiftLeft64(new Go$Uint64(0, (_slice$5 = data, _index$5 = 5, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"))), 16), new Go$Uint64(x$2.high | x$11.high, (x$2.low | x$11.low) >>> 0)), x$12 = go$shiftLeft64(new Go$Uint64(0, (_slice$6 = data, _index$6 = 6, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range"))), 8), new Go$Uint64(x$1.high | x$12.high, (x$1.low | x$12.low) >>> 0)), x$13 = new Go$Uint64(0, (_slice$7 = data, _index$7 = 7, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range"))), new Go$Uint64(x.high | x$13.high, (x.low | x$13.low) >>> 0));
		return r;
	};
0Çá	putUint64Çx	var putUint64 = function(out, v) {
		var _slice, _index, _slice$1, _index$1, _slice$2, _index$2, _slice$3, _index$3, _slice$4, _index$4, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		_slice = out, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = (go$shiftRightUint64(v, 56).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$1 = out, _index$1 = 1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = (go$shiftRightUint64(v, 48).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$2 = out, _index$2 = 2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = (go$shiftRightUint64(v, 40).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$3 = out, _index$3 = 3, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = (go$shiftRightUint64(v, 32).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$4 = out, _index$4 = 4, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = (go$shiftRightUint64(v, 24).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$5 = out, _index$5 = 5, (_index$5 >= 0 && _index$5 < _slice$5.length) ? (_slice$5.array[_slice$5.offset + _index$5] = (go$shiftRightUint64(v, 16).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$6 = out, _index$6 = 6, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = (go$shiftRightUint64(v, 8).low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
		_slice$7 = out, _index$7 = 7, (_index$7 >= 0 && _index$7 < _slice$7.length) ? (_slice$7.array[_slice$7.offset + _index$7] = (v.low << 24 >>> 24)) : go$throwRuntimeError("index out of range");
	};
0ÇüReadÇï	StreamReader.Ptr.prototype.Read = function(dst) {
		var n, err, _struct, r, _tuple;
		n = 0;
		err = null;
		r = (_struct = this, new StreamReader.Ptr(_struct.S, _struct.R));
		_tuple = r.R.Read(dst), n = _tuple[0], err = _tuple[1];
		r.S.XORKeyStream(go$subslice(dst, 0, n), go$subslice(dst, 0, n));
		return [n, err];
	};
	StreamReader.prototype.Read = function(dst) { return this.go$val.Read(dst); };
0ÇEWriteÇ:	StreamWriter.Ptr.prototype.Write = function(src) {
		var n, err, _struct, w, c, _tuple;
		n = 0;
		err = null;
		w = (_struct = this, new StreamWriter.Ptr(_struct.S, _struct.W, _struct.Err));
		c = (go$sliceType(Go$Uint8)).make(src.length, 0, function() { return 0; });
		w.S.XORKeyStream(c, src);
		_tuple = w.W.Write(c), n = _tuple[0], err = _tuple[1];
		if (!((n === src.length))) {
			if (go$interfaceIsEqual(err, null)) {
				err = io.ErrShortWrite;
			}
		}
		return [n, err];
	};
	StreamWriter.prototype.Write = function(src) { return this.go$val.Write(src); };
0ÇÀCloseÇ¿	StreamWriter.Ptr.prototype.Close = function() {
		var _struct, w, ok, _tuple, x, c;
		w = (_struct = this, new StreamWriter.Ptr(_struct.S, _struct.W, _struct.Err));
		if (_tuple = (x = w.W, (x !== null && io.Closer.implementedBy.indexOf(x.constructor) !== -1 ? [x, true] : [null, false])), c = _tuple[0], ok = _tuple[1], ok) {
			return c.Close();
		}
		return null;
	};
	StreamWriter.prototype.Close = function() { return this.go$val.Close(); };
0Ç/NewOFBÇ#	var NewOFB = go$pkg.NewOFB = function(b, iv) {
		var blockSize, x;
		blockSize = b.BlockSize();
		if (!((iv.length === blockSize))) {
			return null;
		}
		x = new ofb.Ptr(b, (go$sliceType(Go$Uint8)).make(blockSize, 0, function() { return 0; }), 0);
		b.Encrypt(x.out, iv);
		return x;
	};
0ÇÏXORKeyStreamÇ⁄	ofb.Ptr.prototype.XORKeyStream = function(dst, src) {
		var x, _ref, _i, _slice, _index, s, i, _slice$1, _index$1, _slice$2, _index$2;
		x = this;
		_ref = src;
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (x.outUsed === x.out.length) {
				x.b.Encrypt(x.out, x.out);
				x.outUsed = 0;
			}
			_slice$2 = dst, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = (s ^ (_slice$1 = x.out, _index$1 = x.outUsed, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))) << 24 >>> 24) : go$throwRuntimeError("index out of range");
			x.outUsed = x.outUsed + 1 >> 0;
			_i++;
		}
	};
	ofb.prototype.XORKeyStream = function(dst, src) { return this.go$val.XORKeyStream(dst, src); };
0ÇinitÇ	go$pkg.init = function() {
		errOpen = errors.New("cipher: message authentication failed");
		gcmReductionTable = new (go$sliceType(Go$Uint16))([0, 7200, 14400, 9312, 28800, 27808, 18624, 21728, 57600, 64800, 55616, 50528, 37248, 36256, 43456, 46560]);
	};
