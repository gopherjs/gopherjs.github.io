0É)„crypto/ellipticÇK}package elliptic
import io "io"
import big "math/big"
import sync "sync"
type @"".Curve interface { @"".Add(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int, @"".x2 *@"math/big".Int, @"".y2 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int); @"".Double(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int); @"".IsOnCurve(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? bool); @"".Params() (? *@"".CurveParams); @"".ScalarBaseMult(@"".k []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int); @"".ScalarMult(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int, @"".k []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int) }
type @"".CurveParams struct { @"".P *@"math/big".Int; @"".N *@"math/big".Int; @"".B *@"math/big".Int; @"".Gx *@"math/big".Int; @"".Gy *@"math/big".Int; @"".BitSize int }
func (? *@"".CurveParams) @"".Add(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int, @"".x2 *@"math/big".Int, @"".y2 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"".CurveParams) @"".Double(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"".CurveParams) @"".IsOnCurve(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? bool)
func (? *@"".CurveParams) @"".Params() (? *@"".CurveParams)
func (? *@"".CurveParams) @"".ScalarBaseMult(@"".k []byte) (? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"".CurveParams) @"".ScalarMult(@"".Bx *@"math/big".Int, @"".By *@"math/big".Int, @"".k []byte) (? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"".CurveParams) @"".addJacobian(@"".x1 *@"math/big".Int, @"".y1 *@"math/big".Int, @"".z1 *@"math/big".Int, @"".x2 *@"math/big".Int, @"".y2 *@"math/big".Int, @"".z2 *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"".CurveParams) @"".affineFromJacobian(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".z *@"math/big".Int) (@"".xOut *@"math/big".Int, @"".yOut *@"math/big".Int)
func (? *@"".CurveParams) @"".doubleJacobian(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".z *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int, ? *@"math/big".Int)
func @"".GenerateKey(@"".curve @"".Curve, @"".rand @"io".Reader) (@"".priv []byte, @"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".err error)
func @"".Marshal(@"".curve @"".Curve, @"".x *@"math/big".Int, @"".y *@"math/big".Int) (? []byte)
func @"".P224() (? @"".Curve)
func @"".P256() (? @"".Curve)
func @"".P384() (? @"".Curve)
func @"".P521() (? @"".Curve)
func @"".Unmarshal(@"".curve @"".Curve, @"".data []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
type @"".p224Curve struct { ? *@"".CurveParams; @"".gx @"".p224FieldElement; @"".gy @"".p224FieldElement; @"".b @"".p224FieldElement }
func (? @"".p224Curve) @"".Add(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int, @"".bigX2 *@"math/big".Int, @"".bigY2 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? @"".p224Curve) @"".Double(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? @"".p224Curve) @"".IsOnCurve(@"".bigX *@"math/big".Int, @"".bigY *@"math/big".Int) (? bool)
func (? @"".p224Curve) @"".Params() (? *@"".CurveParams)
func (? @"".p224Curve) @"".ScalarBaseMult(@"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? @"".p224Curve) @"".ScalarMult(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int, @"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p224Curve) @"".Add(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int, @"".bigX2 *@"math/big".Int, @"".bigY2 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p224Curve) @"".Double(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p224Curve) @"".IsOnCurve(@"".bigX *@"math/big".Int, @"".bigY *@"math/big".Int) (? bool)
func (? *@"".p224Curve) @"".Params() (? *@"".CurveParams)
func (? *@"".p224Curve) @"".ScalarBaseMult(@"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p224Curve) @"".ScalarMult(@"".bigX1 *@"math/big".Int, @"".bigY1 *@"math/big".Int, @"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
type @"".p224FieldElement [8]uint32
type @"".p224LargeFieldElement [15]uint64
type @"".p256Curve struct { ? *@"".CurveParams }
func (? @"".p256Curve) @"".Params() (? *@"".CurveParams)
func (? @"".p256Curve) @"".ScalarBaseMult(@"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? @"".p256Curve) @"".ScalarMult(@"".bigX *@"math/big".Int, @"".bigY *@"math/big".Int, @"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p256Curve) @"".Params() (? *@"".CurveParams)
func (? *@"".p256Curve) @"".ScalarBaseMult(@"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
func (? *@"".p256Curve) @"".ScalarMult(@"".bigX *@"math/big".Int, @"".bigY *@"math/big".Int, @"".scalar []byte) (@"".x *@"math/big".Int, @"".y *@"math/big".Int)
type @"math/big".Int struct { @"math/big".neg bool; @"math/big".abs @"math/big".nat }
func (? *@"math/big".Int) @"math/big".Abs(@"".x *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Add(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".And(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".AndNot(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Binomial(@"".n int64, @"".k int64) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Bit(@"".i int) (? uint)
func (? *@"math/big".Int) @"math/big".BitLen() (? int)
func (? *@"math/big".Int) @"math/big".Bits() (? []@"math/big".Word)
func (? *@"math/big".Int) @"math/big".Bytes() (? []byte)
func (? *@"math/big".Int) @"math/big".Cmp(@"".y *@"math/big".Int) (@"".r int)
func (? *@"math/big".Int) @"math/big".Div(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".DivMod(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".m *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Exp(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".m *@"math/big".Int) (? *@"math/big".Int)
import fmt "fmt"
func (? *@"math/big".Int) @"math/big".Format(@"".s @"fmt".State, @"".ch rune) ()
func (? *@"math/big".Int) @"math/big".GCD(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".a *@"math/big".Int, @"".b *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".GobDecode(@"".buf []byte) (? error)
func (? *@"math/big".Int) @"math/big".GobEncode() (? []byte, ? error)
func (? *@"math/big".Int) @"math/big".Int64() (? int64)
func (? *@"math/big".Int) @"math/big".Lsh(@"".x *@"math/big".Int, @"".n uint) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".MarshalJSON() (? []byte, ? error)
func (? *@"math/big".Int) @"math/big".Mod(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".ModInverse(@"".g *@"math/big".Int, @"".p *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Mul(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".MulRange(@"".a int64, @"".b int64) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Neg(@"".x *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Not(@"".x *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Or(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".ProbablyPrime(@"".n int) (? bool)
func (? *@"math/big".Int) @"math/big".Quo(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".QuoRem(@"".x *@"math/big".Int, @"".y *@"math/big".Int, @"".r *@"math/big".Int) (? *@"math/big".Int, ? *@"math/big".Int)
import rand "math/rand"
func (? *@"math/big".Int) @"math/big".Rand(@"".rnd *@"math/rand".Rand, @"".n *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Rem(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Rsh(@"".x *@"math/big".Int, @"".n uint) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Scan(@"".s @"fmt".ScanState, @"".ch rune) (? error)
func (? *@"math/big".Int) @"math/big".Set(@"".x *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".SetBit(@"".x *@"math/big".Int, @"".i int, @"".b uint) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".SetBits(@"".abs []@"math/big".Word) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".SetBytes(@"".buf []byte) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".SetInt64(@"".x int64) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".SetString(@"".s string, @"".base int) (? *@"math/big".Int, ? bool)
func (? *@"math/big".Int) @"math/big".SetUint64(@"".x uint64) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Sign() (? int)
func (? *@"math/big".Int) @"math/big".String() (? string)
func (? *@"math/big".Int) @"math/big".Sub(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".Uint64() (? uint64)
func (? *@"math/big".Int) @"math/big".UnmarshalJSON(@"".x []byte) (? error)
func (? *@"math/big".Int) @"math/big".Xor(@"".x *@"math/big".Int, @"".y *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".binaryGCD(@"".a *@"math/big".Int, @"".b *@"math/big".Int) (? *@"math/big".Int)
func (? *@"math/big".Int) @"math/big".scan(@"".r @"io".RuneScanner, @"".base int) (? *@"math/big".Int, ? int, ? error)
type @"io".Reader interface { @"io".Read(@"".p []byte) (@"".n int, @"".err error) }
type @"math/big".nat []@"math/big".Word
func (? @"math/big".nat) @"math/big".add(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".and(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".andNot(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".bit(@"".i uint) (? uint)
func (? @"math/big".nat) @"math/big".bitLen() (? int)
func (? @"math/big".nat) @"math/big".bytes(@"".buf []byte) (@"".i int)
func (? @"math/big".nat) @"math/big".clear() ()
func (? @"math/big".nat) @"math/big".cmp(@"".y @"math/big".nat) (@"".r int)
func (? @"math/big".nat) @"math/big".convertWords(@"".s []byte, @"".charset string, @"".b @"math/big".Word, @"".ndigits int, @"".bb @"math/big".Word, @"".table []@"math/big".divisor) ()
func (? @"math/big".nat) @"math/big".decimalString() (? string)
func (? @"math/big".nat) @"math/big".div(@"".z2 @"math/big".nat, @"".u @"math/big".nat, @"".v @"math/big".nat) (@"".q @"math/big".nat, @"".r @"math/big".nat)
func (? @"math/big".nat) @"math/big".divLarge(@"".u @"math/big".nat, @"".uIn @"math/big".nat, @"".v @"math/big".nat) (@"".q @"math/big".nat, @"".r @"math/big".nat)
func (? @"math/big".nat) @"math/big".divW(@"".x @"math/big".nat, @"".y @"math/big".Word) (@"".q @"math/big".nat, @"".r @"math/big".Word)
func (? @"math/big".nat) @"math/big".expNN(@"".x @"math/big".nat, @"".y @"math/big".nat, @"".m @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".expNNWindowed(@"".x @"math/big".nat, @"".y @"math/big".nat, @"".m @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".expWW(@"".x @"math/big".Word, @"".y @"math/big".Word) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".make(@"".n int) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".modW(@"".d @"math/big".Word) (@"".r @"math/big".Word)
func (? @"math/big".nat) @"math/big".mul(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".mulAddWW(@"".x @"math/big".nat, @"".y @"math/big".Word, @"".r @"math/big".Word) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".mulRange(@"".a uint64, @"".b uint64) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".norm() (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".or(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".probablyPrime(@"".reps int) (? bool)
func (? @"math/big".nat) @"math/big".random(@"".rand *@"math/rand".Rand, @"".limit @"math/big".nat, @"".n int) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".scan(@"".r @"io".RuneScanner, @"".base int) (? @"math/big".nat, ? int, ? error)
func (? @"math/big".nat) @"math/big".set(@"".x @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".setBit(@"".x @"math/big".nat, @"".i uint, @"".b uint) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".setBytes(@"".buf []byte) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".setUint64(@"".x uint64) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".setWord(@"".x @"math/big".Word) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".shl(@"".x @"math/big".nat, @"".s uint) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".shr(@"".x @"math/big".nat, @"".s uint) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".string(@"".charset string) (? string)
func (? @"math/big".nat) @"math/big".sub(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? @"math/big".nat) @"math/big".trailingZeroBits() (? uint)
func (? @"math/big".nat) @"math/big".xor(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".add(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".and(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".andNot(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".bit(@"".i uint) (? uint)
func (? *@"math/big".nat) @"math/big".bitLen() (? int)
func (? *@"math/big".nat) @"math/big".bytes(@"".buf []byte) (@"".i int)
func (? *@"math/big".nat) @"math/big".clear() ()
func (? *@"math/big".nat) @"math/big".cmp(@"".y @"math/big".nat) (@"".r int)
func (? *@"math/big".nat) @"math/big".convertWords(@"".s []byte, @"".charset string, @"".b @"math/big".Word, @"".ndigits int, @"".bb @"math/big".Word, @"".table []@"math/big".divisor) ()
func (? *@"math/big".nat) @"math/big".decimalString() (? string)
func (? *@"math/big".nat) @"math/big".div(@"".z2 @"math/big".nat, @"".u @"math/big".nat, @"".v @"math/big".nat) (@"".q @"math/big".nat, @"".r @"math/big".nat)
func (? *@"math/big".nat) @"math/big".divLarge(@"".u @"math/big".nat, @"".uIn @"math/big".nat, @"".v @"math/big".nat) (@"".q @"math/big".nat, @"".r @"math/big".nat)
func (? *@"math/big".nat) @"math/big".divW(@"".x @"math/big".nat, @"".y @"math/big".Word) (@"".q @"math/big".nat, @"".r @"math/big".Word)
func (? *@"math/big".nat) @"math/big".expNN(@"".x @"math/big".nat, @"".y @"math/big".nat, @"".m @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".expNNWindowed(@"".x @"math/big".nat, @"".y @"math/big".nat, @"".m @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".expWW(@"".x @"math/big".Word, @"".y @"math/big".Word) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".make(@"".n int) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".modW(@"".d @"math/big".Word) (@"".r @"math/big".Word)
func (? *@"math/big".nat) @"math/big".mul(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".mulAddWW(@"".x @"math/big".nat, @"".y @"math/big".Word, @"".r @"math/big".Word) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".mulRange(@"".a uint64, @"".b uint64) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".norm() (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".or(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".probablyPrime(@"".reps int) (? bool)
func (? *@"math/big".nat) @"math/big".random(@"".rand *@"math/rand".Rand, @"".limit @"math/big".nat, @"".n int) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".scan(@"".r @"io".RuneScanner, @"".base int) (? @"math/big".nat, ? int, ? error)
func (? *@"math/big".nat) @"math/big".set(@"".x @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".setBit(@"".x @"math/big".nat, @"".i uint, @"".b uint) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".setBytes(@"".buf []byte) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".setUint64(@"".x uint64) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".setWord(@"".x @"math/big".Word) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".shl(@"".x @"math/big".nat, @"".s uint) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".shr(@"".x @"math/big".nat, @"".s uint) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".string(@"".charset string) (? string)
func (? *@"math/big".nat) @"math/big".sub(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
func (? *@"math/big".nat) @"math/big".trailingZeroBits() (? uint)
func (? *@"math/big".nat) @"math/big".xor(@"".x @"math/big".nat, @"".y @"math/big".nat) (? @"math/big".nat)
type @"math/big".Word uintptr
type @"fmt".State interface { @"fmt".Flag(@"".c int) (? bool); @"fmt".Precision() (@"".prec int, @"".ok bool); @"fmt".Width() (@"".wid int, @"".ok bool); @"fmt".Write(@"".b []byte) (@"".ret int, @"".err error) }
type @"math/rand".Rand struct { @"math/rand".src @"math/rand".Source }
func (? *@"math/rand".Rand) @"math/rand".ExpFloat64() (? float64)
func (? *@"math/rand".Rand) @"math/rand".Float32() (? float32)
func (? *@"math/rand".Rand) @"math/rand".Float64() (? float64)
func (? *@"math/rand".Rand) @"math/rand".Int() (? int)
func (? *@"math/rand".Rand) @"math/rand".Int31() (? int32)
func (? *@"math/rand".Rand) @"math/rand".Int31n(@"".n int32) (? int32)
func (? *@"math/rand".Rand) @"math/rand".Int63() (? int64)
func (? *@"math/rand".Rand) @"math/rand".Int63n(@"".n int64) (? int64)
func (? *@"math/rand".Rand) @"math/rand".Intn(@"".n int) (? int)
func (? *@"math/rand".Rand) @"math/rand".NormFloat64() (? float64)
func (? *@"math/rand".Rand) @"math/rand".Perm(@"".n int) (? []int)
func (? *@"math/rand".Rand) @"math/rand".Seed(@"".seed int64) ()
func (? *@"math/rand".Rand) @"math/rand".Uint32() (? uint32)
type @"fmt".ScanState interface { @"fmt".Read(@"".buf []byte) (@"".n int, @"".err error); @"fmt".ReadRune() (@"".r rune, @"".size int, @"".err error); @"fmt".SkipSpace() (); @"fmt".Token(@"".skipSpace bool, @"".f func (? rune) (? bool)) (@"".token []byte, @"".err error); @"fmt".UnreadRune() (? error); @"fmt".Width() (@"".wid int, @"".ok bool) }
type @"io".RuneScanner interface { @"io".ReadRune() (@"".r rune, @"".size int, @"".err error); @"io".UnreadRune() (? error) }
type @"math/big".divisor struct { @"math/big".bbb @"math/big".nat; @"math/big".nbits int; @"math/big".ndigits int }
type @"math/rand".Source interface { @"math/rand".Int63() (? int64); @"math/rand".Seed(@"".seed int64) () }
$$
0ÅØruntimeerrorssync/atomicsynciomathunicode/utf8strconvreflectencoding/binarysyscalltimeosfmt	math/randunicodestringsmath/bigcrypto/elliptic0)0ioio0math/bigbig0syncsync0É›m0Çá Curveh	Curve = go$pkg.Curve = go$newType(0, "Interface", "elliptic.Curve", "Curve", "crypto/elliptic", null);
Ç		Curve.init([["Add", "", (go$funcType([(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false))], ["Double", "", (go$funcType([(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false))], ["IsOnCurve", "", (go$funcType([(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false))], ["Params", "", (go$funcType([], [(go$ptrType(CurveParams))], false))], ["ScalarBaseMult", "", (go$funcType([(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false))], ["ScalarMult", "", (go$funcType([(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false))]]);
0Çk CurveParamsÇ0	CurveParams = go$pkg.CurveParams = go$newType(0, "Struct", "elliptic.CurveParams", "CurveParams", "crypto/elliptic", function(P_, N_, B_, Gx_, Gy_, BitSize_) {
		this.go$val = this;
		this.P = P_ !== undefined ? P_ : (go$ptrType(big.Int)).nil;
		this.N = N_ !== undefined ? N_ : (go$ptrType(big.Int)).nil;
		this.B = B_ !== undefined ? B_ : (go$ptrType(big.Int)).nil;
		this.Gx = Gx_ !== undefined ? Gx_ : (go$ptrType(big.Int)).nil;
		this.Gy = Gy_ !== undefined ? Gy_ : (go$ptrType(big.Int)).nil;
		this.BitSize = BitSize_ !== undefined ? BitSize_ : 0;
	});
Ç$		CurveParams.init([["P", "", (go$ptrType(big.Int)), ""], ["N", "", (go$ptrType(big.Int)), ""], ["B", "", (go$ptrType(big.Int)), ""], ["Gx", "", (go$ptrType(big.Int)), ""], ["Gy", "", (go$ptrType(big.Int)), ""], ["BitSize", "", Go$Int, ""]]);
		(go$ptrType(CurveParams)).methods = [["Add", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["Double", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["IsOnCurve", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false], ["Params", "", [], [(go$ptrType(CurveParams))], false], ["ScalarBaseMult", "", [(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["ScalarMult", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["addJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["affineFromJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["doubleJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false]];
0Çß 	p224CurveÇ	s	p224Curve = go$pkg.p224Curve = go$newType(0, "Struct", "elliptic.p224Curve", "p224Curve", "crypto/elliptic", function(CurveParams_, gx_, gy_, b_) {
		this.go$val = this;
		this.CurveParams = CurveParams_ !== undefined ? CurveParams_ : (go$ptrType(CurveParams)).nil;
		this.gx = gx_ !== undefined ? gx_ : go$makeNativeArray("Uint32", 8, function() { return 0; });
		this.gy = gy_ !== undefined ? gy_ : go$makeNativeArray("Uint32", 8, function() { return 0; });
		this.b = b_ !== undefined ? b_ : go$makeNativeArray("Uint32", 8, function() { return 0; });
	});
	p224Curve.prototype.Add = function(x1, y1, x2, y2) { return this.go$val.Add(x1, y1, x2, y2); };
	p224Curve.Ptr.prototype.Add = function(x1, y1, x2, y2) { return this.CurveParams.Add(x1, y1, x2, y2); };
	p224Curve.prototype.Double = function(x1, y1) { return this.go$val.Double(x1, y1); };
	p224Curve.Ptr.prototype.Double = function(x1, y1) { return this.CurveParams.Double(x1, y1); };
	p224Curve.prototype.IsOnCurve = function(x, y) { return this.go$val.IsOnCurve(x, y); };
	p224Curve.Ptr.prototype.IsOnCurve = function(x, y) { return this.CurveParams.IsOnCurve(x, y); };
	p224Curve.prototype.Params = function() { return this.go$val.Params(); };
	p224Curve.Ptr.prototype.Params = function() { return this.CurveParams.Params(); };
	p224Curve.prototype.ScalarBaseMult = function(k) { return this.go$val.ScalarBaseMult(k); };
	p224Curve.Ptr.prototype.ScalarBaseMult = function(k) { return this.CurveParams.ScalarBaseMult(k); };
	p224Curve.prototype.ScalarMult = function(Bx, By, k) { return this.go$val.ScalarMult(Bx, By, k); };
	p224Curve.Ptr.prototype.ScalarMult = function(Bx, By, k) { return this.CurveParams.ScalarMult(Bx, By, k); };
	p224Curve.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) { return this.go$val.addJacobian(x1, y1, z1, x2, y2, z2); };
	p224Curve.Ptr.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) { return this.CurveParams.addJacobian(x1, y1, z1, x2, y2, z2); };
	p224Curve.prototype.affineFromJacobian = function(x, y, z) { return this.go$val.affineFromJacobian(x, y, z); };
	p224Curve.Ptr.prototype.affineFromJacobian = function(x, y, z) { return this.CurveParams.affineFromJacobian(x, y, z); };
	p224Curve.prototype.doubleJacobian = function(x, y, z) { return this.go$val.doubleJacobian(x, y, z); };
	p224Curve.Ptr.prototype.doubleJacobian = function(x, y, z) { return this.CurveParams.doubleJacobian(x, y, z); };
Ç		p224Curve.init([["", "", (go$ptrType(CurveParams)), ""], ["gx", "crypto/elliptic", p224FieldElement, ""], ["gy", "crypto/elliptic", p224FieldElement, ""], ["b", "crypto/elliptic", p224FieldElement, ""]]);
		p224Curve.methods = [["Add", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["Double", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["IsOnCurve", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false], ["Params", "", [], [(go$ptrType(CurveParams))], false], ["ScalarBaseMult", "", [(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["ScalarMult", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["addJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["affineFromJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["doubleJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false]];
		(go$ptrType(p224Curve)).methods = [["Add", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["Double", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["IsOnCurve", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false], ["Params", "", [], [(go$ptrType(CurveParams))], false], ["ScalarBaseMult", "", [(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["ScalarMult", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["addJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["affineFromJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["doubleJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false]];
0Å– p224FieldElementÅê	p224FieldElement = go$pkg.p224FieldElement = go$newType(0, "Array", "elliptic.p224FieldElement", "p224FieldElement", "crypto/elliptic", null);
'		p224FieldElement.init(Go$Uint32, 8);
0ÅÔ p224LargeFieldElementÅ§	p224LargeFieldElement = go$pkg.p224LargeFieldElement = go$newType(0, "Array", "elliptic.p224LargeFieldElement", "p224LargeFieldElement", "crypto/elliptic", null);
-		p224LargeFieldElement.init(Go$Uint64, 15);
0ÇÁ 	p256CurveÇE	p256Curve = go$pkg.p256Curve = go$newType(0, "Struct", "elliptic.p256Curve", "p256Curve", "crypto/elliptic", function(CurveParams_) {
		this.go$val = this;
		this.CurveParams = CurveParams_ !== undefined ? CurveParams_ : (go$ptrType(CurveParams)).nil;
	});
	p256Curve.prototype.Add = function(x1, y1, x2, y2) { return this.go$val.Add(x1, y1, x2, y2); };
	p256Curve.Ptr.prototype.Add = function(x1, y1, x2, y2) { return this.CurveParams.Add(x1, y1, x2, y2); };
	p256Curve.prototype.Double = function(x1, y1) { return this.go$val.Double(x1, y1); };
	p256Curve.Ptr.prototype.Double = function(x1, y1) { return this.CurveParams.Double(x1, y1); };
	p256Curve.prototype.IsOnCurve = function(x, y) { return this.go$val.IsOnCurve(x, y); };
	p256Curve.Ptr.prototype.IsOnCurve = function(x, y) { return this.CurveParams.IsOnCurve(x, y); };
	p256Curve.prototype.Params = function() { return this.go$val.Params(); };
	p256Curve.Ptr.prototype.Params = function() { return this.CurveParams.Params(); };
	p256Curve.prototype.ScalarBaseMult = function(k) { return this.go$val.ScalarBaseMult(k); };
	p256Curve.Ptr.prototype.ScalarBaseMult = function(k) { return this.CurveParams.ScalarBaseMult(k); };
	p256Curve.prototype.ScalarMult = function(Bx, By, k) { return this.go$val.ScalarMult(Bx, By, k); };
	p256Curve.Ptr.prototype.ScalarMult = function(Bx, By, k) { return this.CurveParams.ScalarMult(Bx, By, k); };
	p256Curve.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) { return this.go$val.addJacobian(x1, y1, z1, x2, y2, z2); };
	p256Curve.Ptr.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) { return this.CurveParams.addJacobian(x1, y1, z1, x2, y2, z2); };
	p256Curve.prototype.affineFromJacobian = function(x, y, z) { return this.go$val.affineFromJacobian(x, y, z); };
	p256Curve.Ptr.prototype.affineFromJacobian = function(x, y, z) { return this.CurveParams.affineFromJacobian(x, y, z); };
	p256Curve.prototype.doubleJacobian = function(x, y, z) { return this.go$val.doubleJacobian(x, y, z); };
	p256Curve.Ptr.prototype.doubleJacobian = function(x, y, z) { return this.CurveParams.doubleJacobian(x, y, z); };
Ç
ç		p256Curve.init([["", "", (go$ptrType(CurveParams)), ""]]);
		p256Curve.methods = [["Add", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["Double", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["IsOnCurve", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false], ["Params", "", [], [(go$ptrType(CurveParams))], false], ["ScalarBaseMult", "", [(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["ScalarMult", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["addJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["affineFromJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["doubleJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false]];
		(go$ptrType(p256Curve)).methods = [["Add", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["Double", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["IsOnCurve", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int))], [Go$Bool], false], ["Params", "", [], [(go$ptrType(CurveParams))], false], ["ScalarBaseMult", "", [(go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["ScalarMult", "", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$sliceType(Go$Uint8))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["addJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["affineFromJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int))], false], ["doubleJacobian", "crypto/elliptic", [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], [(go$ptrType(big.Int)), (go$ptrType(big.Int)), (go$ptrType(big.Int))], false]];
0 mask  02 initonce "		initonce = new sync.Once.Ptr();
04 p384 (		p384 = (go$ptrType(CurveParams)).nil;
04 p521 (		p521 = (go$ptrType(CurveParams)).nil;
0* p224 		p224 = new p224Curve.Ptr();
0 p224P  0 p224ZeroModP31  0 p224ZeroModP63  0* p256 		p256 = new p256Curve.Ptr();
0@ p256RInverse ,		p256RInverse = (go$ptrType(big.Int)).nil;
0 p256One  0 p256Zero  0 p256P  0 p2562P  0 p256Precomputed  0 
p256Zero31  0P   H		mask = new (go$sliceType(Go$Uint8))([255, 1, 3, 7, 15, 31, 63, 127]);
0p   h		p224P = go$toNativeArray("Uint32", [1, 0, 0, 268431360, 268435455, 268435455, 268435455, 268435455]);
0Åù   Åî		p224ZeroModP31 = new (go$sliceType(Go$Uint32))([2147483656, 2147483640, 2147483640, 2147450872, 2147483640, 2147483640, 2147483640, 2147483640]);
0Ç4   Ç*		p224ZeroModP63 = go$toNativeArray("Uint64", [new Go$Uint64(2147483656, 0), new Go$Uint64(2147483640, 0), new Go$Uint64(2147483640, 0), new Go$Uint64(2147483640, 0), new Go$Uint64(2147483639, 4294443008), new Go$Uint64(2147483640, 0), new Go$Uint64(2147483640, 0), new Go$Uint64(2147483640, 0)]);
0t   l		p256One = go$toNativeArray("Uint32", [2, 0, 0, 268433408, 536870911, 268435455, 532676607, 33554431, 0]);
0N   F		p256Zero = go$toNativeArray("Uint32", [0, 0, 0, 0, 0, 0, 0, 0, 0]);
0|   t		p256P = go$toNativeArray("Uint32", [536870911, 268435455, 536870911, 1023, 0, 0, 2097152, 251658240, 268435455]);
0}   u		p2562P = go$toNativeArray("Uint32", [536870910, 268435455, 536870911, 2047, 0, 0, 4194304, 234881024, 536870911]);
0Çø   Çµ		p256Precomputed = go$toNativeArray("Uint32", [290596984, 242421057, 230031737, 78635775, 310917853, 212721032, 295599836, 222981803, 51514350, 489335829, 254096764, 434396381, 96936400, 429049253, 170095751, 22329889, 21696699, 11419619, 222406006, 153287761, 37001551, 101408979, 373655214, 216620824, 535072883, 66729676, 99339564, 188755759, 22835391, 358715996, 94529284, 229187216, 215751807, 513877062, 236641822, 248061730, 40859512, 90604670, 168553630, 37024851, 439480858, 226879324, 90992905, 170293760, 190300240, 10025815, 178796492, 101451666, 217734681, 102476702, 92922779, 10691781, 131522279, 43478603, 532943434, 176956491, 484992866, 215358590, 405915872, 123172065, 496412073, 138651209, 205172986, 115533781, 124205610, 395011560, 67124891, 438243778, 7870186, 258227729, 93078495, 255999938, 425934842, 143782578, 305931036, 74112396, 88539357, 94251799, 388871183, 138291069, 185456137, 265411090, 56389202, 435020300, 219799744, 159190848, 184638233, 71951349, 14748830, 54179201, 90859435, 91714381, 501071970, 207073549, 21607325, 40541819, 204857247, 75982029, 124632266, 212120422, 244515755, 443842791, 92184193, 504621904, 256273651, 116484896, 79311219, 202804275, 365646905, 111382033, 121002173, 187258447, 66509915, 5486974, 321045696, 106813439, 60941558, 350622890, 153379607, 466107082, 182025965, 221826634, 260222982, 54653047, 174775689, 76106445, 166814421, 260313327, 455502422, 14152227, 65063826, 238663282, 111317018, 110789974, 518080, 163043539, 3185280, 449863551, 204453341, 213898269, 164542008, 273777244, 228642651, 135456897, 116610665, 111505196, 502845828, 3430432, 343397495, 23354801, 199756881, 203603518, 238413402, 451639968, 204952341, 258456729, 134076345, 421511614, 6366045, 46236905, 29730873, 75111974, 192722006, 155066973, 351520493, 214702793, 402536435, 77105545, 445695234, 49487938, 169309851, 184388732, 135863406, 500019767, 23199936, 276509345, 107743451, 282094082, 261267, 90308643, 376580903, 109796441, 40959228, 262999756, 241033666, 246105707, 50090300, 67630940, 195735859, 158359529, 193509607, 120899987, 31588239, 420833648, 180162304, 273063591, 53033664, 215783594, 30950397, 236240872, 364806751, 9130514, 246676327, 136101161, 197537558, 45546695, 257576489, 324406118, 202074818, 85649040, 222421617, 255761364, 30870187, 16949106, 121510965, 250023868, 181935023, 166511770, 141325342, 266780208, 392647399, 2348054, 528735877, 41804168, 107966648, 404542751, 158035532, 412033845, 173930329, 396852918, 267062899, 357230868, 49540177, 58878809, 194113917, 29829449, 325238538, 237239775, 173413552, 1015183, 495713, 136567250, 136396601, 287878667, 218717445, 193315010, 32289519, 38657156, 238414081, 406919754, 257809469, 58222217, 86139112, 95303012, 88256781, 148453957, 429206180, 160877633, 273786665, 79574169, 86713258, 278868094, 116766395, 528802279, 125439226, 281337663, 39453418, 184844341, 238149222, 208587427, 42902325, 42491940, 326299680, 16080181, 367290444, 254451223, 441087273, 213368497, 187332769, 447880991, 104209615, 113842077, 185816615, 308787572, 71338925, 482342488, 238904593, 13096815, 30177897, 243196699, 89107279, 2855247, 450001456, 215177118, 206574156, 84781712, 11616114, 184986229, 118447302, 373941674, 139088658, 53019708, 68960273, 332604433, 184854584, 225840429, 387167538, 195693571, 138420907, 113046977, 49566585, 25878640, 415883550, 34327194, 107956587, 65991316, 108331218, 226451772, 2997227, 192155704, 235148095, 360879757, 199853559, 28097562, 443192223, 54415606, 224812756, 189496278, 509228953, 112408647, 402282239, 106887472, 2219082, 45315673, 72416791, 188054373, 234221484, 356088815, 164846207, 288014687, 103081518, 177253935, 276753618, 32938942, 125660110, 91493268, 331777276, 156289296, 119886379, 231179651, 68086459, 534655626, 198581654, 220775303, 166165897, 307563584, 123325309, 57143092, 182626656, 152800220, 154428073, 16017903, 187603695, 221030257, 89005890, 8038985, 103901883, 37829774, 88235001, 468532794, 254222964, 526283558, 104949015, 245526642, 164552359, 7239219, 130619730, 226520526, 149071841, 239214106, 68733409, 31180944, 456743990, 169722229, 499445619, 144011060, 239820018, 453851672, 51989046, 113402911, 239342156, 170872490, 176956858, 261258967, 103265812, 121052362, 195126932, 68664323, 130066403, 163798041, 292069893, 146190349, 283373001, 163683314, 92807721, 455819618, 173862682, 356737579, 163398462, 56942669, 122161042, 97105331, 243662629, 67694423, 404017060, 18986011, 220498447, 61887010, 60535146, 209032813, 168001811, 172627817, 18857068, 152560910, 250363304, 379416236, 17569433, 172056915, 259148050, 365781175, 78428889, 99599866, 253038295, 1190737, 285520906, 213382210, 263923967, 111956938, 425804492, 129961897, 9795153, 81850901, 248789496, 66350037, 95217711, 285808310, 7188600, 268270935, 254724780, 212364780, 366392026, 157674697, 479376578, 2045969, 481329397, 47757316, 433176877, 253803846, 26550183, 171333315, 86221861, 265094802, 222617032, 320802651, 184028746, 215612532, 161199640, 47944780, 174534800, 29495521, 395087139, 21447555, 280523837, 159753563, 48711545, 5726520, 156793127, 321990906, 199251222, 167040537, 196486512, 161400209, 227830014, 487028781, 264711691, 117551768, 409175611, 140072120, 303696950, 166199007, 258257961, 163174174, 350418392, 260410682, 155381416, 228964197, 116240383, 178067660, 208004282, 477396614, 240036117, 427939745, 137975385, 86955234, 142427063, 58372379, 433230542, 260916882, 415434047, 143015443, 79775424, 113112410, 82068861, 370483849, 180850370, 442090914, 33721239, 119287041, 43353375, 67400827, 142103949, 131242660, 332936223, 148565975, 329029421, 112716405, 222993886, 267477976, 136140247, 173797224, 192622808, 199703919, 178815297, 228027521, 132622796, 415151985, 225918141, 334829905, 164675959, 29661816]);
0Å°   Åò		p256Zero31 = go$toNativeArray("Uint32", [2147483640, 1073741820, 2147483644, 1073750012, 2147483644, 1073741820, 2164260860, 939524092, 2147483644]);
0Å∏  ÅØ	CurveParams.Ptr.prototype.Params = function() {
		var curve;
		curve = this;
		return curve;
	};
	CurveParams.prototype.Params = function() { return this.go$val.Params(); };
 0Çﬁ  Ç‘	CurveParams.Ptr.prototype.IsOnCurve = function(x, y) {
		var curve, y2, x3, threeX;
		curve = this;
		y2 = new big.Int.Ptr().Mul(y, y);
		y2.Mod(y2, curve.P);
		x3 = new big.Int.Ptr().Mul(x, x);
		x3.Mul(x3, x);
		threeX = new big.Int.Ptr().Lsh(x, 1);
		threeX.Add(threeX, x);
		x3.Sub(x3, threeX);
		x3.Add(x3, curve.B);
		x3.Mod(x3, curve.P);
		return x3.Cmp(y2) === 0;
	};
	CurveParams.prototype.IsOnCurve = function(x, y) { return this.go$val.IsOnCurve(x, y); };
 0Åø 
zForAffineÅ¨	zForAffine = function(x, y) {
		var z;
		z = new big.Int.Ptr();
		if (!((x.Sign() === 0)) || !((y.Sign() === 0))) {
			z.SetInt64(new Go$Int64(0, 1));
		}
		return z;
	};
 0Ç¯  ÇÓ	CurveParams.Ptr.prototype.affineFromJacobian = function(x, y, z) {
		var xOut, yOut, curve, _tuple, zinv, zinvsq;
		xOut = (go$ptrType(big.Int)).nil;
		yOut = (go$ptrType(big.Int)).nil;
		curve = this;
		if (z.Sign() === 0) {
			_tuple = [new big.Int.Ptr(), new big.Int.Ptr()], xOut = _tuple[0], yOut = _tuple[1];
			return [xOut, yOut];
		}
		zinv = new big.Int.Ptr().ModInverse(z, curve.P);
		zinvsq = new big.Int.Ptr().Mul(zinv, zinv);
		xOut = new big.Int.Ptr().Mul(x, zinvsq);
		xOut.Mod(xOut, curve.P);
		zinvsq.Mul(zinvsq, zinv);
		yOut = new big.Int.Ptr().Mul(y, zinvsq);
		yOut.Mod(yOut, curve.P);
		return [xOut, yOut];
	};
	CurveParams.prototype.affineFromJacobian = function(x, y, z) { return this.go$val.affineFromJacobian(x, y, z); };
 0Çä  ÇÄ	CurveParams.Ptr.prototype.Add = function(x1, y1, x2, y2) {
		var curve, z1, z2, _tuple;
		curve = this;
		z1 = zForAffine(x1, y1);
		z2 = zForAffine(x2, y2);
		return (_tuple = curve.addJacobian(x1, y1, z1, x2, y2, z2), curve.affineFromJacobian(_tuple[0], _tuple[1], _tuple[2]));
	};
	CurveParams.prototype.Add = function(x1, y1, x2, y2) { return this.go$val.Add(x1, y1, x2, y2); };
 0ÇN  ÇD	CurveParams.Ptr.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) {
		var curve, _tuple, x3, y3, z3, z1z1, z2z2, u1, u2, h, xEqual, i, j, s1, s2, r, yEqual, v;
		curve = this;
		_tuple = [new big.Int.Ptr(), new big.Int.Ptr(), new big.Int.Ptr()], x3 = _tuple[0], y3 = _tuple[1], z3 = _tuple[2];
		if (z1.Sign() === 0) {
			x3.Set(x2);
			y3.Set(y2);
			z3.Set(z2);
			return [x3, y3, z3];
		}
		if (z2.Sign() === 0) {
			x3.Set(x1);
			y3.Set(y1);
			z3.Set(z1);
			return [x3, y3, z3];
		}
		z1z1 = new big.Int.Ptr().Mul(z1, z1);
		z1z1.Mod(z1z1, curve.P);
		z2z2 = new big.Int.Ptr().Mul(z2, z2);
		z2z2.Mod(z2z2, curve.P);
		u1 = new big.Int.Ptr().Mul(x1, z2z2);
		u1.Mod(u1, curve.P);
		u2 = new big.Int.Ptr().Mul(x2, z1z1);
		u2.Mod(u2, curve.P);
		h = new big.Int.Ptr().Sub(u2, u1);
		xEqual = h.Sign() === 0;
		if (h.Sign() === -1) {
			h.Add(h, curve.P);
		}
		i = new big.Int.Ptr().Lsh(h, 1);
		i.Mul(i, i);
		j = new big.Int.Ptr().Mul(h, i);
		s1 = new big.Int.Ptr().Mul(y1, z2);
		s1.Mul(s1, z2z2);
		s1.Mod(s1, curve.P);
		s2 = new big.Int.Ptr().Mul(y2, z1);
		s2.Mul(s2, z1z1);
		s2.Mod(s2, curve.P);
		r = new big.Int.Ptr().Sub(s2, s1);
		if (r.Sign() === -1) {
			r.Add(r, curve.P);
		}
		yEqual = r.Sign() === 0;
		if (xEqual && yEqual) {
			return curve.doubleJacobian(x1, y1, z1);
		}
		r.Lsh(r, 1);
		v = new big.Int.Ptr().Mul(u1, i);
		x3.Set(r);
		x3.Mul(x3, x3);
		x3.Sub(x3, j);
		x3.Sub(x3, v);
		x3.Sub(x3, v);
		x3.Mod(x3, curve.P);
		y3.Set(r);
		v.Sub(v, x3);
		y3.Mul(y3, v);
		s1.Mul(s1, j);
		s1.Lsh(s1, 1);
		y3.Sub(y3, s1);
		y3.Mod(y3, curve.P);
		z3.Add(z1, z2);
		z3.Mul(z3, z3);
		z3.Sub(z3, z1z1);
		z3.Sub(z3, z2z2);
		z3.Mul(z3, h);
		z3.Mod(z3, curve.P);
		return [x3, y3, z3];
	};
	CurveParams.prototype.addJacobian = function(x1, y1, z1, x2, y2, z2) { return this.go$val.addJacobian(x1, y1, z1, x2, y2, z2); };
 0ÇS  ÇI	CurveParams.Ptr.prototype.Double = function(x1, y1) {
		var curve, z1, _tuple;
		curve = this;
		z1 = zForAffine(x1, y1);
		return (_tuple = curve.doubleJacobian(x1, y1, z1), curve.affineFromJacobian(_tuple[0], _tuple[1], _tuple[2]));
	};
	CurveParams.prototype.Double = function(x1, y1) { return this.go$val.Double(x1, y1); };
 0Çô  Çè	CurveParams.Ptr.prototype.doubleJacobian = function(x, y, z) {
		var curve, delta, gamma, alpha, alpha2, beta, x3, beta8, z3, y3;
		curve = this;
		delta = new big.Int.Ptr().Mul(z, z);
		delta.Mod(delta, curve.P);
		gamma = new big.Int.Ptr().Mul(y, y);
		gamma.Mod(gamma, curve.P);
		alpha = new big.Int.Ptr().Sub(x, delta);
		if (alpha.Sign() === -1) {
			alpha.Add(alpha, curve.P);
		}
		alpha2 = new big.Int.Ptr().Add(x, delta);
		alpha.Mul(alpha, alpha2);
		alpha2.Set(alpha);
		alpha.Lsh(alpha, 1);
		alpha.Add(alpha, alpha2);
		beta = alpha2.Mul(x, gamma);
		x3 = new big.Int.Ptr().Mul(alpha, alpha);
		beta8 = new big.Int.Ptr().Lsh(beta, 3);
		x3.Sub(x3, beta8);
		while (x3.Sign() === -1) {
			x3.Add(x3, curve.P);
		}
		x3.Mod(x3, curve.P);
		z3 = new big.Int.Ptr().Add(y, z);
		z3.Mul(z3, z3);
		z3.Sub(z3, gamma);
		if (z3.Sign() === -1) {
			z3.Add(z3, curve.P);
		}
		z3.Sub(z3, delta);
		if (z3.Sign() === -1) {
			z3.Add(z3, curve.P);
		}
		z3.Mod(z3, curve.P);
		beta.Lsh(beta, 2);
		beta.Sub(beta, x3);
		if (beta.Sign() === -1) {
			beta.Add(beta, curve.P);
		}
		y3 = alpha.Mul(alpha, beta);
		gamma.Mul(gamma, gamma);
		gamma.Lsh(gamma, 3);
		gamma.Mod(gamma, curve.P);
		y3.Sub(y3, gamma);
		if (y3.Sign() === -1) {
			y3.Add(y3, curve.P);
		}
		y3.Mod(y3, curve.P);
		return [x3, y3, z3];
	};
	CurveParams.prototype.doubleJacobian = function(x, y, z) { return this.go$val.doubleJacobian(x, y, z); };
 0ÇM  ÇC	CurveParams.Ptr.prototype.ScalarMult = function(Bx, By, k) {
		var curve, Bz, _tuple, x, y, z, _ref, _i, _slice, _index, byte$1, bitNum, _tuple$1, _tuple$2;
		curve = this;
		Bz = new big.Int.Ptr().SetInt64(new Go$Int64(0, 1));
		_tuple = [new big.Int.Ptr(), new big.Int.Ptr(), new big.Int.Ptr()], x = _tuple[0], y = _tuple[1], z = _tuple[2];
		_ref = k;
		_i = 0;
		while (_i < _ref.length) {
			byte$1 = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			bitNum = 0;
			while (bitNum < 8) {
				_tuple$1 = curve.doubleJacobian(x, y, z), x = _tuple$1[0], y = _tuple$1[1], z = _tuple$1[2];
				if (((byte$1 & 128) >>> 0) === 128) {
					_tuple$2 = curve.addJacobian(Bx, By, Bz, x, y, z), x = _tuple$2[0], y = _tuple$2[1], z = _tuple$2[2];
				}
				byte$1 = byte$1 << 1 << 24 >>> 24;
				bitNum = bitNum + 1 >> 0;
			}
			_i++;
		}
		return curve.affineFromJacobian(x, y, z);
	};
	CurveParams.prototype.ScalarMult = function(Bx, By, k) { return this.go$val.ScalarMult(Bx, By, k); };
 0Åı  ÅÏ	CurveParams.Ptr.prototype.ScalarBaseMult = function(k) {
		var curve;
		curve = this;
		return curve.ScalarMult(curve.Gx, curve.Gy, k);
	};
	CurveParams.prototype.ScalarBaseMult = function(k) { return this.go$val.ScalarBaseMult(k); };
 0Ç] GenerateKeyÇH	GenerateKey = go$pkg.GenerateKey = function(curve, rand) {
		var priv, x, y, err, bitSize, byteLen, _tuple, _lhs, _index, _slice, _index$1, _slice$1, _index$2, _r, _slice$2, _index$3, _lhs$1, _index$4, _slice$3, _index$5, _slice$4, _index$6, _tuple$1;
		priv = (go$sliceType(Go$Uint8)).nil;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		err = null;
		bitSize = curve.Params().BitSize;
		byteLen = ((bitSize + 7 >> 0)) >> 3 >> 0;
		priv = (go$sliceType(Go$Uint8)).make(byteLen, 0, function() { return 0; });
		while (x === (go$ptrType(big.Int)).nil) {
			_tuple = io.ReadFull(rand, priv), err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [priv, x, y, err];
			}
			_lhs = priv, _index = 0, _slice$2 = _lhs, _index$3 = _index, (_index$3 >= 0 && _index$3 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$3] = ((_slice = _lhs, _index$1 = _index, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) & ((_slice$1 = mask, _index$2 = (_r = bitSize % 8, _r === _r ? _r : go$throwRuntimeError("integer divide by zero")), (_index$2 >= 0 && _index$2 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$2] : go$throwRuntimeError("index out of range")))) >>> 0) : go$throwRuntimeError("index out of range");
			_lhs$1 = priv, _index$4 = 1, _slice$4 = _lhs$1, _index$6 = _index$4, (_index$6 >= 0 && _index$6 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$6] = ((_slice$3 = _lhs$1, _index$5 = _index$4, (_index$5 >= 0 && _index$5 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$5] : go$throwRuntimeError("index out of range")) ^ 66) << 24 >>> 24) : go$throwRuntimeError("index out of range");
			_tuple$1 = curve.ScalarBaseMult(priv), x = _tuple$1[0], y = _tuple$1[1];
		}
		return [priv, x, y, err];
	};
 0Ç5 MarshalÇ$	Marshal = go$pkg.Marshal = function(curve, x, y) {
		var byteLen, x$1, ret, _slice, _index, xBytes, yBytes, x$2;
		byteLen = ((curve.Params().BitSize + 7 >> 0)) >> 3 >> 0;
		ret = (go$sliceType(Go$Uint8)).make(1 + (x$1 = 2, (((x$1 >>> 16 << 16) * byteLen >> 0) + (x$1 << 16 >>> 16) * byteLen) >> 0) >> 0, 0, function() { return 0; });
		_slice = ret, _index = 0, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 4) : go$throwRuntimeError("index out of range");
		xBytes = x.Bytes();
		go$copySlice(go$subslice(ret, ((1 + byteLen >> 0) - xBytes.length >> 0)), xBytes);
		yBytes = y.Bytes();
		go$copySlice(go$subslice(ret, ((1 + (x$2 = 2, (((x$2 >>> 16 << 16) * byteLen >> 0) + (x$2 << 16 >>> 16) * byteLen) >> 0) >> 0) - yBytes.length >> 0)), yBytes);
		return ret;
	};
 0ÇÛ 	UnmarshalÇ‡	Unmarshal = go$pkg.Unmarshal = function(curve, data) {
		var x, y, byteLen, x$1, _slice, _index;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		byteLen = ((curve.Params().BitSize + 7 >> 0)) >> 3 >> 0;
		if (!((data.length === (1 + (x$1 = 2, (((x$1 >>> 16 << 16) * byteLen >> 0) + (x$1 << 16 >>> 16) * byteLen) >> 0) >> 0)))) {
			return [x, y];
		}
		if (!(((_slice = data, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) === 4))) {
			return [x, y];
		}
		x = new big.Int.Ptr().SetBytes(go$subslice(data, 1, (1 + byteLen >> 0)));
		y = new big.Int.Ptr().SetBytes(go$subslice(data, (1 + byteLen >> 0)));
		return [x, y];
	};
 0c initAllT	initAll = function() {
		initP224();
		initP256();
		initP384();
		initP521();
	};
 0Ç	 initP384Ç˜	initP384 = function() {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4;
		p384 = new CurveParams.Ptr();
		_tuple = new big.Int.Ptr().SetString("39402006196394479212279040100143613805079739270465446667948293404245721771496870329047266088258938001861606973112319", 10), p384.P = _tuple[0];
		_tuple$1 = new big.Int.Ptr().SetString("39402006196394479212279040100143613805079739270465446667946905279627659399113263569398956308152294913554433653942643", 10), p384.N = _tuple$1[0];
		_tuple$2 = new big.Int.Ptr().SetString("b3312fa7e23ee7e4988e056be3f82d19181d9c6efe8141120314088f5013875ac656398d8a2ed19d2a85c8edd3ec2aef", 16), p384.B = _tuple$2[0];
		_tuple$3 = new big.Int.Ptr().SetString("aa87ca22be8b05378eb1c71ef320ad746e1d3b628ba79b9859f741e082542a385502f25dbf55296c3a545e3872760ab7", 16), p384.Gx = _tuple$3[0];
		_tuple$4 = new big.Int.Ptr().SetString("3617de4a96262c6f5d9e98bf9292dc29f8f41dbd289a147ce9da3113b5f0b8c00a60b1ce1d7e819d7a431d7c90ea0e5f", 16), p384.Gy = _tuple$4[0];
		p384.BitSize = 384;
	};
 0Ç√ initP521Ç±	initP521 = function() {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4;
		p521 = new CurveParams.Ptr();
		_tuple = new big.Int.Ptr().SetString("6864797660130609714981900799081393217269435300143305409394463459185543183397656052122559640661454554977296311391480858037121987999716643812574028291115057151", 10), p521.P = _tuple[0];
		_tuple$1 = new big.Int.Ptr().SetString("6864797660130609714981900799081393217269435300143305409394463459185543183397655394245057746333217197532963996371363321113864768612440380340372808892707005449", 10), p521.N = _tuple$1[0];
		_tuple$2 = new big.Int.Ptr().SetString("051953eb9618e1c9a1f929a21a0b68540eea2da725b99b315f3b8b489918ef109e156193951ec7e937b1652c0bd3bb1bf073573df883d2c34f1ef451fd46b503f00", 16), p521.B = _tuple$2[0];
		_tuple$3 = new big.Int.Ptr().SetString("c6858e06b70404e9cd9e3ecb662395b4429c648139053fb521f828af606b4d3dbaa14b5e77efe75928fe1dc127a2ffa8de3348b3c1856a429bf97e7e31c2e5bd66", 16), p521.Gx = _tuple$3[0];
		_tuple$4 = new big.Int.Ptr().SetString("11839296a789a3bc0045c8a5fb42c7d1bd998f54449579b446817afbd17273e662c97ee72995ef42640c550b9013fad0761353c7086a272c24088be94769fd16650", 16), p521.Gy = _tuple$4[0];
		p521.BitSize = 521;
	};
 0w P256k	P256 = go$pkg.P256 = function() {
		initonce.Do(initAll);
		return new p256.constructor.Struct(p256);
	};
 0Z P384N	P384 = go$pkg.P384 = function() {
		initonce.Do(initAll);
		return p384;
	};
 0Z P521N	P521 = go$pkg.P521 = function() {
		initonce.Do(initAll);
		return p521;
	};
 0Ç
 initP224Ç¯	initP224 = function() {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4;
		p224.CurveParams = new CurveParams.Ptr();
		_tuple = new big.Int.Ptr().SetString("26959946667150639794667015087019630673557916260026308143510066298881", 10), p224.CurveParams.P = _tuple[0];
		_tuple$1 = new big.Int.Ptr().SetString("26959946667150639794667015087019625940457807714424391721682722368061", 10), p224.CurveParams.N = _tuple$1[0];
		_tuple$2 = new big.Int.Ptr().SetString("b4050a850c04b3abf54132565044b0b7d7bfd8ba270b39432355ffb4", 16), p224.CurveParams.B = _tuple$2[0];
		_tuple$3 = new big.Int.Ptr().SetString("b70e0cbd6bb4bf7f321390b94a03c1d356c21122343280d6115c1d21", 16), p224.CurveParams.Gx = _tuple$3[0];
		_tuple$4 = new big.Int.Ptr().SetString("bd376388b5f723fb4c22dfe6cd4375a05a07476444d5819985007e34", 16), p224.CurveParams.Gy = _tuple$4[0];
		p224.CurveParams.BitSize = 224;
		p224FromBig(p224.gx, p224.CurveParams.Gx);
		p224FromBig(p224.gy, p224.CurveParams.Gy);
		p224FromBig(p224.b, p224.CurveParams.B);
	};
 0w P224k	P224 = go$pkg.P224 = function() {
		initonce.Do(initAll);
		return new p224.constructor.Struct(p224);
	};
 0Ç±  Çß	p224Curve.Ptr.prototype.Params = function() {
		var _struct, curve;
		curve = (_struct = this, new p224Curve.Ptr(_struct.CurveParams, go$mapArray(_struct.gx, function(entry) { return entry; }), go$mapArray(_struct.gy, function(entry) { return entry; }), go$mapArray(_struct.b, function(entry) { return entry; })));
		return curve.CurveParams;
	};
	p224Curve.prototype.Params = function() { return this.go$val.Params(); };
 0Ç\  ÇR	p224Curve.Ptr.prototype.IsOnCurve = function(bigX, bigY) {
		var _struct, curve, _tuple, x, y, tmp, x3, i, _lhs, _index, x$1, x$2, i$1;
		curve = (_struct = this, new p224Curve.Ptr(_struct.CurveParams, go$mapArray(_struct.gx, function(entry) { return entry; }), go$mapArray(_struct.gy, function(entry) { return entry; }), go$mapArray(_struct.b, function(entry) { return entry; })));
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], x = _tuple[0], y = _tuple[1];
		p224FromBig(x, bigX);
		p224FromBig(y, bigY);
		tmp = go$makeNativeArray("Uint64", 15, function() { return new Go$Uint64(0, 0); });
		x3 = go$makeNativeArray("Uint32", 8, function() { return 0; });
		p224Square(x3, x, tmp);
		p224Mul(x3, x3, x, tmp);
		i = 0;
		while (i < 8) {
			_lhs = x, _index = i, _lhs[_index] = (x$1 = _lhs[_index], x$2 = 3, (((x$1 >>> 16 << 16) * x$2 >>> 0) + (x$1 << 16 >>> 16) * x$2) >>> 0);
			i = i + 1 >> 0;
		}
		p224Sub(x3, x3, x);
		p224Reduce(x3);
		p224Add(x3, x3, curve.b);
		p224Contract(x3, x3);
		p224Square(y, y, tmp);
		p224Contract(y, y);
		i$1 = 0;
		while (i$1 < 8) {
			if (!((y[i$1] === x3[i$1]))) {
				return false;
			}
			i$1 = i$1 + 1 >> 0;
		}
		return true;
	};
	p224Curve.prototype.IsOnCurve = function(bigX, bigY) { return this.go$val.IsOnCurve(bigX, bigY); };
 0Çñ  Çå	p224Curve.Ptr.prototype.Add = function(bigX1, bigY1, bigX2, bigY2) {
		var x, y, _tuple, x1, y1, z1, x2, y2, z2, x3, y3, z3, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], x1 = _tuple[0], y1 = _tuple[1], z1 = _tuple[2], x2 = _tuple[3], y2 = _tuple[4], z2 = _tuple[5], x3 = _tuple[6], y3 = _tuple[7], z3 = _tuple[8];
		p224FromBig(x1, bigX1);
		p224FromBig(y1, bigY1);
		if (!((bigX1.Sign() === 0)) || !((bigY1.Sign() === 0))) {
			z1[0] = 1;
		}
		p224FromBig(x2, bigX2);
		p224FromBig(y2, bigY2);
		if (!((bigX2.Sign() === 0)) || !((bigY2.Sign() === 0))) {
			z2[0] = 1;
		}
		p224AddJacobian(x3, y3, z3, x1, y1, z1, x2, y2, z2);
		_tuple$1 = p224ToAffine(x3, y3, z3), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p224Curve.prototype.Add = function(bigX1, bigY1, bigX2, bigY2) { return this.go$val.Add(bigX1, bigY1, bigX2, bigY2); };
 0Çº  Ç≤	p224Curve.Ptr.prototype.Double = function(bigX1, bigY1) {
		var x, y, _tuple, x1, y1, z1, x2, y2, z2, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], x1 = _tuple[0], y1 = _tuple[1], z1 = _tuple[2], x2 = _tuple[3], y2 = _tuple[4], z2 = _tuple[5];
		p224FromBig(x1, bigX1);
		p224FromBig(y1, bigY1);
		z1[0] = 1;
		p224DoubleJacobian(x2, y2, z2, x1, y1, z1);
		_tuple$1 = p224ToAffine(x2, y2, z2), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p224Curve.prototype.Double = function(bigX1, bigY1) { return this.go$val.Double(bigX1, bigY1); };
 0Ç‰  Ç⁄	p224Curve.Ptr.prototype.ScalarMult = function(bigX1, bigY1, scalar) {
		var x, y, _tuple, x1, y1, z1, x2, y2, z2, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], x1 = _tuple[0], y1 = _tuple[1], z1 = _tuple[2], x2 = _tuple[3], y2 = _tuple[4], z2 = _tuple[5];
		p224FromBig(x1, bigX1);
		p224FromBig(y1, bigY1);
		z1[0] = 1;
		p224ScalarMult(x2, y2, z2, x1, y1, z1, scalar);
		_tuple$1 = p224ToAffine(x2, y2, z2), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p224Curve.prototype.ScalarMult = function(bigX1, bigY1, scalar) { return this.go$val.ScalarMult(bigX1, bigY1, scalar); };
 0Ç  Ç˝	p224Curve.Ptr.prototype.ScalarBaseMult = function(scalar) {
		var x, y, _struct, curve, _tuple, z1, x2, y2, z2, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		curve = (_struct = this, new p224Curve.Ptr(_struct.CurveParams, go$mapArray(_struct.gx, function(entry) { return entry; }), go$mapArray(_struct.gy, function(entry) { return entry; }), go$mapArray(_struct.b, function(entry) { return entry; })));
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], z1 = _tuple[0], x2 = _tuple[1], y2 = _tuple[2], z2 = _tuple[3];
		z1[0] = 1;
		p224ScalarMult(x2, y2, z2, curve.gx, curve.gy, z1, scalar);
		_tuple$1 = p224ToAffine(x2, y2, z2), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p224Curve.prototype.ScalarBaseMult = function(scalar) { return this.go$val.ScalarBaseMult(scalar); };
 0ÇÌ 
p224IsZeroÇŸ	p224IsZero = function(a) {
		var minimal, _tuple, isZero, isP, _ref, _i, v, i, result;
		minimal = go$makeNativeArray("Uint32", 8, function() { return 0; });
		p224Contract(minimal, a);
		_tuple = [0, 0], isZero = _tuple[0], isP = _tuple[1];
		_ref = minimal;
		_i = 0;
		while (_i < 8) {
			v = _ref[_i];
			i = _i;
			isZero = (isZero | (v)) >>> 0;
			isP = (isP | ((v - p224P[i] >>> 0))) >>> 0;
			_i++;
		}
		isZero = (isZero | ((isZero >>> 16 >>> 0))) >>> 0;
		isZero = (isZero | ((isZero >>> 8 >>> 0))) >>> 0;
		isZero = (isZero | ((isZero >>> 4 >>> 0))) >>> 0;
		isZero = (isZero | ((isZero >>> 2 >>> 0))) >>> 0;
		isZero = (isZero | ((isZero >>> 1 >>> 0))) >>> 0;
		isP = (isP | ((isP >>> 16 >>> 0))) >>> 0;
		isP = (isP | ((isP >>> 8 >>> 0))) >>> 0;
		isP = (isP | ((isP >>> 4 >>> 0))) >>> 0;
		isP = (isP | ((isP >>> 2 >>> 0))) >>> 0;
		isP = (isP | ((isP >>> 1 >>> 0))) >>> 0;
		result = (isZero & isP) >>> 0;
		result = (((~result >>> 0)) & 1) >>> 0;
		return result;
	};
 0Åé p224Add	p224Add = function(out, a, b) {
		var i;
		i = 0;
		while (i < 8) {
			out[i] = a[i] + b[i] >>> 0;
			i = i + 1 >> 0;
		}
	};
 0ÇM p224SubÇ<	p224Sub = function(out, a, b) {
		var i, _slice, _index;
		i = 0;
		while (i < 8) {
			out[i] = (a[i] + (_slice = p224ZeroModP31, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >>> 0) - b[i] >>> 0;
			i = i + 1 >> 0;
		}
	};
 0Ç p224MulÇÒ	p224Mul = function(out, a, b, tmp) {
		var i, i$1, j, _lhs, _index, x, x$1;
		i = 0;
		while (i < 15) {
			tmp[i] = new Go$Uint64(0, 0);
			i = i + 1 >> 0;
		}
		i$1 = 0;
		while (i$1 < 8) {
			j = 0;
			while (j < 8) {
				_lhs = tmp, _index = i$1 + j >> 0, _lhs[_index] = (x = _lhs[_index], x$1 = go$mul64(new Go$Uint64(0, a[i$1]), new Go$Uint64(0, b[j])), new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
				j = j + 1 >> 0;
			}
			i$1 = i$1 + 1 >> 0;
		}
		p224ReduceLarge(out, tmp);
	};
 0Ç 
p224SquareÇÛ	p224Square = function(out, a, tmp) {
		var i, i$1, j, r, _lhs, _index, x, x$1, _lhs$1, _index$1, x$2, x$3;
		i = 0;
		while (i < 15) {
			tmp[i] = new Go$Uint64(0, 0);
			i = i + 1 >> 0;
		}
		i$1 = 0;
		while (i$1 < 8) {
			j = 0;
			while (j <= i$1) {
				r = go$mul64(new Go$Uint64(0, a[i$1]), new Go$Uint64(0, a[j]));
				if (i$1 === j) {
					_lhs = tmp, _index = i$1 + j >> 0, _lhs[_index] = (x = _lhs[_index], x$1 = r, new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
				} else {
					_lhs$1 = tmp, _index$1 = i$1 + j >> 0, _lhs$1[_index$1] = (x$2 = _lhs$1[_index$1], x$3 = go$shiftLeft64(r, 1), new Go$Uint64(x$2.high + x$3.high, x$2.low + x$3.low));
				}
				j = j + 1 >> 0;
			}
			i$1 = i$1 + 1 >> 0;
		}
		p224ReduceLarge(out, tmp);
	};
 0Ç	ä p224ReduceLargeÇ	q	p224ReduceLarge = function(out, in$1) {
		var i, _lhs, _index, x, x$1, i$1, _lhs$1, _index$1, x$2, x$3, _lhs$2, _index$2, x$4, x$5, x$6, _lhs$3, _index$3, x$7, x$8, i$2, _lhs$4, _index$4, x$9, x$10, x$11, _lhs$5, _index$5, x$12, x$13, _lhs$6, _index$6, x$14, _lhs$7, _index$7, x$15, _lhs$8, _index$8, x$16, _lhs$9, _index$9;
		i = 0;
		while (i < 8) {
			_lhs = in$1, _index = i, _lhs[_index] = (x = _lhs[_index], x$1 = p224ZeroModP63[i], new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
			i = i + 1 >> 0;
		}
		i$1 = 14;
		while (i$1 >= 8) {
			_lhs$1 = in$1, _index$1 = i$1 - 8 >> 0, _lhs$1[_index$1] = (x$2 = _lhs$1[_index$1], x$3 = in$1[i$1], new Go$Uint64(x$2.high - x$3.high, x$2.low - x$3.low));
			_lhs$2 = in$1, _index$2 = i$1 - 5 >> 0, _lhs$2[_index$2] = (x$4 = _lhs$2[_index$2], x$5 = go$shiftLeft64(((x$6 = in$1[i$1], new Go$Uint64(x$6.high & 0, (x$6.low & 65535) >>> 0))), 12), new Go$Uint64(x$4.high + x$5.high, x$4.low + x$5.low));
			_lhs$3 = in$1, _index$3 = i$1 - 4 >> 0, _lhs$3[_index$3] = (x$7 = _lhs$3[_index$3], x$8 = go$shiftRightUint64(in$1[i$1], 16), new Go$Uint64(x$7.high + x$8.high, x$7.low + x$8.low));
			i$1 = i$1 - 1 >> 0;
		}
		in$1[8] = new Go$Uint64(0, 0);
		i$2 = 1;
		while (i$2 < 8) {
			_lhs$4 = in$1, _index$4 = i$2 + 1 >> 0, _lhs$4[_index$4] = (x$9 = _lhs$4[_index$4], x$10 = go$shiftRightUint64(in$1[i$2], 28), new Go$Uint64(x$9.high + x$10.high, x$9.low + x$10.low));
			out[i$2] = ((x$11 = in$1[i$2], new Go$Uint64(x$11.high & 0, (x$11.low & 268435455) >>> 0)).low >>> 0);
			i$2 = i$2 + 1 >> 0;
		}
		_lhs$5 = in$1, _index$5 = 0, _lhs$5[_index$5] = (x$12 = _lhs$5[_index$5], x$13 = in$1[8], new Go$Uint64(x$12.high - x$13.high, x$12.low - x$13.low));
		_lhs$6 = out, _index$6 = 3, _lhs$6[_index$6] = _lhs$6[_index$6] + ((((x$14 = in$1[8], new Go$Uint64(x$14.high & 0, (x$14.low & 65535) >>> 0)).low >>> 0) << 12 >>> 0)) >>> 0;
		_lhs$7 = out, _index$7 = 4, _lhs$7[_index$7] = _lhs$7[_index$7] + ((go$shiftRightUint64(in$1[8], 16).low >>> 0)) >>> 0;
		out[0] = ((x$15 = in$1[0], new Go$Uint64(x$15.high & 0, (x$15.low & 268435455) >>> 0)).low >>> 0);
		_lhs$8 = out, _index$8 = 1, _lhs$8[_index$8] = _lhs$8[_index$8] + (((x$16 = go$shiftRightUint64(in$1[0], 28), new Go$Uint64(x$16.high & 0, (x$16.low & 268435455) >>> 0)).low >>> 0)) >>> 0;
		_lhs$9 = out, _index$9 = 2, _lhs$9[_index$9] = _lhs$9[_index$9] + ((go$shiftRightUint64(in$1[0], 56).low >>> 0)) >>> 0;
	};
 0ÇG 
p224ReduceÇ3	p224Reduce = function(a) {
		var i, _lhs, _index, _lhs$1, _index$1, top, _lhs$2, _index$2, mask$1, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5, _lhs$6, _index$6, _lhs$7, _index$7, _lhs$8, _index$8;
		i = 0;
		while (i < 7) {
			_lhs = a, _index = i + 1 >> 0, _lhs[_index] = _lhs[_index] + ((a[i] >>> 28 >>> 0)) >>> 0;
			_lhs$1 = a, _index$1 = i, _lhs$1[_index$1] = (_lhs$1[_index$1] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		top = a[7] >>> 28 >>> 0;
		_lhs$2 = a, _index$2 = 7, _lhs$2[_index$2] = (_lhs$2[_index$2] & 268435455) >>> 0;
		mask$1 = top;
		mask$1 = (mask$1 | ((mask$1 >>> 2 >>> 0))) >>> 0;
		mask$1 = (mask$1 | ((mask$1 >>> 1 >>> 0))) >>> 0;
		mask$1 = mask$1 << 31 >>> 0;
		mask$1 = (((mask$1 >> 0) >> 31 >> 0) >>> 0);
		_lhs$3 = a, _index$3 = 0, _lhs$3[_index$3] = _lhs$3[_index$3] - (top) >>> 0;
		_lhs$4 = a, _index$4 = 3, _lhs$4[_index$4] = _lhs$4[_index$4] + ((top << 12 >>> 0)) >>> 0;
		_lhs$5 = a, _index$5 = 3, _lhs$5[_index$5] = _lhs$5[_index$5] - (((1 & mask$1) >>> 0)) >>> 0;
		_lhs$6 = a, _index$6 = 2, _lhs$6[_index$6] = _lhs$6[_index$6] + (((mask$1 & 268435455) >>> 0)) >>> 0;
		_lhs$7 = a, _index$7 = 1, _lhs$7[_index$7] = _lhs$7[_index$7] + (((mask$1 & 268435455) >>> 0)) >>> 0;
		_lhs$8 = a, _index$8 = 0, _lhs$8[_index$8] = _lhs$8[_index$8] + (((mask$1 & 268435456) >>> 0)) >>> 0;
	};
 0Çé 
p224InvertÇz	p224Invert = function(out, in$1) {
		var _tuple, f1, f2, f3, f4, c, i, i$1, i$2, i$3, i$4, i$5, i$6;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], f1 = _tuple[0], f2 = _tuple[1], f3 = _tuple[2], f4 = _tuple[3];
		c = go$makeNativeArray("Uint64", 15, function() { return new Go$Uint64(0, 0); });
		p224Square(f1, in$1, c);
		p224Mul(f1, f1, in$1, c);
		p224Square(f1, f1, c);
		p224Mul(f1, f1, in$1, c);
		p224Square(f2, f1, c);
		p224Square(f2, f2, c);
		p224Square(f2, f2, c);
		p224Mul(f1, f1, f2, c);
		p224Square(f2, f1, c);
		i = 0;
		while (i < 5) {
			p224Square(f2, f2, c);
			i = i + 1 >> 0;
		}
		p224Mul(f2, f2, f1, c);
		p224Square(f3, f2, c);
		i$1 = 0;
		while (i$1 < 11) {
			p224Square(f3, f3, c);
			i$1 = i$1 + 1 >> 0;
		}
		p224Mul(f2, f3, f2, c);
		p224Square(f3, f2, c);
		i$2 = 0;
		while (i$2 < 23) {
			p224Square(f3, f3, c);
			i$2 = i$2 + 1 >> 0;
		}
		p224Mul(f3, f3, f2, c);
		p224Square(f4, f3, c);
		i$3 = 0;
		while (i$3 < 47) {
			p224Square(f4, f4, c);
			i$3 = i$3 + 1 >> 0;
		}
		p224Mul(f3, f3, f4, c);
		p224Square(f4, f3, c);
		i$4 = 0;
		while (i$4 < 23) {
			p224Square(f4, f4, c);
			i$4 = i$4 + 1 >> 0;
		}
		p224Mul(f2, f4, f2, c);
		i$5 = 0;
		while (i$5 < 6) {
			p224Square(f2, f2, c);
			i$5 = i$5 + 1 >> 0;
		}
		p224Mul(f1, f1, f2, c);
		p224Square(f1, f1, c);
		p224Mul(f1, f1, in$1, c);
		i$6 = 0;
		while (i$6 < 97) {
			p224Square(f1, f1, c);
			i$6 = i$6 + 1 >> 0;
		}
		p224Mul(out, f1, f3, c);
	};
 0Çã p224ContractÇu	p224Contract = function(out, in$1) {
		var i, _lhs, _index, _lhs$1, _index$1, top, _lhs$2, _index$2, _lhs$3, _index$3, _lhs$4, _index$4, i$1, mask$1, _lhs$5, _index$5, _lhs$6, _index$6, i$2, _lhs$7, _index$7, _lhs$8, _index$8, _lhs$9, _index$9, _lhs$10, _index$10, _lhs$11, _index$11, i$3, mask$2, _lhs$12, _index$12, _lhs$13, _index$13, top4AllOnes, i$4, bottom3NonZero, n, out3Equal, out3GT, mask$3, _lhs$14, _index$14, _lhs$15, _index$15, _lhs$16, _index$16, _lhs$17, _index$17, _lhs$18, _index$18, _lhs$19, _index$19;
		go$copySlice(new (go$sliceType(Go$Uint32))(out), new (go$sliceType(Go$Uint32))(in$1));
		i = 0;
		while (i < 7) {
			_lhs = out, _index = i + 1 >> 0, _lhs[_index] = _lhs[_index] + ((out[i] >>> 28 >>> 0)) >>> 0;
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = (_lhs$1[_index$1] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		top = out[7] >>> 28 >>> 0;
		_lhs$2 = out, _index$2 = 7, _lhs$2[_index$2] = (_lhs$2[_index$2] & 268435455) >>> 0;
		_lhs$3 = out, _index$3 = 0, _lhs$3[_index$3] = _lhs$3[_index$3] - (top) >>> 0;
		_lhs$4 = out, _index$4 = 3, _lhs$4[_index$4] = _lhs$4[_index$4] + ((top << 12 >>> 0)) >>> 0;
		i$1 = 0;
		while (i$1 < 3) {
			mask$1 = (((out[i$1] >> 0) >> 31 >> 0) >>> 0);
			_lhs$5 = out, _index$5 = i$1, _lhs$5[_index$5] = _lhs$5[_index$5] + (((268435456 & mask$1) >>> 0)) >>> 0;
			_lhs$6 = out, _index$6 = i$1 + 1 >> 0, _lhs$6[_index$6] = _lhs$6[_index$6] - (((1 & mask$1) >>> 0)) >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		i$2 = 3;
		while (i$2 < 7) {
			_lhs$7 = out, _index$7 = i$2 + 1 >> 0, _lhs$7[_index$7] = _lhs$7[_index$7] + ((out[i$2] >>> 28 >>> 0)) >>> 0;
			_lhs$8 = out, _index$8 = i$2, _lhs$8[_index$8] = (_lhs$8[_index$8] & 268435455) >>> 0;
			i$2 = i$2 + 1 >> 0;
		}
		top = out[7] >>> 28 >>> 0;
		_lhs$9 = out, _index$9 = 7, _lhs$9[_index$9] = (_lhs$9[_index$9] & 268435455) >>> 0;
		_lhs$10 = out, _index$10 = 0, _lhs$10[_index$10] = _lhs$10[_index$10] - (top) >>> 0;
		_lhs$11 = out, _index$11 = 3, _lhs$11[_index$11] = _lhs$11[_index$11] + ((top << 12 >>> 0)) >>> 0;
		i$3 = 0;
		while (i$3 < 3) {
			mask$2 = (((out[i$3] >> 0) >> 31 >> 0) >>> 0);
			_lhs$12 = out, _index$12 = i$3, _lhs$12[_index$12] = _lhs$12[_index$12] + (((268435456 & mask$2) >>> 0)) >>> 0;
			_lhs$13 = out, _index$13 = i$3 + 1 >> 0, _lhs$13[_index$13] = _lhs$13[_index$13] - (((1 & mask$2) >>> 0)) >>> 0;
			i$3 = i$3 + 1 >> 0;
		}
		top4AllOnes = 4294967295;
		i$4 = 4;
		while (i$4 < 8) {
			top4AllOnes = (top4AllOnes & (out[i$4])) >>> 0;
			i$4 = i$4 + 1 >> 0;
		}
		top4AllOnes = (top4AllOnes | 4026531840) >>> 0;
		top4AllOnes = (top4AllOnes & ((top4AllOnes >>> 16 >>> 0))) >>> 0;
		top4AllOnes = (top4AllOnes & ((top4AllOnes >>> 8 >>> 0))) >>> 0;
		top4AllOnes = (top4AllOnes & ((top4AllOnes >>> 4 >>> 0))) >>> 0;
		top4AllOnes = (top4AllOnes & ((top4AllOnes >>> 2 >>> 0))) >>> 0;
		top4AllOnes = (top4AllOnes & ((top4AllOnes >>> 1 >>> 0))) >>> 0;
		top4AllOnes = ((((top4AllOnes << 31 >>> 0) >> 0) >> 31 >> 0) >>> 0);
		bottom3NonZero = (((out[0] | out[1]) >>> 0) | out[2]) >>> 0;
		bottom3NonZero = (bottom3NonZero | ((bottom3NonZero >>> 16 >>> 0))) >>> 0;
		bottom3NonZero = (bottom3NonZero | ((bottom3NonZero >>> 8 >>> 0))) >>> 0;
		bottom3NonZero = (bottom3NonZero | ((bottom3NonZero >>> 4 >>> 0))) >>> 0;
		bottom3NonZero = (bottom3NonZero | ((bottom3NonZero >>> 2 >>> 0))) >>> 0;
		bottom3NonZero = (bottom3NonZero | ((bottom3NonZero >>> 1 >>> 0))) >>> 0;
		bottom3NonZero = ((((bottom3NonZero << 31 >>> 0) >> 0) >> 31 >> 0) >>> 0);
		n = out[3] - 268431360 >>> 0;
		out3Equal = n;
		out3Equal = (out3Equal | ((out3Equal >>> 16 >>> 0))) >>> 0;
		out3Equal = (out3Equal | ((out3Equal >>> 8 >>> 0))) >>> 0;
		out3Equal = (out3Equal | ((out3Equal >>> 4 >>> 0))) >>> 0;
		out3Equal = (out3Equal | ((out3Equal >>> 2 >>> 0))) >>> 0;
		out3Equal = (out3Equal | ((out3Equal >>> 1 >>> 0))) >>> 0;
		out3Equal = ~((((out3Equal << 31 >>> 0) >> 0) >> 31 >> 0) >>> 0) >>> 0;
		out3GT = ~(((n >> 0) >> 31 >> 0) >>> 0) >>> 0;
		mask$3 = (top4AllOnes & ((((((out3Equal & bottom3NonZero) >>> 0)) | out3GT) >>> 0))) >>> 0;
		_lhs$14 = out, _index$14 = 0, _lhs$14[_index$14] = _lhs$14[_index$14] - (((1 & mask$3) >>> 0)) >>> 0;
		_lhs$15 = out, _index$15 = 3, _lhs$15[_index$15] = _lhs$15[_index$15] - (((268431360 & mask$3) >>> 0)) >>> 0;
		_lhs$16 = out, _index$16 = 4, _lhs$16[_index$16] = _lhs$16[_index$16] - (((268435455 & mask$3) >>> 0)) >>> 0;
		_lhs$17 = out, _index$17 = 5, _lhs$17[_index$17] = _lhs$17[_index$17] - (((268435455 & mask$3) >>> 0)) >>> 0;
		_lhs$18 = out, _index$18 = 6, _lhs$18[_index$18] = _lhs$18[_index$18] - (((268435455 & mask$3) >>> 0)) >>> 0;
		_lhs$19 = out, _index$19 = 7, _lhs$19[_index$19] = _lhs$19[_index$19] - (((268435455 & mask$3) >>> 0)) >>> 0;
	};
 0Çx p224AddJacobianÇ_	p224AddJacobian = function(x3, y3, z3, x1, y1, z1, x2, y2, z2) {
		var _tuple, z1z1, z2z2, u1, u2, s1, s2, h, i, j, r, v, c, z1IsZero, z2IsZero, xEqual, j$1, yEqual, i$1, _lhs, _index, i$2, i$3, _lhs$1, _index$1;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], z1z1 = _tuple[0], z2z2 = _tuple[1], u1 = _tuple[2], u2 = _tuple[3], s1 = _tuple[4], s2 = _tuple[5], h = _tuple[6], i = _tuple[7], j = _tuple[8], r = _tuple[9], v = _tuple[10];
		c = go$makeNativeArray("Uint64", 15, function() { return new Go$Uint64(0, 0); });
		z1IsZero = p224IsZero(z1);
		z2IsZero = p224IsZero(z2);
		p224Square(z1z1, z1, c);
		p224Square(z2z2, z2, c);
		p224Mul(u1, x1, z2z2, c);
		p224Mul(u2, x2, z1z1, c);
		p224Mul(s1, z2, z2z2, c);
		p224Mul(s1, y1, s1, c);
		p224Mul(s2, z1, z1z1, c);
		p224Mul(s2, y2, s2, c);
		p224Sub(h, u2, u1);
		p224Reduce(h);
		xEqual = p224IsZero(h);
		j$1 = 0;
		while (j$1 < 8) {
			i[j$1] = h[j$1] << 1 >>> 0;
			j$1 = j$1 + 1 >> 0;
		}
		p224Reduce(i);
		p224Square(i, i, c);
		p224Mul(j, h, i, c);
		p224Sub(r, s2, s1);
		p224Reduce(r);
		yEqual = p224IsZero(r);
		if ((xEqual === 1) && (yEqual === 1) && (z1IsZero === 0) && (z2IsZero === 0)) {
			p224DoubleJacobian(x3, y3, z3, x1, y1, z1);
			return;
		}
		i$1 = 0;
		while (i$1 < 8) {
			_lhs = r, _index = i$1, _lhs[_index] = _lhs[_index] << 1 >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		p224Reduce(r);
		p224Mul(v, u1, i, c);
		p224Add(z1z1, z1z1, z2z2);
		p224Add(z2z2, z1, z2);
		p224Reduce(z2z2);
		p224Square(z2z2, z2z2, c);
		p224Sub(z3, z2z2, z1z1);
		p224Reduce(z3);
		p224Mul(z3, z3, h, c);
		i$2 = 0;
		while (i$2 < 8) {
			z1z1[i$2] = v[i$2] << 1 >>> 0;
			i$2 = i$2 + 1 >> 0;
		}
		p224Add(z1z1, j, z1z1);
		p224Reduce(z1z1);
		p224Square(x3, r, c);
		p224Sub(x3, x3, z1z1);
		p224Reduce(x3);
		i$3 = 0;
		while (i$3 < 8) {
			_lhs$1 = s1, _index$1 = i$3, _lhs$1[_index$1] = _lhs$1[_index$1] << 1 >>> 0;
			i$3 = i$3 + 1 >> 0;
		}
		p224Mul(s1, s1, j, c);
		p224Sub(z1z1, v, x3);
		p224Reduce(z1z1);
		p224Mul(z1z1, z1z1, r, c);
		p224Sub(y3, z1z1, s1);
		p224Reduce(y3);
		p224CopyConditional(x3, x2, z1IsZero);
		p224CopyConditional(x3, x1, z2IsZero);
		p224CopyConditional(y3, y2, z1IsZero);
		p224CopyConditional(y3, y1, z2IsZero);
		p224CopyConditional(z3, z2, z1IsZero);
		p224CopyConditional(z3, z1, z2IsZero);
	};
 0Ç" p224DoubleJacobianÇ	p224DoubleJacobian = function(x3, y3, z3, x1, y1, z1) {
		var _tuple, delta, gamma, beta, alpha, t, c, i, _lhs, _index, i$1, i$2, _lhs$1, _index$1, i$3, _lhs$2, _index$2;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], delta = _tuple[0], gamma = _tuple[1], beta = _tuple[2], alpha = _tuple[3], t = _tuple[4];
		c = go$makeNativeArray("Uint64", 15, function() { return new Go$Uint64(0, 0); });
		p224Square(delta, z1, c);
		p224Square(gamma, y1, c);
		p224Mul(beta, x1, gamma, c);
		p224Add(t, x1, delta);
		i = 0;
		while (i < 8) {
			_lhs = t, _index = i, _lhs[_index] = _lhs[_index] + ((t[i] << 1 >>> 0)) >>> 0;
			i = i + 1 >> 0;
		}
		p224Reduce(t);
		p224Sub(alpha, x1, delta);
		p224Reduce(alpha);
		p224Mul(alpha, alpha, t, c);
		p224Add(z3, y1, z1);
		p224Reduce(z3);
		p224Square(z3, z3, c);
		p224Sub(z3, z3, gamma);
		p224Reduce(z3);
		p224Sub(z3, z3, delta);
		p224Reduce(z3);
		i$1 = 0;
		while (i$1 < 8) {
			delta[i$1] = beta[i$1] << 3 >>> 0;
			i$1 = i$1 + 1 >> 0;
		}
		p224Reduce(delta);
		p224Square(x3, alpha, c);
		p224Sub(x3, x3, delta);
		p224Reduce(x3);
		i$2 = 0;
		while (i$2 < 8) {
			_lhs$1 = beta, _index$1 = i$2, _lhs$1[_index$1] = _lhs$1[_index$1] << 2 >>> 0;
			i$2 = i$2 + 1 >> 0;
		}
		p224Sub(beta, beta, x3);
		p224Reduce(beta);
		p224Square(gamma, gamma, c);
		i$3 = 0;
		while (i$3 < 8) {
			_lhs$2 = gamma, _index$2 = i$3, _lhs$2[_index$2] = _lhs$2[_index$2] << 3 >>> 0;
			i$3 = i$3 + 1 >> 0;
		}
		p224Reduce(gamma);
		p224Mul(y3, alpha, beta, c);
		p224Sub(y3, y3, gamma);
		p224Reduce(y3);
	};
 0Çg p224CopyConditionalÇJ	p224CopyConditional = function(out, in$1, control) {
		var i, _lhs, _index;
		control = control << 31 >>> 0;
		control = (((control >> 0) >> 31 >> 0) >>> 0);
		i = 0;
		while (i < 8) {
			_lhs = out, _index = i, _lhs[_index] = (_lhs[_index] ^ ((((((out[i] ^ in$1[i]) >>> 0)) & control) >>> 0))) >>> 0;
			i = i + 1 >> 0;
		}
	};
 0Çò p224ScalarMultÇÄ	p224ScalarMult = function(outX, outY, outZ, inX, inY, inZ, scalar) {
		var _tuple, xx, yy, zz, i, _ref, _i, _slice, _index, byte$1, bitNum, y, bit;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], xx = _tuple[0], yy = _tuple[1], zz = _tuple[2];
		i = 0;
		while (i < 8) {
			outX[i] = 0;
			outY[i] = 0;
			outZ[i] = 0;
			i = i + 1 >> 0;
		}
		_ref = scalar;
		_i = 0;
		while (_i < _ref.length) {
			byte$1 = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			bitNum = 0;
			while (bitNum < 8) {
				p224DoubleJacobian(outX, outY, outZ, outX, outY, outZ);
				bit = ((((((y = ((7 - bitNum >>> 0)), y < 32 ? (byte$1 >>> y) : 0) << 24 >>> 24)) & 1) >>> 0) >>> 0);
				p224AddJacobian(xx, yy, zz, inX, inY, inZ, outX, outY, outZ);
				p224CopyConditional(outX, xx, bit);
				p224CopyConditional(outY, yy, bit);
				p224CopyConditional(outZ, zz, bit);
				bitNum = bitNum + 1 >>> 0;
			}
			_i++;
		}
	};
 0Çä p224ToAffineÇt	p224ToAffine = function(x, y, z) {
		var _tuple, zinv, zinvsq, outx, outy, tmp, isPointAtInfinity;
		_tuple = [go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; }), go$makeNativeArray("Uint32", 8, function() { return 0; })], zinv = _tuple[0], zinvsq = _tuple[1], outx = _tuple[2], outy = _tuple[3];
		tmp = go$makeNativeArray("Uint64", 15, function() { return new Go$Uint64(0, 0); });
		if (isPointAtInfinity = p224IsZero(z), isPointAtInfinity === 1) {
			return [new big.Int.Ptr(), new big.Int.Ptr()];
		}
		p224Invert(zinv, z);
		p224Square(zinvsq, zinv, tmp);
		p224Mul(x, x, zinvsq, tmp);
		p224Mul(zinvsq, zinvsq, zinv, tmp);
		p224Mul(y, y, zinvsq, tmp);
		p224Contract(outx, x);
		p224Contract(outy, y);
		return [p224ToBig(outx), p224ToBig(outy)];
	};
 0Ç‚ get28BitsFromEndÇ»	get28BitsFromEnd = function(buf, shift) {
		var ret, i, b, l, _slice, _index, y, y$1, x;
		ret = 0;
		i = 0;
		while (i < 4) {
			b = 0;
			if (l = buf.length, l > 0) {
				b = (_slice = buf, _index = (l - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (!((i === 3)) || (shift === 4)) {
					buf = go$subslice(buf, 0, (l - 1 >> 0));
				}
			}
			ret = (ret | (((y = shift, y < 32 ? (((y$1 = ((x = 8, (((x >>> 16 << 16) * i >>> 0) + (x << 16 >>> 16) * i) >>> 0)), y$1 < 32 ? ((b >>> 0) << y$1) : 0) >>> 0) >>> y) : 0) >>> 0))) >>> 0;
			i = i + 1 >>> 0;
		}
		ret = (ret & 268435455) >>> 0;
		return [ret, buf];
	};
 0ÇK p224FromBigÇ6	p224FromBig = function(out, in$1) {
		var bytes, _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5, _tuple$6, _tuple$7;
		bytes = in$1.Bytes();
		_tuple = get28BitsFromEnd(bytes, 0), out[0] = _tuple[0], bytes = _tuple[1];
		_tuple$1 = get28BitsFromEnd(bytes, 4), out[1] = _tuple$1[0], bytes = _tuple$1[1];
		_tuple$2 = get28BitsFromEnd(bytes, 0), out[2] = _tuple$2[0], bytes = _tuple$2[1];
		_tuple$3 = get28BitsFromEnd(bytes, 4), out[3] = _tuple$3[0], bytes = _tuple$3[1];
		_tuple$4 = get28BitsFromEnd(bytes, 0), out[4] = _tuple$4[0], bytes = _tuple$4[1];
		_tuple$5 = get28BitsFromEnd(bytes, 4), out[5] = _tuple$5[0], bytes = _tuple$5[1];
		_tuple$6 = get28BitsFromEnd(bytes, 0), out[6] = _tuple$6[0], bytes = _tuple$6[1];
		_tuple$7 = get28BitsFromEnd(bytes, 4), out[7] = _tuple$7[0], bytes = _tuple$7[1];
	};
 0Ç) 	p224ToBigÇ	p224ToBig = function(in$1) {
		var buf;
		buf = go$makeNativeArray("Uint8", 28, function() { return 0; });
		buf[27] = (in$1[0] << 24 >>> 24);
		buf[26] = ((in$1[0] >>> 8 >>> 0) << 24 >>> 24);
		buf[25] = ((in$1[0] >>> 16 >>> 0) << 24 >>> 24);
		buf[24] = ((((((((in$1[0] >>> 24 >>> 0)) & 15) >>> 0)) | ((((in$1[1] << 4 >>> 0)) & 240) >>> 0)) >>> 0) << 24 >>> 24);
		buf[23] = ((in$1[1] >>> 4 >>> 0) << 24 >>> 24);
		buf[22] = ((in$1[1] >>> 12 >>> 0) << 24 >>> 24);
		buf[21] = ((in$1[1] >>> 20 >>> 0) << 24 >>> 24);
		buf[20] = (in$1[2] << 24 >>> 24);
		buf[19] = ((in$1[2] >>> 8 >>> 0) << 24 >>> 24);
		buf[18] = ((in$1[2] >>> 16 >>> 0) << 24 >>> 24);
		buf[17] = ((((((((in$1[2] >>> 24 >>> 0)) & 15) >>> 0)) | ((((in$1[3] << 4 >>> 0)) & 240) >>> 0)) >>> 0) << 24 >>> 24);
		buf[16] = ((in$1[3] >>> 4 >>> 0) << 24 >>> 24);
		buf[15] = ((in$1[3] >>> 12 >>> 0) << 24 >>> 24);
		buf[14] = ((in$1[3] >>> 20 >>> 0) << 24 >>> 24);
		buf[13] = (in$1[4] << 24 >>> 24);
		buf[12] = ((in$1[4] >>> 8 >>> 0) << 24 >>> 24);
		buf[11] = ((in$1[4] >>> 16 >>> 0) << 24 >>> 24);
		buf[10] = ((((((((in$1[4] >>> 24 >>> 0)) & 15) >>> 0)) | ((((in$1[5] << 4 >>> 0)) & 240) >>> 0)) >>> 0) << 24 >>> 24);
		buf[9] = ((in$1[5] >>> 4 >>> 0) << 24 >>> 24);
		buf[8] = ((in$1[5] >>> 12 >>> 0) << 24 >>> 24);
		buf[7] = ((in$1[5] >>> 20 >>> 0) << 24 >>> 24);
		buf[6] = (in$1[6] << 24 >>> 24);
		buf[5] = ((in$1[6] >>> 8 >>> 0) << 24 >>> 24);
		buf[4] = ((in$1[6] >>> 16 >>> 0) << 24 >>> 24);
		buf[3] = ((((((((in$1[6] >>> 24 >>> 0)) & 15) >>> 0)) | ((((in$1[7] << 4 >>> 0)) & 240) >>> 0)) >>> 0) << 24 >>> 24);
		buf[2] = ((in$1[7] >>> 4 >>> 0) << 24 >>> 24);
		buf[1] = ((in$1[7] >>> 12 >>> 0) << 24 >>> 24);
		buf[0] = ((in$1[7] >>> 20 >>> 0) << 24 >>> 24);
		return new big.Int.Ptr().SetBytes(new (go$sliceType(Go$Uint8))(buf));
	};
 0ÇI initP256Ç7	initP256 = function() {
		var _tuple, _tuple$1, _tuple$2, _tuple$3, _tuple$4, _tuple$5;
		p256.CurveParams = new CurveParams.Ptr();
		_tuple = new big.Int.Ptr().SetString("115792089210356248762697446949407573530086143415290314195533631308867097853951", 10), p256.CurveParams.P = _tuple[0];
		_tuple$1 = new big.Int.Ptr().SetString("115792089210356248762697446949407573529996955224135760342422259061068512044369", 10), p256.CurveParams.N = _tuple$1[0];
		_tuple$2 = new big.Int.Ptr().SetString("5ac635d8aa3a93e7b3ebbd55769886bc651d06b0cc53b0f63bce3c3e27d2604b", 16), p256.CurveParams.B = _tuple$2[0];
		_tuple$3 = new big.Int.Ptr().SetString("6b17d1f2e12c4247f8bce6e563a440f277037d812deb33a0f4a13945d898c296", 16), p256.CurveParams.Gx = _tuple$3[0];
		_tuple$4 = new big.Int.Ptr().SetString("4fe342e2fe1a7f9b8ee7eb4a7c0f9e162bce33576b315ececbb6406837bf51f5", 16), p256.CurveParams.Gy = _tuple$4[0];
		p256.CurveParams.BitSize = 256;
		_tuple$5 = new big.Int.Ptr().SetString("7fffffff00000001fffffffe8000000100000000ffffffff0000000180000000", 16), p256RInverse = _tuple$5[0];
	};
 0Å˝  ÅÙ	p256Curve.Ptr.prototype.Params = function() {
		var _struct, curve;
		curve = (_struct = this, new p256Curve.Ptr(_struct.CurveParams));
		return curve.CurveParams;
	};
	p256Curve.prototype.Params = function() { return this.go$val.Params(); };
 0ÇÜ p256GetScalarÇo	p256GetScalar = function(out, in$1) {
		var n, scalarBytes, _ref, _i, _slice, _index, v, i;
		n = new big.Int.Ptr().SetBytes(in$1);
		scalarBytes = (go$sliceType(Go$Uint8)).nil;
		if (n.Cmp(p256.CurveParams.N) >= 0) {
			n.Mod(n, p256.CurveParams.N);
			scalarBytes = n.Bytes();
		} else {
			scalarBytes = in$1;
		}
		_ref = scalarBytes;
		_i = 0;
		while (_i < _ref.length) {
			v = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			out[scalarBytes.length - ((1 + i >> 0)) >> 0] = v;
			_i++;
		}
	};
 0Ç  Ç	p256Curve.Ptr.prototype.ScalarBaseMult = function(scalar) {
		var x, y, scalarReversed, _tuple, x1, y1, z1, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		scalarReversed = go$makeNativeArray("Uint8", 32, function() { return 0; });
		p256GetScalar(scalarReversed, scalar);
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], x1 = _tuple[0], y1 = _tuple[1], z1 = _tuple[2];
		p256ScalarBaseMult(x1, y1, z1, scalarReversed);
		_tuple$1 = p256ToAffine(x1, y1, z1), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p256Curve.prototype.ScalarBaseMult = function(scalar) { return this.go$val.ScalarBaseMult(scalar); };
 0Ç  Ç	p256Curve.Ptr.prototype.ScalarMult = function(bigX, bigY, scalar) {
		var x, y, scalarReversed, _tuple, px, py, x1, y1, z1, _tuple$1;
		x = (go$ptrType(big.Int)).nil;
		y = (go$ptrType(big.Int)).nil;
		scalarReversed = go$makeNativeArray("Uint8", 32, function() { return 0; });
		p256GetScalar(scalarReversed, scalar);
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], px = _tuple[0], py = _tuple[1], x1 = _tuple[2], y1 = _tuple[3], z1 = _tuple[4];
		p256FromBig(px, bigX);
		p256FromBig(py, bigY);
		p256ScalarMult(x1, y1, z1, px, py, scalarReversed);
		_tuple$1 = p256ToAffine(x1, y1, z1), x = _tuple$1[0], y = _tuple$1[1];
		return [x, y];
	};
	p256Curve.prototype.ScalarMult = function(bigX, bigY, scalar) { return this.go$val.ScalarMult(bigX, bigY, scalar); };
 0s nonZeroToAllOnes[	nonZeroToAllOnes = function(x) {
		return ((((x - 1 >>> 0)) >>> 31 >>> 0)) - 1 >>> 0;
	};
 0Ç» p256ReduceCarryÇØ	p256ReduceCarry = function(inout, carry) {
		var carry_mask, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5, _lhs$6, _index$6, _lhs$7, _index$7, _lhs$8, _index$8;
		carry_mask = nonZeroToAllOnes(carry);
		_lhs = inout, _index = 0, _lhs[_index] = _lhs[_index] + ((carry << 1 >>> 0)) >>> 0;
		_lhs$1 = inout, _index$1 = 3, _lhs$1[_index$1] = _lhs$1[_index$1] + (((268435456 & carry_mask) >>> 0)) >>> 0;
		_lhs$2 = inout, _index$2 = 3, _lhs$2[_index$2] = _lhs$2[_index$2] - ((carry << 11 >>> 0)) >>> 0;
		_lhs$3 = inout, _index$3 = 4, _lhs$3[_index$3] = _lhs$3[_index$3] + (((536870911 & carry_mask) >>> 0)) >>> 0;
		_lhs$4 = inout, _index$4 = 5, _lhs$4[_index$4] = _lhs$4[_index$4] + (((268435455 & carry_mask) >>> 0)) >>> 0;
		_lhs$5 = inout, _index$5 = 6, _lhs$5[_index$5] = _lhs$5[_index$5] + (((536870911 & carry_mask) >>> 0)) >>> 0;
		_lhs$6 = inout, _index$6 = 6, _lhs$6[_index$6] = _lhs$6[_index$6] - ((carry << 22 >>> 0)) >>> 0;
		_lhs$7 = inout, _index$7 = 7, _lhs$7[_index$7] = _lhs$7[_index$7] - (((1 & carry_mask) >>> 0)) >>> 0;
		_lhs$8 = inout, _index$8 = 7, _lhs$8[_index$8] = _lhs$8[_index$8] + ((carry << 25 >>> 0)) >>> 0;
	};
 0Çı p256SumÇ‰	p256Sum = function(out, in$1, in2) {
		var carry, i, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3;
		carry = 0;
		i = 0;
		while (true) {
			out[i] = in$1[i] + in2[i] >>> 0;
			_lhs = out, _index = i, _lhs[_index] = _lhs[_index] + (carry) >>> 0;
			carry = out[i] >>> 29 >>> 0;
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = (_lhs$1[_index$1] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			out[i] = in$1[i] + in2[i] >>> 0;
			_lhs$2 = out, _index$2 = i, _lhs$2[_index$2] = _lhs$2[_index$2] + (carry) >>> 0;
			carry = out[i] >>> 28 >>> 0;
			_lhs$3 = out, _index$3 = i, _lhs$3[_index$3] = (_lhs$3[_index$3] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		p256ReduceCarry(out, carry);
	};
 0Ç” p256DiffÇ¡	p256Diff = function(out, in$1, in2) {
		var carry, i, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5;
		carry = 0;
		i = 0;
		while (true) {
			out[i] = in$1[i] - in2[i] >>> 0;
			_lhs = out, _index = i, _lhs[_index] = _lhs[_index] + (p256Zero31[i]) >>> 0;
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = _lhs$1[_index$1] + (carry) >>> 0;
			carry = out[i] >>> 29 >>> 0;
			_lhs$2 = out, _index$2 = i, _lhs$2[_index$2] = (_lhs$2[_index$2] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			out[i] = in$1[i] - in2[i] >>> 0;
			_lhs$3 = out, _index$3 = i, _lhs$3[_index$3] = _lhs$3[_index$3] + (p256Zero31[i]) >>> 0;
			_lhs$4 = out, _index$4 = i, _lhs$4[_index$4] = _lhs$4[_index$4] + (carry) >>> 0;
			carry = out[i] >>> 28 >>> 0;
			_lhs$5 = out, _index$5 = i, _lhs$5[_index$5] = (_lhs$5[_index$5] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		p256ReduceCarry(out, carry);
	};
 0Çú p256ReduceDegreeÇÇ	p256ReduceDegree = function(out, tmp) {
		var tmp2, _tuple, carry, x, xMask, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, i, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5, _lhs$6, _index$6, _lhs$7, _index$7, _lhs$8, _index$8, _lhs$9, _index$9, _lhs$10, _index$10, _lhs$11, _index$11, _lhs$12, _index$12, _lhs$13, _index$13, _lhs$14, _index$14, _lhs$15, _index$15, i$1, _lhs$16, _index$16, _lhs$17, _index$17, _lhs$18, _index$18, _lhs$19, _index$19, _lhs$20, _index$20, _lhs$21, _index$21, _lhs$22, _index$22, _lhs$23, _index$23, _lhs$24, _index$24, _lhs$25, _index$25, _lhs$26, _index$26, _lhs$27, _index$27, _lhs$28, _index$28, _lhs$29, _index$29, _lhs$30, _index$30, _lhs$31, _index$31, _lhs$32, _index$32, _lhs$33, _index$33, _lhs$34, _index$34, _lhs$35, _index$35, _lhs$36, _index$36, _lhs$37, _index$37, _lhs$38, _index$38, _lhs$39, _index$39, _lhs$40, _index$40, i$2, _lhs$41, _index$41, _lhs$42, _index$42, _lhs$43, _index$43, _lhs$44, _index$44, _lhs$45, _index$45, _lhs$46, _index$46, _lhs$47, _index$47;
		tmp2 = go$makeNativeArray("Uint32", 18, function() { return 0; });
		_tuple = [0, 0, 0], carry = _tuple[0], x = _tuple[1], xMask = _tuple[2];
		tmp2[0] = ((tmp[0].low >>> 0) & 536870911) >>> 0;
		tmp2[1] = (tmp[0].low >>> 0) >>> 29 >>> 0;
		_lhs = tmp2, _index = 1, _lhs[_index] = (_lhs[_index] | ((((((go$shiftRightUint64(tmp[0], 32).low >>> 0) << 3 >>> 0)) & 268435455) >>> 0))) >>> 0;
		_lhs$1 = tmp2, _index$1 = 1, _lhs$1[_index$1] = _lhs$1[_index$1] + ((((tmp[1].low >>> 0) & 268435455) >>> 0)) >>> 0;
		carry = tmp2[1] >>> 28 >>> 0;
		_lhs$2 = tmp2, _index$2 = 1, _lhs$2[_index$2] = (_lhs$2[_index$2] & 268435455) >>> 0;
		i = 2;
		while (i < 17) {
			tmp2[i] = ((go$shiftRightUint64(tmp[(i - 2 >> 0)], 32).low >>> 0)) >>> 25 >>> 0;
			_lhs$3 = tmp2, _index$3 = i, _lhs$3[_index$3] = _lhs$3[_index$3] + ((((tmp[(i - 1 >> 0)].low >>> 0)) >>> 28 >>> 0)) >>> 0;
			_lhs$4 = tmp2, _index$4 = i, _lhs$4[_index$4] = _lhs$4[_index$4] + ((((((go$shiftRightUint64(tmp[(i - 1 >> 0)], 32).low >>> 0) << 4 >>> 0)) & 536870911) >>> 0)) >>> 0;
			_lhs$5 = tmp2, _index$5 = i, _lhs$5[_index$5] = _lhs$5[_index$5] + ((((tmp[i].low >>> 0) & 536870911) >>> 0)) >>> 0;
			_lhs$6 = tmp2, _index$6 = i, _lhs$6[_index$6] = _lhs$6[_index$6] + (carry) >>> 0;
			carry = tmp2[i] >>> 29 >>> 0;
			_lhs$7 = tmp2, _index$7 = i, _lhs$7[_index$7] = (_lhs$7[_index$7] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 17) {
				break;
			}
			tmp2[i] = (go$shiftRightUint64(tmp[(i - 2 >> 0)], 32).low >>> 0) >>> 25 >>> 0;
			_lhs$8 = tmp2, _index$8 = i, _lhs$8[_index$8] = _lhs$8[_index$8] + (((tmp[(i - 1 >> 0)].low >>> 0) >>> 29 >>> 0)) >>> 0;
			_lhs$9 = tmp2, _index$9 = i, _lhs$9[_index$9] = _lhs$9[_index$9] + (((((((go$shiftRightUint64(tmp[(i - 1 >> 0)], 32).low >>> 0)) << 3 >>> 0)) & 268435455) >>> 0)) >>> 0;
			_lhs$10 = tmp2, _index$10 = i, _lhs$10[_index$10] = _lhs$10[_index$10] + ((((tmp[i].low >>> 0) & 268435455) >>> 0)) >>> 0;
			_lhs$11 = tmp2, _index$11 = i, _lhs$11[_index$11] = _lhs$11[_index$11] + (carry) >>> 0;
			carry = tmp2[i] >>> 28 >>> 0;
			_lhs$12 = tmp2, _index$12 = i, _lhs$12[_index$12] = (_lhs$12[_index$12] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		tmp2[17] = (go$shiftRightUint64(tmp[15], 32).low >>> 0) >>> 25 >>> 0;
		_lhs$13 = tmp2, _index$13 = 17, _lhs$13[_index$13] = _lhs$13[_index$13] + (((tmp[16].low >>> 0) >>> 29 >>> 0)) >>> 0;
		_lhs$14 = tmp2, _index$14 = 17, _lhs$14[_index$14] = _lhs$14[_index$14] + (((go$shiftRightUint64(tmp[16], 32).low >>> 0) << 3 >>> 0)) >>> 0;
		_lhs$15 = tmp2, _index$15 = 17, _lhs$15[_index$15] = _lhs$15[_index$15] + (carry) >>> 0;
		i$1 = 0;
		while (true) {
			_lhs$16 = tmp2, _index$16 = i$1 + 1 >> 0, _lhs$16[_index$16] = _lhs$16[_index$16] + ((tmp2[i$1] >>> 29 >>> 0)) >>> 0;
			x = (tmp2[i$1] & 536870911) >>> 0;
			xMask = nonZeroToAllOnes(x);
			tmp2[i$1] = 0;
			_lhs$17 = tmp2, _index$17 = i$1 + 3 >> 0, _lhs$17[_index$17] = _lhs$17[_index$17] + (((((x << 10 >>> 0)) & 268435455) >>> 0)) >>> 0;
			_lhs$18 = tmp2, _index$18 = i$1 + 4 >> 0, _lhs$18[_index$18] = _lhs$18[_index$18] + (((x >>> 18 >>> 0))) >>> 0;
			_lhs$19 = tmp2, _index$19 = i$1 + 6 >> 0, _lhs$19[_index$19] = _lhs$19[_index$19] + (((((x << 21 >>> 0)) & 536870911) >>> 0)) >>> 0;
			_lhs$20 = tmp2, _index$20 = i$1 + 7 >> 0, _lhs$20[_index$20] = _lhs$20[_index$20] + ((x >>> 8 >>> 0)) >>> 0;
			_lhs$21 = tmp2, _index$21 = i$1 + 7 >> 0, _lhs$21[_index$21] = _lhs$21[_index$21] + (((268435456 & xMask) >>> 0)) >>> 0;
			_lhs$22 = tmp2, _index$22 = i$1 + 8 >> 0, _lhs$22[_index$22] = _lhs$22[_index$22] + (((((x - 1 >>> 0)) & xMask) >>> 0)) >>> 0;
			_lhs$23 = tmp2, _index$23 = i$1 + 7 >> 0, _lhs$23[_index$23] = _lhs$23[_index$23] - (((((x << 24 >>> 0)) & 268435455) >>> 0)) >>> 0;
			_lhs$24 = tmp2, _index$24 = i$1 + 8 >> 0, _lhs$24[_index$24] = _lhs$24[_index$24] - ((x >>> 4 >>> 0)) >>> 0;
			_lhs$25 = tmp2, _index$25 = i$1 + 8 >> 0, _lhs$25[_index$25] = _lhs$25[_index$25] + (((536870912 & xMask) >>> 0)) >>> 0;
			_lhs$26 = tmp2, _index$26 = i$1 + 8 >> 0, _lhs$26[_index$26] = _lhs$26[_index$26] - (x) >>> 0;
			_lhs$27 = tmp2, _index$27 = i$1 + 8 >> 0, _lhs$27[_index$27] = _lhs$27[_index$27] + (((((x << 28 >>> 0)) & 536870911) >>> 0)) >>> 0;
			_lhs$28 = tmp2, _index$28 = i$1 + 9 >> 0, _lhs$28[_index$28] = _lhs$28[_index$28] + (((((((x >>> 1 >>> 0)) - 1 >>> 0)) & xMask) >>> 0)) >>> 0;
			if ((i$1 + 1 >> 0) === 9) {
				break;
			}
			_lhs$29 = tmp2, _index$29 = i$1 + 2 >> 0, _lhs$29[_index$29] = _lhs$29[_index$29] + ((tmp2[(i$1 + 1 >> 0)] >>> 28 >>> 0)) >>> 0;
			x = (tmp2[(i$1 + 1 >> 0)] & 268435455) >>> 0;
			xMask = nonZeroToAllOnes(x);
			tmp2[i$1 + 1 >> 0] = 0;
			_lhs$30 = tmp2, _index$30 = i$1 + 4 >> 0, _lhs$30[_index$30] = _lhs$30[_index$30] + (((((x << 11 >>> 0)) & 536870911) >>> 0)) >>> 0;
			_lhs$31 = tmp2, _index$31 = i$1 + 5 >> 0, _lhs$31[_index$31] = _lhs$31[_index$31] + (((x >>> 18 >>> 0))) >>> 0;
			_lhs$32 = tmp2, _index$32 = i$1 + 7 >> 0, _lhs$32[_index$32] = _lhs$32[_index$32] + (((((x << 21 >>> 0)) & 268435455) >>> 0)) >>> 0;
			_lhs$33 = tmp2, _index$33 = i$1 + 8 >> 0, _lhs$33[_index$33] = _lhs$33[_index$33] + ((x >>> 7 >>> 0)) >>> 0;
			_lhs$34 = tmp2, _index$34 = i$1 + 8 >> 0, _lhs$34[_index$34] = _lhs$34[_index$34] + (((536870912 & xMask) >>> 0)) >>> 0;
			_lhs$35 = tmp2, _index$35 = i$1 + 9 >> 0, _lhs$35[_index$35] = _lhs$35[_index$35] + (((((x - 1 >>> 0)) & xMask) >>> 0)) >>> 0;
			_lhs$36 = tmp2, _index$36 = i$1 + 8 >> 0, _lhs$36[_index$36] = _lhs$36[_index$36] - (((((x << 25 >>> 0)) & 536870911) >>> 0)) >>> 0;
			_lhs$37 = tmp2, _index$37 = i$1 + 9 >> 0, _lhs$37[_index$37] = _lhs$37[_index$37] - ((x >>> 4 >>> 0)) >>> 0;
			_lhs$38 = tmp2, _index$38 = i$1 + 9 >> 0, _lhs$38[_index$38] = _lhs$38[_index$38] + (((268435456 & xMask) >>> 0)) >>> 0;
			_lhs$39 = tmp2, _index$39 = i$1 + 9 >> 0, _lhs$39[_index$39] = _lhs$39[_index$39] - (x) >>> 0;
			_lhs$40 = tmp2, _index$40 = i$1 + 10 >> 0, _lhs$40[_index$40] = _lhs$40[_index$40] + (((((x - 1 >>> 0)) & xMask) >>> 0)) >>> 0;
			i$1 = i$1 + 2 >> 0;
		}
		carry = 0;
		i$2 = 0;
		while (i$2 < 8) {
			out[i$2] = tmp2[(i$2 + 9 >> 0)];
			_lhs$41 = out, _index$41 = i$2, _lhs$41[_index$41] = _lhs$41[_index$41] + (carry) >>> 0;
			_lhs$42 = out, _index$42 = i$2, _lhs$42[_index$42] = _lhs$42[_index$42] + (((((tmp2[(i$2 + 10 >> 0)] << 28 >>> 0)) & 536870911) >>> 0)) >>> 0;
			carry = out[i$2] >>> 29 >>> 0;
			_lhs$43 = out, _index$43 = i$2, _lhs$43[_index$43] = (_lhs$43[_index$43] & 536870911) >>> 0;
			i$2 = i$2 + 1 >> 0;
			out[i$2] = tmp2[(i$2 + 9 >> 0)] >>> 1 >>> 0;
			_lhs$44 = out, _index$44 = i$2, _lhs$44[_index$44] = _lhs$44[_index$44] + (carry) >>> 0;
			carry = out[i$2] >>> 28 >>> 0;
			_lhs$45 = out, _index$45 = i$2, _lhs$45[_index$45] = (_lhs$45[_index$45] & 268435455) >>> 0;
			i$2 = i$2 + 1 >> 0;
		}
		out[8] = tmp2[17];
		_lhs$46 = out, _index$46 = 8, _lhs$46[_index$46] = _lhs$46[_index$46] + (carry) >>> 0;
		carry = out[8] >>> 29 >>> 0;
		_lhs$47 = out, _index$47 = 8, _lhs$47[_index$47] = (_lhs$47[_index$47] & 536870911) >>> 0;
		p256ReduceCarry(out, carry);
	};
 0Çâ 
p256SquareÇu	p256Square = function(out, in$1) {
		var tmp, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25, x$26, x$27, x$28, x$29, x$30, x$31, x$32, x$33, x$34, x$35, x$36, x$37, x$38, x$39, x$40, x$41, x$42, x$43, x$44, x$45, x$46, x$47, x$48, x$49, x$50, x$51, x$52, x$53, x$54, x$55;
		tmp = go$makeNativeArray("Uint64", 17, function() { return new Go$Uint64(0, 0); });
		tmp[0] = go$mul64(new Go$Uint64(0, in$1[0]), new Go$Uint64(0, in$1[0]));
		tmp[1] = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[1]), 1)));
		tmp[2] = (x = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[2]), 1))), x$1 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[1]), 1))), new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
		tmp[3] = (x$2 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[3]), 1))), x$3 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[2]), 1))), new Go$Uint64(x$2.high + x$3.high, x$2.low + x$3.low));
		tmp[4] = (x$4 = (x$5 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[4]), 1))), x$6 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[3]), 2))), new Go$Uint64(x$5.high + x$6.high, x$5.low + x$6.low)), x$7 = go$mul64(new Go$Uint64(0, in$1[2]), new Go$Uint64(0, in$1[2])), new Go$Uint64(x$4.high + x$7.high, x$4.low + x$7.low));
		tmp[5] = (x$8 = (x$9 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 1))), x$10 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[4]), 1))), new Go$Uint64(x$9.high + x$10.high, x$9.low + x$10.low)), x$11 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[3]), 1))), new Go$Uint64(x$8.high + x$11.high, x$8.low + x$11.low));
		tmp[6] = (x$12 = (x$13 = (x$14 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), x$15 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 2))), new Go$Uint64(x$14.high + x$15.high, x$14.low + x$15.low)), x$16 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[4]), 1))), new Go$Uint64(x$13.high + x$16.high, x$13.low + x$16.low)), x$17 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[3]), 1))), new Go$Uint64(x$12.high + x$17.high, x$12.low + x$17.low));
		tmp[7] = (x$18 = (x$19 = (x$20 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 1))), x$21 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), new Go$Uint64(x$20.high + x$21.high, x$20.low + x$21.low)), x$22 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 1))), new Go$Uint64(x$19.high + x$22.high, x$19.low + x$22.low)), x$23 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[4]), 1))), new Go$Uint64(x$18.high + x$23.high, x$18.low + x$23.low));
		tmp[8] = (x$24 = (x$25 = (x$26 = (x$27 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$28 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 2))), new Go$Uint64(x$27.high + x$28.high, x$27.low + x$28.low)), x$29 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), new Go$Uint64(x$26.high + x$29.high, x$26.low + x$29.low)), x$30 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 2))), new Go$Uint64(x$25.high + x$30.high, x$25.low + x$30.low)), x$31 = go$mul64(new Go$Uint64(0, in$1[4]), new Go$Uint64(0, in$1[4])), new Go$Uint64(x$24.high + x$31.high, x$24.low + x$31.low));
		tmp[9] = (x$32 = (x$33 = (x$34 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$35 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 1))), new Go$Uint64(x$34.high + x$35.high, x$34.low + x$35.low)), x$36 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), new Go$Uint64(x$33.high + x$36.high, x$33.low + x$36.low)), x$37 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 1))), new Go$Uint64(x$32.high + x$37.high, x$32.low + x$37.low));
		tmp[10] = (x$38 = (x$39 = (x$40 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$41 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 2))), new Go$Uint64(x$40.high + x$41.high, x$40.low + x$41.low)), x$42 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), new Go$Uint64(x$39.high + x$42.high, x$39.low + x$42.low)), x$43 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in$1[5]), 1))), new Go$Uint64(x$38.high + x$43.high, x$38.low + x$43.low));
		tmp[11] = (x$44 = (x$45 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$46 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 1))), new Go$Uint64(x$45.high + x$46.high, x$45.low + x$46.low)), x$47 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in$1[6]), 1))), new Go$Uint64(x$44.high + x$47.high, x$44.low + x$47.low));
		tmp[12] = (x$48 = (x$49 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$50 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 2))), new Go$Uint64(x$49.high + x$50.high, x$49.low + x$50.low)), x$51 = go$mul64(new Go$Uint64(0, in$1[6]), new Go$Uint64(0, in$1[6])), new Go$Uint64(x$48.high + x$51.high, x$48.low + x$51.low));
		tmp[13] = (x$52 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$53 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 1))), new Go$Uint64(x$52.high + x$53.high, x$52.low + x$53.low));
		tmp[14] = (x$54 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1))), x$55 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in$1[7]), 1))), new Go$Uint64(x$54.high + x$55.high, x$54.low + x$55.low));
		tmp[15] = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in$1[8]), 1)));
		tmp[16] = go$mul64(new Go$Uint64(0, in$1[8]), new Go$Uint64(0, in$1[8]));
		p256ReduceDegree(out, go$mapArray(tmp, function(entry) { return entry; }));
	};
 0Ç2+ p256MulÇ2	p256Mul = function(out, in$1, in2) {
		var tmp, x, x$1, x$2, x$3, x$4, x$5, x$6, x$7, x$8, x$9, x$10, x$11, x$12, x$13, x$14, x$15, x$16, x$17, x$18, x$19, x$20, x$21, x$22, x$23, x$24, x$25, x$26, x$27, x$28, x$29, x$30, x$31, x$32, x$33, x$34, x$35, x$36, x$37, x$38, x$39, x$40, x$41, x$42, x$43, x$44, x$45, x$46, x$47, x$48, x$49, x$50, x$51, x$52, x$53, x$54, x$55, x$56, x$57, x$58, x$59, x$60, x$61, x$62, x$63, x$64, x$65, x$66, x$67, x$68, x$69, x$70, x$71, x$72, x$73, x$74, x$75, x$76, x$77, x$78, x$79, x$80, x$81, x$82, x$83, x$84, x$85, x$86, x$87, x$88, x$89, x$90, x$91, x$92, x$93, x$94, x$95, x$96, x$97, x$98, x$99, x$100, x$101, x$102, x$103, x$104, x$105, x$106, x$107, x$108, x$109, x$110, x$111, x$112, x$113, x$114, x$115, x$116, x$117, x$118, x$119, x$120, x$121, x$122, x$123, x$124, x$125, x$126, x$127;
		tmp = go$makeNativeArray("Uint64", 17, function() { return new Go$Uint64(0, 0); });
		tmp[0] = go$mul64(new Go$Uint64(0, in$1[0]), new Go$Uint64(0, in2[0]));
		tmp[1] = (x = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 0))), x$1 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x.high + x$1.high, x.low + x$1.low));
		tmp[2] = (x$2 = (x$3 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), x$4 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 1))), new Go$Uint64(x$3.high + x$4.high, x$3.low + x$4.low)), x$5 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$2.high + x$5.high, x$2.low + x$5.low));
		tmp[3] = (x$6 = (x$7 = (x$8 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 0))), x$9 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$8.high + x$9.high, x$8.low + x$9.low)), x$10 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 0))), new Go$Uint64(x$7.high + x$10.high, x$7.low + x$10.low)), x$11 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$6.high + x$11.high, x$6.low + x$11.low));
		tmp[4] = (x$12 = (x$13 = (x$14 = (x$15 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), x$16 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 1))), new Go$Uint64(x$15.high + x$16.high, x$15.low + x$16.low)), x$17 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$14.high + x$17.high, x$14.low + x$17.low)), x$18 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 1))), new Go$Uint64(x$13.high + x$18.high, x$13.low + x$18.low)), x$19 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$12.high + x$19.high, x$12.low + x$19.low));
		tmp[5] = (x$20 = (x$21 = (x$22 = (x$23 = (x$24 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 0))), x$25 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$24.high + x$25.high, x$24.low + x$25.low)), x$26 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 0))), new Go$Uint64(x$23.high + x$26.high, x$23.low + x$26.low)), x$27 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$22.high + x$27.high, x$22.low + x$27.low)), x$28 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 0))), new Go$Uint64(x$21.high + x$28.high, x$21.low + x$28.low)), x$29 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$20.high + x$29.high, x$20.low + x$29.low));
		tmp[6] = (x$30 = (x$31 = (x$32 = (x$33 = (x$34 = (x$35 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), x$36 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 1))), new Go$Uint64(x$35.high + x$36.high, x$35.low + x$36.low)), x$37 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$34.high + x$37.high, x$34.low + x$37.low)), x$38 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 1))), new Go$Uint64(x$33.high + x$38.high, x$33.low + x$38.low)), x$39 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$32.high + x$39.high, x$32.low + x$39.low)), x$40 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 1))), new Go$Uint64(x$31.high + x$40.high, x$31.low + x$40.low)), x$41 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$30.high + x$41.high, x$30.low + x$41.low));
		tmp[7] = (x$42 = (x$43 = (x$44 = (x$45 = (x$46 = (x$47 = (x$48 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 0))), x$49 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$48.high + x$49.high, x$48.low + x$49.low)), x$50 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 0))), new Go$Uint64(x$47.high + x$50.high, x$47.low + x$50.low)), x$51 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$46.high + x$51.high, x$46.low + x$51.low)), x$52 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 0))), new Go$Uint64(x$45.high + x$52.high, x$45.low + x$52.low)), x$53 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$44.high + x$53.high, x$44.low + x$53.low)), x$54 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 0))), new Go$Uint64(x$43.high + x$54.high, x$43.low + x$54.low)), x$55 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$42.high + x$55.high, x$42.low + x$55.low));
		tmp[8] = (x$56 = (x$57 = (x$58 = (x$59 = (x$60 = (x$61 = (x$62 = (x$63 = go$mul64(new Go$Uint64(0, in$1[0]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$64 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 1))), new Go$Uint64(x$63.high + x$64.high, x$63.low + x$64.low)), x$65 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$62.high + x$65.high, x$62.low + x$65.low)), x$66 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 1))), new Go$Uint64(x$61.high + x$66.high, x$61.low + x$66.low)), x$67 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$60.high + x$67.high, x$60.low + x$67.low)), x$68 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 1))), new Go$Uint64(x$59.high + x$68.high, x$59.low + x$68.low)), x$69 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$58.high + x$69.high, x$58.low + x$69.low)), x$70 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 1))), new Go$Uint64(x$57.high + x$70.high, x$57.low + x$70.low)), x$71 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[0]), 0))), new Go$Uint64(x$56.high + x$71.high, x$56.low + x$71.low));
		tmp[9] = (x$72 = (x$73 = (x$74 = (x$75 = (x$76 = (x$77 = (x$78 = go$mul64(new Go$Uint64(0, in$1[1]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$79 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 0))), new Go$Uint64(x$78.high + x$79.high, x$78.low + x$79.low)), x$80 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$77.high + x$80.high, x$77.low + x$80.low)), x$81 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 0))), new Go$Uint64(x$76.high + x$81.high, x$76.low + x$81.low)), x$82 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$75.high + x$82.high, x$75.low + x$82.low)), x$83 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 0))), new Go$Uint64(x$74.high + x$83.high, x$74.low + x$83.low)), x$84 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$73.high + x$84.high, x$73.low + x$84.low)), x$85 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[1]), 0))), new Go$Uint64(x$72.high + x$85.high, x$72.low + x$85.low));
		tmp[10] = (x$86 = (x$87 = (x$88 = (x$89 = (x$90 = (x$91 = go$mul64(new Go$Uint64(0, in$1[2]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$92 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 1))), new Go$Uint64(x$91.high + x$92.high, x$91.low + x$92.low)), x$93 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$90.high + x$93.high, x$90.low + x$93.low)), x$94 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 1))), new Go$Uint64(x$89.high + x$94.high, x$89.low + x$94.low)), x$95 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$88.high + x$95.high, x$88.low + x$95.low)), x$96 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 1))), new Go$Uint64(x$87.high + x$96.high, x$87.low + x$96.low)), x$97 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[2]), 0))), new Go$Uint64(x$86.high + x$97.high, x$86.low + x$97.low));
		tmp[11] = (x$98 = (x$99 = (x$100 = (x$101 = (x$102 = go$mul64(new Go$Uint64(0, in$1[3]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$103 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 0))), new Go$Uint64(x$102.high + x$103.high, x$102.low + x$103.low)), x$104 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$101.high + x$104.high, x$101.low + x$104.low)), x$105 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 0))), new Go$Uint64(x$100.high + x$105.high, x$100.low + x$105.low)), x$106 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$99.high + x$106.high, x$99.low + x$106.low)), x$107 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[3]), 0))), new Go$Uint64(x$98.high + x$107.high, x$98.low + x$107.low));
		tmp[12] = (x$108 = (x$109 = (x$110 = (x$111 = go$mul64(new Go$Uint64(0, in$1[4]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$112 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 1))), new Go$Uint64(x$111.high + x$112.high, x$111.low + x$112.low)), x$113 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$110.high + x$113.high, x$110.low + x$113.low)), x$114 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 1))), new Go$Uint64(x$109.high + x$114.high, x$109.low + x$114.low)), x$115 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[4]), 0))), new Go$Uint64(x$108.high + x$115.high, x$108.low + x$115.low));
		tmp[13] = (x$116 = (x$117 = (x$118 = go$mul64(new Go$Uint64(0, in$1[5]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$119 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 0))), new Go$Uint64(x$118.high + x$119.high, x$118.low + x$119.low)), x$120 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$117.high + x$120.high, x$117.low + x$120.low)), x$121 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[5]), 0))), new Go$Uint64(x$116.high + x$121.high, x$116.low + x$121.low));
		tmp[14] = (x$122 = (x$123 = go$mul64(new Go$Uint64(0, in$1[6]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$124 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 1))), new Go$Uint64(x$123.high + x$124.high, x$123.low + x$124.low)), x$125 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[6]), 0))), new Go$Uint64(x$122.high + x$125.high, x$122.low + x$125.low));
		tmp[15] = (x$126 = go$mul64(new Go$Uint64(0, in$1[7]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0))), x$127 = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[7]), 0))), new Go$Uint64(x$126.high + x$127.high, x$126.low + x$127.low));
		tmp[16] = go$mul64(new Go$Uint64(0, in$1[8]), (go$shiftLeft64(new Go$Uint64(0, in2[8]), 0)));
		p256ReduceDegree(out, go$mapArray(tmp, function(entry) { return entry; }));
	};
 0ÅÖ 
p256Assigns	p256Assign = function(out, in$1) {
		go$copyArray(out, go$mapArray(in$1, function(entry) { return entry; }));
	};
 0Ç® 
p256InvertÇî	p256Invert = function(out, in$1) {
		var _tuple, ftmp, ftmp2, _tuple$1, e2, e4, e8, e16, e32, e64, i, i$1, i$2, i$3, i$4, i$5, i$6;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], ftmp = _tuple[0], ftmp2 = _tuple[1];
		_tuple$1 = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], e2 = _tuple$1[0], e4 = _tuple$1[1], e8 = _tuple$1[2], e16 = _tuple$1[3], e32 = _tuple$1[4], e64 = _tuple$1[5];
		p256Square(ftmp, in$1);
		p256Mul(ftmp, in$1, ftmp);
		p256Assign(e2, ftmp);
		p256Square(ftmp, ftmp);
		p256Square(ftmp, ftmp);
		p256Mul(ftmp, ftmp, e2);
		p256Assign(e4, ftmp);
		p256Square(ftmp, ftmp);
		p256Square(ftmp, ftmp);
		p256Square(ftmp, ftmp);
		p256Square(ftmp, ftmp);
		p256Mul(ftmp, ftmp, e4);
		p256Assign(e8, ftmp);
		i = 0;
		while (i < 8) {
			p256Square(ftmp, ftmp);
			i = i + 1 >> 0;
		}
		p256Mul(ftmp, ftmp, e8);
		p256Assign(e16, ftmp);
		i$1 = 0;
		while (i$1 < 16) {
			p256Square(ftmp, ftmp);
			i$1 = i$1 + 1 >> 0;
		}
		p256Mul(ftmp, ftmp, e16);
		p256Assign(e32, ftmp);
		i$2 = 0;
		while (i$2 < 32) {
			p256Square(ftmp, ftmp);
			i$2 = i$2 + 1 >> 0;
		}
		p256Assign(e64, ftmp);
		p256Mul(ftmp, ftmp, in$1);
		i$3 = 0;
		while (i$3 < 192) {
			p256Square(ftmp, ftmp);
			i$3 = i$3 + 1 >> 0;
		}
		p256Mul(ftmp2, e64, e32);
		i$4 = 0;
		while (i$4 < 16) {
			p256Square(ftmp2, ftmp2);
			i$4 = i$4 + 1 >> 0;
		}
		p256Mul(ftmp2, ftmp2, e16);
		i$5 = 0;
		while (i$5 < 8) {
			p256Square(ftmp2, ftmp2);
			i$5 = i$5 + 1 >> 0;
		}
		p256Mul(ftmp2, ftmp2, e8);
		i$6 = 0;
		while (i$6 < 4) {
			p256Square(ftmp2, ftmp2);
			i$6 = i$6 + 1 >> 0;
		}
		p256Mul(ftmp2, ftmp2, e4);
		p256Square(ftmp2, ftmp2);
		p256Square(ftmp2, ftmp2);
		p256Mul(ftmp2, ftmp2, e2);
		p256Square(ftmp2, ftmp2);
		p256Square(ftmp2, ftmp2);
		p256Mul(ftmp2, ftmp2, in$1);
		p256Mul(out, ftmp2, ftmp);
	};
 0Ç p256Scalar3Ç˘	p256Scalar3 = function(out) {
		var carry, i, _lhs, _index, x, x$1, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3, x$2, x$3, _lhs$4, _index$4, _lhs$5, _index$5;
		carry = 0;
		i = 0;
		while (true) {
			_lhs = out, _index = i, _lhs[_index] = (x = _lhs[_index], x$1 = 3, (((x >>> 16 << 16) * x$1 >>> 0) + (x << 16 >>> 16) * x$1) >>> 0);
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = _lhs$1[_index$1] + (carry) >>> 0;
			carry = out[i] >>> 29 >>> 0;
			_lhs$2 = out, _index$2 = i, _lhs$2[_index$2] = (_lhs$2[_index$2] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			_lhs$3 = out, _index$3 = i, _lhs$3[_index$3] = (x$2 = _lhs$3[_index$3], x$3 = 3, (((x$2 >>> 16 << 16) * x$3 >>> 0) + (x$2 << 16 >>> 16) * x$3) >>> 0);
			_lhs$4 = out, _index$4 = i, _lhs$4[_index$4] = _lhs$4[_index$4] + (carry) >>> 0;
			carry = out[i] >>> 28 >>> 0;
			_lhs$5 = out, _index$5 = i, _lhs$5[_index$5] = (_lhs$5[_index$5] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		p256ReduceCarry(out, carry);
	};
 0Ç˜ p256Scalar4Ç‚	p256Scalar4 = function(out) {
		var _tuple, carry, nextCarry, i, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5, _lhs$6, _index$6, _lhs$7, _index$7;
		_tuple = [0, 0], carry = _tuple[0], nextCarry = _tuple[1];
		i = 0;
		while (true) {
			nextCarry = out[i] >>> 27 >>> 0;
			_lhs = out, _index = i, _lhs[_index] = _lhs[_index] << 2 >>> 0;
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = (_lhs$1[_index$1] & 536870911) >>> 0;
			_lhs$2 = out, _index$2 = i, _lhs$2[_index$2] = _lhs$2[_index$2] + (carry) >>> 0;
			carry = nextCarry + ((out[i] >>> 29 >>> 0)) >>> 0;
			_lhs$3 = out, _index$3 = i, _lhs$3[_index$3] = (_lhs$3[_index$3] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			nextCarry = out[i] >>> 26 >>> 0;
			_lhs$4 = out, _index$4 = i, _lhs$4[_index$4] = _lhs$4[_index$4] << 2 >>> 0;
			_lhs$5 = out, _index$5 = i, _lhs$5[_index$5] = (_lhs$5[_index$5] & 268435455) >>> 0;
			_lhs$6 = out, _index$6 = i, _lhs$6[_index$6] = _lhs$6[_index$6] + (carry) >>> 0;
			carry = nextCarry + ((out[i] >>> 28 >>> 0)) >>> 0;
			_lhs$7 = out, _index$7 = i, _lhs$7[_index$7] = (_lhs$7[_index$7] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		p256ReduceCarry(out, carry);
	};
 0Ç˜ p256Scalar8Ç‚	p256Scalar8 = function(out) {
		var _tuple, carry, nextCarry, i, _lhs, _index, _lhs$1, _index$1, _lhs$2, _index$2, _lhs$3, _index$3, _lhs$4, _index$4, _lhs$5, _index$5, _lhs$6, _index$6, _lhs$7, _index$7;
		_tuple = [0, 0], carry = _tuple[0], nextCarry = _tuple[1];
		i = 0;
		while (true) {
			nextCarry = out[i] >>> 26 >>> 0;
			_lhs = out, _index = i, _lhs[_index] = _lhs[_index] << 3 >>> 0;
			_lhs$1 = out, _index$1 = i, _lhs$1[_index$1] = (_lhs$1[_index$1] & 536870911) >>> 0;
			_lhs$2 = out, _index$2 = i, _lhs$2[_index$2] = _lhs$2[_index$2] + (carry) >>> 0;
			carry = nextCarry + ((out[i] >>> 29 >>> 0)) >>> 0;
			_lhs$3 = out, _index$3 = i, _lhs$3[_index$3] = (_lhs$3[_index$3] & 536870911) >>> 0;
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			nextCarry = out[i] >>> 25 >>> 0;
			_lhs$4 = out, _index$4 = i, _lhs$4[_index$4] = _lhs$4[_index$4] << 3 >>> 0;
			_lhs$5 = out, _index$5 = i, _lhs$5[_index$5] = (_lhs$5[_index$5] & 268435455) >>> 0;
			_lhs$6 = out, _index$6 = i, _lhs$6[_index$6] = _lhs$6[_index$6] + (carry) >>> 0;
			carry = nextCarry + ((out[i] >>> 28 >>> 0)) >>> 0;
			_lhs$7 = out, _index$7 = i, _lhs$7[_index$7] = (_lhs$7[_index$7] & 268435455) >>> 0;
			i = i + 1 >> 0;
		}
		p256ReduceCarry(out, carry);
	};
 0Çv p256PointDoubleÇ]	p256PointDouble = function(xOut, yOut, zOut, x, y, z) {
		var _tuple, delta, gamma, alpha, beta, tmp, tmp2;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], delta = _tuple[0], gamma = _tuple[1], alpha = _tuple[2], beta = _tuple[3], tmp = _tuple[4], tmp2 = _tuple[5];
		p256Square(delta, z);
		p256Square(gamma, y);
		p256Mul(beta, x, gamma);
		p256Sum(tmp, x, delta);
		p256Diff(tmp2, x, delta);
		p256Mul(alpha, tmp, tmp2);
		p256Scalar3(alpha);
		p256Sum(tmp, y, z);
		p256Square(tmp, tmp);
		p256Diff(tmp, tmp, gamma);
		p256Diff(zOut, tmp, delta);
		p256Scalar4(beta);
		p256Square(xOut, alpha);
		p256Diff(xOut, xOut, beta);
		p256Diff(xOut, xOut, beta);
		p256Diff(tmp, beta, xOut);
		p256Mul(tmp, alpha, tmp);
		p256Square(tmp2, gamma);
		p256Scalar8(tmp2);
		p256Diff(yOut, tmp, tmp2);
	};
 0Çˇ p256PointAddMixedÇ‰	p256PointAddMixed = function(xOut, yOut, zOut, x1, y1, z1, x2, y2) {
		var _tuple, z1z1, z1z1z1, s2, u2, h, i, j, r, rr, v, tmp;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], z1z1 = _tuple[0], z1z1z1 = _tuple[1], s2 = _tuple[2], u2 = _tuple[3], h = _tuple[4], i = _tuple[5], j = _tuple[6], r = _tuple[7], rr = _tuple[8], v = _tuple[9], tmp = _tuple[10];
		p256Square(z1z1, z1);
		p256Sum(tmp, z1, z1);
		p256Mul(u2, x2, z1z1);
		p256Mul(z1z1z1, z1, z1z1);
		p256Mul(s2, y2, z1z1z1);
		p256Diff(h, u2, x1);
		p256Sum(i, h, h);
		p256Square(i, i);
		p256Mul(j, h, i);
		p256Diff(r, s2, y1);
		p256Sum(r, r, r);
		p256Mul(v, x1, i);
		p256Mul(zOut, tmp, h);
		p256Square(rr, r);
		p256Diff(xOut, rr, j);
		p256Diff(xOut, xOut, v);
		p256Diff(xOut, xOut, v);
		p256Diff(tmp, v, xOut);
		p256Mul(yOut, tmp, r);
		p256Mul(tmp, y1, j);
		p256Diff(yOut, yOut, tmp);
		p256Diff(yOut, yOut, tmp);
	};
 0Ç˛ p256PointAddÇË	p256PointAdd = function(xOut, yOut, zOut, x1, y1, z1, x2, y2, z2) {
		var _tuple, z1z1, z1z1z1, z2z2, z2z2z2, s1, s2, u1, u2, h, i, j, r, rr, v, tmp;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], z1z1 = _tuple[0], z1z1z1 = _tuple[1], z2z2 = _tuple[2], z2z2z2 = _tuple[3], s1 = _tuple[4], s2 = _tuple[5], u1 = _tuple[6], u2 = _tuple[7], h = _tuple[8], i = _tuple[9], j = _tuple[10], r = _tuple[11], rr = _tuple[12], v = _tuple[13], tmp = _tuple[14];
		p256Square(z1z1, z1);
		p256Square(z2z2, z2);
		p256Mul(u1, x1, z2z2);
		p256Sum(tmp, z1, z2);
		p256Square(tmp, tmp);
		p256Diff(tmp, tmp, z1z1);
		p256Diff(tmp, tmp, z2z2);
		p256Mul(z2z2z2, z2, z2z2);
		p256Mul(s1, y1, z2z2z2);
		p256Mul(u2, x2, z1z1);
		p256Mul(z1z1z1, z1, z1z1);
		p256Mul(s2, y2, z1z1z1);
		p256Diff(h, u2, u1);
		p256Sum(i, h, h);
		p256Square(i, i);
		p256Mul(j, h, i);
		p256Diff(r, s2, s1);
		p256Sum(r, r, r);
		p256Mul(v, u1, i);
		p256Mul(zOut, tmp, h);
		p256Square(rr, r);
		p256Diff(xOut, rr, j);
		p256Diff(xOut, xOut, v);
		p256Diff(xOut, xOut, v);
		p256Diff(tmp, v, xOut);
		p256Mul(yOut, tmp, r);
		p256Mul(tmp, s1, j);
		p256Diff(yOut, yOut, tmp);
		p256Diff(yOut, yOut, tmp);
	};
 0Ç$ p256CopyConditionalÇ	p256CopyConditional = function(out, in$1, mask$1) {
		var i, tmp, _lhs, _index;
		i = 0;
		while (i < 9) {
			tmp = (mask$1 & (((in$1[i] ^ out[i]) >>> 0))) >>> 0;
			_lhs = out, _index = i, _lhs[_index] = (_lhs[_index] ^ (tmp)) >>> 0;
			i = i + 1 >> 0;
		}
	};
 0Çµ p256SelectAffinePointÇñ	p256SelectAffinePoint = function(xOut, yOut, table, index) {
		var _ref, _i, i, _ref$1, _i$1, i$1, i$2, mask$1, _ref$2, _i$2, j, _lhs, _index, _slice, _index$1, _ref$3, _i$3, j$1, _lhs$1, _index$2, _slice$1, _index$3;
		_ref = xOut;
		_i = 0;
		while (_i < 9) {
			i = _i;
			xOut[i] = 0;
			_i++;
		}
		_ref$1 = yOut;
		_i$1 = 0;
		while (_i$1 < 9) {
			i$1 = _i$1;
			yOut[i$1] = 0;
			_i$1++;
		}
		i$2 = 1;
		while (i$2 < 16) {
			mask$1 = (i$2 ^ index) >>> 0;
			mask$1 = (mask$1 | ((mask$1 >>> 2 >>> 0))) >>> 0;
			mask$1 = (mask$1 | ((mask$1 >>> 1 >>> 0))) >>> 0;
			mask$1 = (mask$1 & 1) >>> 0;
			mask$1 = mask$1 - 1 >>> 0;
			_ref$2 = xOut;
			_i$2 = 0;
			while (_i$2 < 9) {
				j = _i$2;
				_lhs = xOut, _index = j, _lhs[_index] = (_lhs[_index] | ((((_slice = table, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice.length) ? _slice.array[_slice.offset + _index$1] : go$throwRuntimeError("index out of range")) & mask$1) >>> 0))) >>> 0;
				table = go$subslice(table, 1);
				_i$2++;
			}
			_ref$3 = yOut;
			_i$3 = 0;
			while (_i$3 < 9) {
				j$1 = _i$3;
				_lhs$1 = yOut, _index$2 = j$1, _lhs$1[_index$2] = (_lhs$1[_index$2] | ((((_slice$1 = table, _index$3 = 0, (_index$3 >= 0 && _index$3 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$3] : go$throwRuntimeError("index out of range")) & mask$1) >>> 0))) >>> 0;
				table = go$subslice(table, 1);
				_i$3++;
			}
			i$2 = i$2 + 1 >>> 0;
		}
	};
 0Çï p256SelectJacobianPointÇt	p256SelectJacobianPoint = function(xOut, yOut, zOut, table, index) {
		var _ref, _i, i, _ref$1, _i$1, i$1, _ref$2, _i$2, i$2, i$3, mask$1, _ref$3, _i$3, j, _lhs, _index, _ref$4, _i$4, j$1, _lhs$1, _index$1, _ref$5, _i$5, j$2, _lhs$2, _index$2;
		_ref = xOut;
		_i = 0;
		while (_i < 9) {
			i = _i;
			xOut[i] = 0;
			_i++;
		}
		_ref$1 = yOut;
		_i$1 = 0;
		while (_i$1 < 9) {
			i$1 = _i$1;
			yOut[i$1] = 0;
			_i$1++;
		}
		_ref$2 = zOut;
		_i$2 = 0;
		while (_i$2 < 9) {
			i$2 = _i$2;
			zOut[i$2] = 0;
			_i$2++;
		}
		i$3 = 1;
		while (i$3 < 16) {
			mask$1 = (i$3 ^ index) >>> 0;
			mask$1 = (mask$1 | ((mask$1 >>> 2 >>> 0))) >>> 0;
			mask$1 = (mask$1 | ((mask$1 >>> 1 >>> 0))) >>> 0;
			mask$1 = (mask$1 & 1) >>> 0;
			mask$1 = mask$1 - 1 >>> 0;
			_ref$3 = xOut;
			_i$3 = 0;
			while (_i$3 < 9) {
				j = _i$3;
				_lhs = xOut, _index = j, _lhs[_index] = (_lhs[_index] | (((table[i$3][0][j] & mask$1) >>> 0))) >>> 0;
				_i$3++;
			}
			_ref$4 = yOut;
			_i$4 = 0;
			while (_i$4 < 9) {
				j$1 = _i$4;
				_lhs$1 = yOut, _index$1 = j$1, _lhs$1[_index$1] = (_lhs$1[_index$1] | (((table[i$3][1][j$1] & mask$1) >>> 0))) >>> 0;
				_i$4++;
			}
			_ref$5 = zOut;
			_i$5 = 0;
			while (_i$5 < 9) {
				j$2 = _i$5;
				_lhs$2 = zOut, _index$2 = j$2, _lhs$2[_index$2] = (_lhs$2[_index$2] | (((table[i$3][2][j$2] & mask$1) >>> 0))) >>> 0;
				_i$5++;
			}
			i$3 = i$3 + 1 >>> 0;
		}
	};
 0Å√ 
p256GetBitÅ∞	p256GetBit = function(scalar, bit) {
		var y;
		return ((((((y = (((bit & 7) >>> 0)), y < 32 ? ((scalar[(bit >>> 3 >>> 0)]) >>> y) : 0) << 24 >>> 24)) & 1) >>> 0) >>> 0);
	};
 0Ç	H p256ScalarBaseMultÇ	,	p256ScalarBaseMult = function(xOut, yOut, zOut, scalar) {
		var nIsInfinityMask, _tuple, pIsNoninfiniteMask, mask$1, tableOffset, _tuple$1, px, py, tx, ty, tz, _ref, _i, i, _ref$1, _i$1, i$1, _ref$2, _i$2, i$2, i$3, j, bit0, bit1, bit2, bit3, index;
		nIsInfinityMask = 4294967295;
		_tuple = [0, 0, 0], pIsNoninfiniteMask = _tuple[0], mask$1 = _tuple[1], tableOffset = _tuple[2];
		_tuple$1 = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], px = _tuple$1[0], py = _tuple$1[1], tx = _tuple$1[2], ty = _tuple$1[3], tz = _tuple$1[4];
		_ref = xOut;
		_i = 0;
		while (_i < 9) {
			i = _i;
			xOut[i] = 0;
			_i++;
		}
		_ref$1 = yOut;
		_i$1 = 0;
		while (_i$1 < 9) {
			i$1 = _i$1;
			yOut[i$1] = 0;
			_i$1++;
		}
		_ref$2 = zOut;
		_i$2 = 0;
		while (_i$2 < 9) {
			i$2 = _i$2;
			zOut[i$2] = 0;
			_i$2++;
		}
		i$3 = 0;
		while (i$3 < 32) {
			if (!((i$3 === 0))) {
				p256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut);
			}
			tableOffset = 0;
			j = 0;
			while (j <= 32) {
				bit0 = p256GetBit(scalar, (31 - i$3 >>> 0) + j >>> 0);
				bit1 = p256GetBit(scalar, (95 - i$3 >>> 0) + j >>> 0);
				bit2 = p256GetBit(scalar, (159 - i$3 >>> 0) + j >>> 0);
				bit3 = p256GetBit(scalar, (223 - i$3 >>> 0) + j >>> 0);
				index = (((((bit0 | ((bit1 << 1 >>> 0))) >>> 0) | ((bit2 << 2 >>> 0))) >>> 0) | ((bit3 << 3 >>> 0))) >>> 0;
				p256SelectAffinePoint(px, py, go$subslice(new (go$sliceType(Go$Uint32))(p256Precomputed), tableOffset), index);
				tableOffset = tableOffset + 270 >>> 0;
				p256PointAddMixed(tx, ty, tz, xOut, yOut, zOut, px, py);
				p256CopyConditional(xOut, px, nIsInfinityMask);
				p256CopyConditional(yOut, py, nIsInfinityMask);
				p256CopyConditional(zOut, p256One, nIsInfinityMask);
				pIsNoninfiniteMask = nonZeroToAllOnes(index);
				mask$1 = (pIsNoninfiniteMask & (~nIsInfinityMask >>> 0)) >>> 0;
				p256CopyConditional(xOut, tx, mask$1);
				p256CopyConditional(yOut, ty, mask$1);
				p256CopyConditional(zOut, tz, mask$1);
				nIsInfinityMask = (nIsInfinityMask & ((~pIsNoninfiniteMask >>> 0))) >>> 0;
				j = j + 32 >>> 0;
			}
			i$3 = i$3 + 1 >>> 0;
		}
	};
 0Ç° p256PointToAffineÇÜ	p256PointToAffine = function(xOut, yOut, x, y, z) {
		var _tuple, zInv, zInvSq;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], zInv = _tuple[0], zInvSq = _tuple[1];
		p256Invert(zInv, z);
		p256Square(zInvSq, zInv);
		p256Mul(xOut, x, zInvSq);
		p256Mul(zInv, zInv, zInvSq);
		p256Mul(yOut, y, zInv);
	};
 0ÇÁ p256ToAffineÇ—	p256ToAffine = function(x, y, z) {
		var xOut, yOut, _tuple, xx, yy, _tuple$1;
		xOut = (go$ptrType(big.Int)).nil;
		yOut = (go$ptrType(big.Int)).nil;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], xx = _tuple[0], yy = _tuple[1];
		p256PointToAffine(xx, yy, x, y, z);
		_tuple$1 = [p256ToBig(xx), p256ToBig(yy)], xOut = _tuple$1[0], yOut = _tuple$1[1];
		return [xOut, yOut];
	};
 0Çs p256ScalarMultÇ[	p256ScalarMult = function(xOut, yOut, zOut, x, y, scalar) {
		var _tuple, px, py, pz, tx, ty, tz, precomp, _tuple$1, nIsInfinityMask, index, pIsNoninfiniteMask, mask$1, i, _q, _q$1, _q$2, _ref, _i, i$1, _ref$1, _i$1, i$2, _ref$2, _i$2, i$3, i$4, _q$3;
		_tuple = [go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; }), go$makeNativeArray("Uint32", 9, function() { return 0; })], px = _tuple[0], py = _tuple[1], pz = _tuple[2], tx = _tuple[3], ty = _tuple[4], tz = _tuple[5];
		precomp = go$makeNativeArray("Array", 16, function() { return go$makeNativeArray("Array", 3, function() { return go$makeNativeArray("Uint32", 9, function() { return 0; }); }); });
		_tuple$1 = [0, 0, 0, 0], nIsInfinityMask = _tuple$1[0], index = _tuple$1[1], pIsNoninfiniteMask = _tuple$1[2], mask$1 = _tuple$1[3];
		precomp[1][0] = go$mapArray(x, function(entry) { return entry; });
		precomp[1][1] = go$mapArray(y, function(entry) { return entry; });
		precomp[1][2] = go$mapArray(p256One, function(entry) { return entry; });
		i = 2;
		while (i < 16) {
			p256PointDouble(precomp[i][0], precomp[i][1], precomp[i][2], precomp[(_q = i / 2, (_q === _q && _q !== 1/0 && _q !== -1/0) ? _q >> 0 : go$throwRuntimeError("integer divide by zero"))][0], precomp[(_q$1 = i / 2, (_q$1 === _q$1 && _q$1 !== 1/0 && _q$1 !== -1/0) ? _q$1 >> 0 : go$throwRuntimeError("integer divide by zero"))][1], precomp[(_q$2 = i / 2, (_q$2 === _q$2 && _q$2 !== 1/0 && _q$2 !== -1/0) ? _q$2 >> 0 : go$throwRuntimeError("integer divide by zero"))][2]);
			p256PointAddMixed(precomp[(i + 1 >> 0)][0], precomp[(i + 1 >> 0)][1], precomp[(i + 1 >> 0)][2], precomp[i][0], precomp[i][1], precomp[i][2], x, y);
			i = i + 2 >> 0;
		}
		_ref = xOut;
		_i = 0;
		while (_i < 9) {
			i$1 = _i;
			xOut[i$1] = 0;
			_i++;
		}
		_ref$1 = yOut;
		_i$1 = 0;
		while (_i$1 < 9) {
			i$2 = _i$1;
			yOut[i$2] = 0;
			_i$1++;
		}
		_ref$2 = zOut;
		_i$2 = 0;
		while (_i$2 < 9) {
			i$3 = _i$2;
			zOut[i$3] = 0;
			_i$2++;
		}
		nIsInfinityMask = 4294967295;
		i$4 = 0;
		while (i$4 < 64) {
			if (!((i$4 === 0))) {
				p256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut);
				p256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut);
				p256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut);
				p256PointDouble(xOut, yOut, zOut, xOut, yOut, zOut);
			}
			index = (scalar[(31 - (_q$3 = i$4 / 2, (_q$3 === _q$3 && _q$3 !== 1/0 && _q$3 !== -1/0) ? _q$3 >> 0 : go$throwRuntimeError("integer divide by zero")) >> 0)] >>> 0);
			if (((i$4 & 1)) === 1) {
				index = (index & 15) >>> 0;
			} else {
				index = index >>> 4 >>> 0;
			}
			p256SelectJacobianPoint(px, py, pz, precomp, index);
			p256PointAdd(tx, ty, tz, xOut, yOut, zOut, px, py, pz);
			p256CopyConditional(xOut, px, nIsInfinityMask);
			p256CopyConditional(yOut, py, nIsInfinityMask);
			p256CopyConditional(zOut, pz, nIsInfinityMask);
			pIsNoninfiniteMask = nonZeroToAllOnes(index);
			mask$1 = (pIsNoninfiniteMask & (~nIsInfinityMask >>> 0)) >>> 0;
			p256CopyConditional(xOut, tx, mask$1);
			p256CopyConditional(yOut, ty, mask$1);
			p256CopyConditional(zOut, tz, mask$1);
			nIsInfinityMask = (nIsInfinityMask & ((~pIsNoninfiniteMask >>> 0))) >>> 0;
			i$4 = i$4 + 1 >> 0;
		}
	};
 0Çï p256FromBigÇÄ	p256FromBig = function(out, in$1) {
		var tmp, i, bits, _slice, _index, bits$1, _slice$1, _index$1;
		tmp = new big.Int.Ptr().Lsh(in$1, 257);
		tmp.Mod(tmp, p256.CurveParams.P);
		i = 0;
		while (i < 9) {
			if (bits = tmp.Bits(), bits.length > 0) {
				out[i] = (((_slice = bits, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >>> 0) & 536870911) >>> 0;
			} else {
				out[i] = 0;
			}
			tmp.Rsh(tmp, 29);
			i = i + 1 >> 0;
			if (i === 9) {
				break;
			}
			if (bits$1 = tmp.Bits(), bits$1.length > 0) {
				out[i] = (((_slice$1 = bits$1, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")) >>> 0) & 268435455) >>> 0;
			} else {
				out[i] = 0;
			}
			tmp.Rsh(tmp, 28);
			i = i + 1 >> 0;
		}
	};
 0Ç 	p256ToBigÇ	p256ToBig = function(in$1) {
		var _tuple, result, tmp, i;
		_tuple = [new big.Int.Ptr(), new big.Int.Ptr()], result = _tuple[0], tmp = _tuple[1];
		result.SetInt64(new Go$Int64(0, in$1[8]));
		i = 7;
		while (i >= 0) {
			if (((i & 1)) === 0) {
				result.Lsh(result, 29);
			} else {
				result.Lsh(result, 28);
			}
			tmp.SetInt64(new Go$Int64(0, in$1[i]));
			result.Add(result, tmp);
			i = i - 1 >> 0;
		}
		result.Mul(result, p256RInverse);
		result.Mod(result, p256.CurveParams.P);
		return result;
	};
 0    0    0 