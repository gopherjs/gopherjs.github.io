0É^)go/astÇ¨Ñpackage ast
import token "go/token"
import strings "strings"
import unicode "unicode"
import utf8 "unicode/utf8"
import bytes "bytes"
import fmt "fmt"
import sort "sort"
import strconv "strconv"
import io "io"
import os "os"
import reflect "reflect"
import scanner "go/scanner"
type @"".ArrayType struct { @"".Lbrack @"go/token".Pos; @"".Len @"".Expr; @"".Elt @"".Expr }
func (? *@"".ArrayType) @"".End() (? @"go/token".Pos)
func (? *@"".ArrayType) @"".Pos() (? @"go/token".Pos)
func (? *@"".ArrayType) @"".exprNode() ()
type @"".AssignStmt struct { @"".Lhs []@"".Expr; @"".TokPos @"go/token".Pos; @"".Tok @"go/token".Token; @"".Rhs []@"".Expr }
func (? *@"".AssignStmt) @"".End() (? @"go/token".Pos)
func (? *@"".AssignStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".AssignStmt) @"".stmtNode() ()
const @"".Bad @"".ObjKind = 0x0
type @"".BadDecl struct { @"".From @"go/token".Pos; @"".To @"go/token".Pos }
func (? *@"".BadDecl) @"".End() (? @"go/token".Pos)
func (? *@"".BadDecl) @"".Pos() (? @"go/token".Pos)
func (? *@"".BadDecl) @"".declNode() ()
type @"".BadExpr struct { @"".From @"go/token".Pos; @"".To @"go/token".Pos }
func (? *@"".BadExpr) @"".End() (? @"go/token".Pos)
func (? *@"".BadExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".BadExpr) @"".exprNode() ()
type @"".BadStmt struct { @"".From @"go/token".Pos; @"".To @"go/token".Pos }
func (? *@"".BadStmt) @"".End() (? @"go/token".Pos)
func (? *@"".BadStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".BadStmt) @"".stmtNode() ()
type @"".BasicLit struct { @"".ValuePos @"go/token".Pos; @"".Kind @"go/token".Token; @"".Value string }
func (? *@"".BasicLit) @"".End() (? @"go/token".Pos)
func (? *@"".BasicLit) @"".Pos() (? @"go/token".Pos)
func (? *@"".BasicLit) @"".exprNode() ()
type @"".BinaryExpr struct { @"".X @"".Expr; @"".OpPos @"go/token".Pos; @"".Op @"go/token".Token; @"".Y @"".Expr }
func (? *@"".BinaryExpr) @"".End() (? @"go/token".Pos)
func (? *@"".BinaryExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".BinaryExpr) @"".exprNode() ()
type @"".BlockStmt struct { @"".Lbrace @"go/token".Pos; @"".List []@"".Stmt; @"".Rbrace @"go/token".Pos }
func (? *@"".BlockStmt) @"".End() (? @"go/token".Pos)
func (? *@"".BlockStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".BlockStmt) @"".stmtNode() ()
type @"".BranchStmt struct { @"".TokPos @"go/token".Pos; @"".Tok @"go/token".Token; @"".Label *@"".Ident }
func (? *@"".BranchStmt) @"".End() (? @"go/token".Pos)
func (? *@"".BranchStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".BranchStmt) @"".stmtNode() ()
type @"".CallExpr struct { @"".Fun @"".Expr; @"".Lparen @"go/token".Pos; @"".Args []@"".Expr; @"".Ellipsis @"go/token".Pos; @"".Rparen @"go/token".Pos }
func (? *@"".CallExpr) @"".End() (? @"go/token".Pos)
func (? *@"".CallExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".CallExpr) @"".exprNode() ()
type @"".CaseClause struct { @"".Case @"go/token".Pos; @"".List []@"".Expr; @"".Colon @"go/token".Pos; @"".Body []@"".Stmt }
func (? *@"".CaseClause) @"".End() (? @"go/token".Pos)
func (? *@"".CaseClause) @"".Pos() (? @"go/token".Pos)
func (? *@"".CaseClause) @"".stmtNode() ()
type @"".ChanDir int
type @"".ChanType struct { @"".Begin @"go/token".Pos; @"".Arrow @"go/token".Pos; @"".Dir @"".ChanDir; @"".Value @"".Expr }
func (? *@"".ChanType) @"".End() (? @"go/token".Pos)
func (? *@"".ChanType) @"".Pos() (? @"go/token".Pos)
func (? *@"".ChanType) @"".exprNode() ()
type @"".CommClause struct { @"".Case @"go/token".Pos; @"".Comm @"".Stmt; @"".Colon @"go/token".Pos; @"".Body []@"".Stmt }
func (? *@"".CommClause) @"".End() (? @"go/token".Pos)
func (? *@"".CommClause) @"".Pos() (? @"go/token".Pos)
func (? *@"".CommClause) @"".stmtNode() ()
type @"".Comment struct { @"".Slash @"go/token".Pos; @"".Text string }
func (? *@"".Comment) @"".End() (? @"go/token".Pos)
func (? *@"".Comment) @"".Pos() (? @"go/token".Pos)
type @"".CommentGroup struct { @"".List []*@"".Comment }
func (? *@"".CommentGroup) @"".End() (? @"go/token".Pos)
func (? *@"".CommentGroup) @"".Pos() (? @"go/token".Pos)
func (? *@"".CommentGroup) @"".Text() (? string)
type @"".CommentMap map[@"".Node][]*@"".CommentGroup
func (? @"".CommentMap) @"".Comments() (? []*@"".CommentGroup)
func (? @"".CommentMap) @"".Filter(@"".node @"".Node) (? @"".CommentMap)
func (? @"".CommentMap) @"".String() (? string)
func (? @"".CommentMap) @"".Update(@"".old @"".Node, @"".new @"".Node) (? @"".Node)
func (? @"".CommentMap) @"".addComment(@"".n @"".Node, @"".c *@"".CommentGroup) ()
func (? *@"".CommentMap) @"".Comments() (? []*@"".CommentGroup)
func (? *@"".CommentMap) @"".Filter(@"".node @"".Node) (? @"".CommentMap)
func (? *@"".CommentMap) @"".String() (? string)
func (? *@"".CommentMap) @"".Update(@"".old @"".Node, @"".new @"".Node) (? @"".Node)
func (? *@"".CommentMap) @"".addComment(@"".n @"".Node, @"".c *@"".CommentGroup) ()
type @"".CompositeLit struct { @"".Type @"".Expr; @"".Lbrace @"go/token".Pos; @"".Elts []@"".Expr; @"".Rbrace @"go/token".Pos }
func (? *@"".CompositeLit) @"".End() (? @"go/token".Pos)
func (? *@"".CompositeLit) @"".Pos() (? @"go/token".Pos)
func (? *@"".CompositeLit) @"".exprNode() ()
const @"".Con @"".ObjKind = 0x2
type @"".Decl interface { @"".End() (? @"go/token".Pos); @"".Pos() (? @"go/token".Pos); @"".declNode() () }
type @"".DeclStmt struct { @"".Decl @"".Decl }
func (? *@"".DeclStmt) @"".End() (? @"go/token".Pos)
func (? *@"".DeclStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".DeclStmt) @"".stmtNode() ()
type @"".DeferStmt struct { @"".Defer @"go/token".Pos; @"".Call *@"".CallExpr }
func (? *@"".DeferStmt) @"".End() (? @"go/token".Pos)
func (? *@"".DeferStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".DeferStmt) @"".stmtNode() ()
type @"".Ellipsis struct { @"".Ellipsis @"go/token".Pos; @"".Elt @"".Expr }
func (? *@"".Ellipsis) @"".End() (? @"go/token".Pos)
func (? *@"".Ellipsis) @"".Pos() (? @"go/token".Pos)
func (? *@"".Ellipsis) @"".exprNode() ()
type @"".EmptyStmt struct { @"".Semicolon @"go/token".Pos }
func (? *@"".EmptyStmt) @"".End() (? @"go/token".Pos)
func (? *@"".EmptyStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".EmptyStmt) @"".stmtNode() ()
type @"".Expr interface { @"".End() (? @"go/token".Pos); @"".Pos() (? @"go/token".Pos); @"".exprNode() () }
type @"".ExprStmt struct { @"".X @"".Expr }
func (? *@"".ExprStmt) @"".End() (? @"go/token".Pos)
func (? *@"".ExprStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".ExprStmt) @"".stmtNode() ()
type @"".Field struct { @"".Doc *@"".CommentGroup; @"".Names []*@"".Ident; @"".Type @"".Expr; @"".Tag *@"".BasicLit; @"".Comment *@"".CommentGroup }
func (? *@"".Field) @"".End() (? @"go/token".Pos)
func (? *@"".Field) @"".Pos() (? @"go/token".Pos)
type @"".FieldFilter func (@"".name string, @"".value @"reflect".Value) (? bool)
type @"".FieldList struct { @"".Opening @"go/token".Pos; @"".List []*@"".Field; @"".Closing @"go/token".Pos }
func (? *@"".FieldList) @"".End() (? @"go/token".Pos)
func (? *@"".FieldList) @"".NumFields() (? int)
func (? *@"".FieldList) @"".Pos() (? @"go/token".Pos)
type @"".File struct { @"".Doc *@"".CommentGroup; @"".Package @"go/token".Pos; @"".Name *@"".Ident; @"".Decls []@"".Decl; @"".Scope *@"".Scope; @"".Imports []*@"".ImportSpec; @"".Unresolved []*@"".Ident; @"".Comments []*@"".CommentGroup }
func (? *@"".File) @"".End() (? @"go/token".Pos)
func (? *@"".File) @"".Pos() (? @"go/token".Pos)
func @"".FileExports(@"".src *@"".File) (? bool)
type @"".Filter func (? string) (? bool)
func @"".FilterDecl(@"".decl @"".Decl, @"".f @"".Filter) (? bool)
func @"".FilterFile(@"".src *@"".File, @"".f @"".Filter) (? bool)
const @"".FilterFuncDuplicates @"".MergeMode = 0x1
const @"".FilterImportDuplicates @"".MergeMode = 0x4
func @"".FilterPackage(@"".pkg *@"".Package, @"".f @"".Filter) (? bool)
const @"".FilterUnassociatedComments @"".MergeMode = 0x2
type @"".ForStmt struct { @"".For @"go/token".Pos; @"".Init @"".Stmt; @"".Cond @"".Expr; @"".Post @"".Stmt; @"".Body *@"".BlockStmt }
func (? *@"".ForStmt) @"".End() (? @"go/token".Pos)
func (? *@"".ForStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".ForStmt) @"".stmtNode() ()
func @"".Fprint(@"".w @"io".Writer, @"".fset *@"go/token".FileSet, @"".x interface {  }, @"".f @"".FieldFilter) (@"".err error)
const @"".Fun @"".ObjKind = 0x5
type @"".FuncDecl struct { @"".Doc *@"".CommentGroup; @"".Recv *@"".FieldList; @"".Name *@"".Ident; @"".Type *@"".FuncType; @"".Body *@"".BlockStmt }
func (? *@"".FuncDecl) @"".End() (? @"go/token".Pos)
func (? *@"".FuncDecl) @"".Pos() (? @"go/token".Pos)
func (? *@"".FuncDecl) @"".declNode() ()
type @"".FuncLit struct { @"".Type *@"".FuncType; @"".Body *@"".BlockStmt }
func (? *@"".FuncLit) @"".End() (? @"go/token".Pos)
func (? *@"".FuncLit) @"".Pos() (? @"go/token".Pos)
func (? *@"".FuncLit) @"".exprNode() ()
type @"".FuncType struct { @"".Func @"go/token".Pos; @"".Params *@"".FieldList; @"".Results *@"".FieldList }
func (? *@"".FuncType) @"".End() (? @"go/token".Pos)
func (? *@"".FuncType) @"".Pos() (? @"go/token".Pos)
func (? *@"".FuncType) @"".exprNode() ()
type @"".GenDecl struct { @"".Doc *@"".CommentGroup; @"".TokPos @"go/token".Pos; @"".Tok @"go/token".Token; @"".Lparen @"go/token".Pos; @"".Specs []@"".Spec; @"".Rparen @"go/token".Pos }
func (? *@"".GenDecl) @"".End() (? @"go/token".Pos)
func (? *@"".GenDecl) @"".Pos() (? @"go/token".Pos)
func (? *@"".GenDecl) @"".declNode() ()
type @"".GoStmt struct { @"".Go @"go/token".Pos; @"".Call *@"".CallExpr }
func (? *@"".GoStmt) @"".End() (? @"go/token".Pos)
func (? *@"".GoStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".GoStmt) @"".stmtNode() ()
type @"".Ident struct { @"".NamePos @"go/token".Pos; @"".Name string; @"".Obj *@"".Object }
func (? *@"".Ident) @"".End() (? @"go/token".Pos)
func (? *@"".Ident) @"".IsExported() (? bool)
func (? *@"".Ident) @"".Pos() (? @"go/token".Pos)
func (? *@"".Ident) @"".String() (? string)
func (? *@"".Ident) @"".exprNode() ()
type @"".IfStmt struct { @"".If @"go/token".Pos; @"".Init @"".Stmt; @"".Cond @"".Expr; @"".Body *@"".BlockStmt; @"".Else @"".Stmt }
func (? *@"".IfStmt) @"".End() (? @"go/token".Pos)
func (? *@"".IfStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".IfStmt) @"".stmtNode() ()
type @"".ImportSpec struct { @"".Doc *@"".CommentGroup; @"".Name *@"".Ident; @"".Path *@"".BasicLit; @"".Comment *@"".CommentGroup; @"".EndPos @"go/token".Pos }
func (? *@"".ImportSpec) @"".End() (? @"go/token".Pos)
func (? *@"".ImportSpec) @"".Pos() (? @"go/token".Pos)
func (? *@"".ImportSpec) @"".specNode() ()
type @"".Importer func (@"".imports map[string]*@"".Object, @"".path string) (@"".pkg *@"".Object, @"".err error)
type @"".IncDecStmt struct { @"".X @"".Expr; @"".TokPos @"go/token".Pos; @"".Tok @"go/token".Token }
func (? *@"".IncDecStmt) @"".End() (? @"go/token".Pos)
func (? *@"".IncDecStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".IncDecStmt) @"".stmtNode() ()
type @"".IndexExpr struct { @"".X @"".Expr; @"".Lbrack @"go/token".Pos; @"".Index @"".Expr; @"".Rbrack @"go/token".Pos }
func (? *@"".IndexExpr) @"".End() (? @"go/token".Pos)
func (? *@"".IndexExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".IndexExpr) @"".exprNode() ()
func @"".Inspect(@"".node @"".Node, @"".f func (? @"".Node) (? bool)) ()
type @"".InterfaceType struct { @"".Interface @"go/token".Pos; @"".Methods *@"".FieldList; @"".Incomplete bool }
func (? *@"".InterfaceType) @"".End() (? @"go/token".Pos)
func (? *@"".InterfaceType) @"".Pos() (? @"go/token".Pos)
func (? *@"".InterfaceType) @"".exprNode() ()
func @"".IsExported(@"".name string) (? bool)
type @"".KeyValueExpr struct { @"".Key @"".Expr; @"".Colon @"go/token".Pos; @"".Value @"".Expr }
func (? *@"".KeyValueExpr) @"".End() (? @"go/token".Pos)
func (? *@"".KeyValueExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".KeyValueExpr) @"".exprNode() ()
type @"".LabeledStmt struct { @"".Label *@"".Ident; @"".Colon @"go/token".Pos; @"".Stmt @"".Stmt }
func (? *@"".LabeledStmt) @"".End() (? @"go/token".Pos)
func (? *@"".LabeledStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".LabeledStmt) @"".stmtNode() ()
const @"".Lbl @"".ObjKind = 0x6
type @"".MapType struct { @"".Map @"go/token".Pos; @"".Key @"".Expr; @"".Value @"".Expr }
func (? *@"".MapType) @"".End() (? @"go/token".Pos)
func (? *@"".MapType) @"".Pos() (? @"go/token".Pos)
func (? *@"".MapType) @"".exprNode() ()
type @"".MergeMode uint
func @"".MergePackageFiles(@"".pkg *@"".Package, @"".mode @"".MergeMode) (? *@"".File)
func @"".NewCommentMap(@"".fset *@"go/token".FileSet, @"".node @"".Node, @"".comments []*@"".CommentGroup) (? @"".CommentMap)
func @"".NewIdent(@"".name string) (? *@"".Ident)
func @"".NewObj(@"".kind @"".ObjKind, @"".name string) (? *@"".Object)
func @"".NewPackage(@"".fset *@"go/token".FileSet, @"".files map[string]*@"".File, @"".importer @"".Importer, @"".universe *@"".Scope) (? *@"".Package, ? error)
func @"".NewScope(@"".outer *@"".Scope) (? *@"".Scope)
type @"".Node interface { @"".End() (? @"go/token".Pos); @"".Pos() (? @"go/token".Pos) }
func @"".NotNilFilter(_ string, @"".v @"reflect".Value) (? bool)
type @"".ObjKind int
func (? @"".ObjKind) @"".String() (? string)
func (? *@"".ObjKind) @"".String() (? string)
type @"".Object struct { @"".Kind @"".ObjKind; @"".Name string; @"".Decl interface {  }; @"".Data interface {  }; @"".Type interface {  } }
func (? *@"".Object) @"".Pos() (? @"go/token".Pos)
type @"".Package struct { @"".Name string; @"".Scope *@"".Scope; @"".Imports map[string]*@"".Object; @"".Files map[string]*@"".File }
func (? *@"".Package) @"".End() (? @"go/token".Pos)
func (? *@"".Package) @"".Pos() (? @"go/token".Pos)
func @"".PackageExports(@"".pkg *@"".Package) (? bool)
type @"".ParenExpr struct { @"".Lparen @"go/token".Pos; @"".X @"".Expr; @"".Rparen @"go/token".Pos }
func (? *@"".ParenExpr) @"".End() (? @"go/token".Pos)
func (? *@"".ParenExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".ParenExpr) @"".exprNode() ()
const @"".Pkg @"".ObjKind = 0x1
func @"".Print(@"".fset *@"go/token".FileSet, @"".x interface {  }) (? error)
const @"".RECV @"".ChanDir = 0x2
type @"".RangeStmt struct { @"".For @"go/token".Pos; @"".Key @"".Expr; @"".Value @"".Expr; @"".TokPos @"go/token".Pos; @"".Tok @"go/token".Token; @"".X @"".Expr; @"".Body *@"".BlockStmt }
func (? *@"".RangeStmt) @"".End() (? @"go/token".Pos)
func (? *@"".RangeStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".RangeStmt) @"".stmtNode() ()
type @"".ReturnStmt struct { @"".Return @"go/token".Pos; @"".Results []@"".Expr }
func (? *@"".ReturnStmt) @"".End() (? @"go/token".Pos)
func (? *@"".ReturnStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".ReturnStmt) @"".stmtNode() ()
const @"".SEND @"".ChanDir = 0x1
type @"".Scope struct { @"".Outer *@"".Scope; @"".Objects map[string]*@"".Object }
func (? *@"".Scope) @"".Insert(@"".obj *@"".Object) (@"".alt *@"".Object)
func (? *@"".Scope) @"".Lookup(@"".name string) (? *@"".Object)
func (? *@"".Scope) @"".String() (? string)
type @"".SelectStmt struct { @"".Select @"go/token".Pos; @"".Body *@"".BlockStmt }
func (? *@"".SelectStmt) @"".End() (? @"go/token".Pos)
func (? *@"".SelectStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".SelectStmt) @"".stmtNode() ()
type @"".SelectorExpr struct { @"".X @"".Expr; @"".Sel *@"".Ident }
func (? *@"".SelectorExpr) @"".End() (? @"go/token".Pos)
func (? *@"".SelectorExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".SelectorExpr) @"".exprNode() ()
type @"".SendStmt struct { @"".Chan @"".Expr; @"".Arrow @"go/token".Pos; @"".Value @"".Expr }
func (? *@"".SendStmt) @"".End() (? @"go/token".Pos)
func (? *@"".SendStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".SendStmt) @"".stmtNode() ()
type @"".SliceExpr struct { @"".X @"".Expr; @"".Lbrack @"go/token".Pos; @"".Low @"".Expr; @"".High @"".Expr; @"".Max @"".Expr; @"".Slice3 bool; @"".Rbrack @"go/token".Pos }
func (? *@"".SliceExpr) @"".End() (? @"go/token".Pos)
func (? *@"".SliceExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".SliceExpr) @"".exprNode() ()
func @"".SortImports(@"".fset *@"go/token".FileSet, @"".f *@"".File) ()
type @"".Spec interface { @"".End() (? @"go/token".Pos); @"".Pos() (? @"go/token".Pos); @"".specNode() () }
type @"".StarExpr struct { @"".Star @"go/token".Pos; @"".X @"".Expr }
func (? *@"".StarExpr) @"".End() (? @"go/token".Pos)
func (? *@"".StarExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".StarExpr) @"".exprNode() ()
type @"".Stmt interface { @"".End() (? @"go/token".Pos); @"".Pos() (? @"go/token".Pos); @"".stmtNode() () }
type @"".StructType struct { @"".Struct @"go/token".Pos; @"".Fields *@"".FieldList; @"".Incomplete bool }
func (? *@"".StructType) @"".End() (? @"go/token".Pos)
func (? *@"".StructType) @"".Pos() (? @"go/token".Pos)
func (? *@"".StructType) @"".exprNode() ()
type @"".SwitchStmt struct { @"".Switch @"go/token".Pos; @"".Init @"".Stmt; @"".Tag @"".Expr; @"".Body *@"".BlockStmt }
func (? *@"".SwitchStmt) @"".End() (? @"go/token".Pos)
func (? *@"".SwitchStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".SwitchStmt) @"".stmtNode() ()
const @"".Typ @"".ObjKind = 0x3
type @"".TypeAssertExpr struct { @"".X @"".Expr; @"".Lparen @"go/token".Pos; @"".Type @"".Expr; @"".Rparen @"go/token".Pos }
func (? *@"".TypeAssertExpr) @"".End() (? @"go/token".Pos)
func (? *@"".TypeAssertExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".TypeAssertExpr) @"".exprNode() ()
type @"".TypeSpec struct { @"".Doc *@"".CommentGroup; @"".Name *@"".Ident; @"".Type @"".Expr; @"".Comment *@"".CommentGroup }
func (? *@"".TypeSpec) @"".End() (? @"go/token".Pos)
func (? *@"".TypeSpec) @"".Pos() (? @"go/token".Pos)
func (? *@"".TypeSpec) @"".specNode() ()
type @"".TypeSwitchStmt struct { @"".Switch @"go/token".Pos; @"".Init @"".Stmt; @"".Assign @"".Stmt; @"".Body *@"".BlockStmt }
func (? *@"".TypeSwitchStmt) @"".End() (? @"go/token".Pos)
func (? *@"".TypeSwitchStmt) @"".Pos() (? @"go/token".Pos)
func (? *@"".TypeSwitchStmt) @"".stmtNode() ()
type @"".UnaryExpr struct { @"".OpPos @"go/token".Pos; @"".Op @"go/token".Token; @"".X @"".Expr }
func (? *@"".UnaryExpr) @"".End() (? @"go/token".Pos)
func (? *@"".UnaryExpr) @"".Pos() (? @"go/token".Pos)
func (? *@"".UnaryExpr) @"".exprNode() ()
type @"".ValueSpec struct { @"".Doc *@"".CommentGroup; @"".Names []*@"".Ident; @"".Type @"".Expr; @"".Values []@"".Expr; @"".Comment *@"".CommentGroup }
func (? *@"".ValueSpec) @"".End() (? @"go/token".Pos)
func (? *@"".ValueSpec) @"".Pos() (? @"go/token".Pos)
func (? *@"".ValueSpec) @"".specNode() ()
const @"".Var @"".ObjKind = 0x4
type @"".Visitor interface { @"".Visit(@"".node @"".Node) (@"".w @"".Visitor) }
func @"".Walk(@"".v @"".Visitor, @"".node @"".Node) ()
type @"".byCommentPos []*@"".CommentGroup
func (? @"".byCommentPos) @"".Len() (? int)
func (? @"".byCommentPos) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byCommentPos) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byCommentPos) @"".Len() (? int)
func (? *@"".byCommentPos) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byCommentPos) @"".Swap(@"".i int, @"".j int) ()
type @"".byImportSpec []@"".Spec
func (? @"".byImportSpec) @"".Len() (? int)
func (? @"".byImportSpec) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byImportSpec) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byImportSpec) @"".Len() (? int)
func (? *@"".byImportSpec) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byImportSpec) @"".Swap(@"".i int, @"".j int) ()
type @"".byInterval []@"".Node
func (? @"".byInterval) @"".Len() (? int)
func (? @"".byInterval) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byInterval) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byInterval) @"".Len() (? int)
func (? *@"".byInterval) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byInterval) @"".Swap(@"".i int, @"".j int) ()
type @"".byPos []*@"".CommentGroup
func (? @"".byPos) @"".Len() (? int)
func (? @"".byPos) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byPos) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byPos) @"".Len() (? int)
func (? *@"".byPos) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byPos) @"".Swap(@"".i int, @"".j int) ()
type @"".commentListReader struct { @"".fset *@"go/token".FileSet; @"".list []*@"".CommentGroup; @"".index int; @"".comment *@"".CommentGroup; @"".pos @"go/token".Position; @"".end @"go/token".Position }
func (? *@"".commentListReader) @"".eol() (? bool)
func (? *@"".commentListReader) @"".next() ()
type @"".inspector func (? @"".Node) (? bool)
func (? @"".inspector) @"".Visit(@"".node @"".Node) (? @"".Visitor)
func (? *@"".inspector) @"".Visit(@"".node @"".Node) (? @"".Visitor)
type @"".localError struct { @"".err error }
type @"".nodeStack []@"".Node
func (? *@"".nodeStack) @"".pop(@"".pos @"go/token".Pos) (@"".top @"".Node)
func (? *@"".nodeStack) @"".push(@"".n @"".Node) ()
type @"".pkgBuilder struct { @"".fset *@"go/token".FileSet; @"".errors @"go/scanner".ErrorList }
func (? *@"".pkgBuilder) @"".declare(@"".scope *@"".Scope, @"".altScope *@"".Scope, @"".obj *@"".Object) ()
func (? *@"".pkgBuilder) @"".error(@"".pos @"go/token".Pos, @"".msg string) ()
func (? *@"".pkgBuilder) @"".errorf(@"".pos @"go/token".Pos, @"".format string, @"".args ...interface {  }) ()
type @"".posSpan struct { @"".Start @"go/token".Pos; @"".End @"go/token".Pos }
type @"".printer struct { @"".output @"io".Writer; @"".fset *@"go/token".FileSet; @"".filter @"".FieldFilter; @"".ptrmap map[interface {  }]int; @"".indent int; @"".last byte; @"".line int }
func (? *@"".printer) @"".Write(@"".data []byte) (@"".n int, @"".err error)
func (? *@"".printer) @"".print(@"".x @"reflect".Value) ()
func (? *@"".printer) @"".printf(@"".format string, @"".args ...interface {  }) ()
type @"go/token".Pos int
func (? @"go/token".Pos) @"go/token".IsValid() (? bool)
func (? *@"go/token".Pos) @"go/token".IsValid() (? bool)
type @"go/token".Token int
func (? @"go/token".Token) @"go/token".IsKeyword() (? bool)
func (? @"go/token".Token) @"go/token".IsLiteral() (? bool)
func (? @"go/token".Token) @"go/token".IsOperator() (? bool)
func (? @"go/token".Token) @"go/token".Precedence() (? int)
func (? @"go/token".Token) @"go/token".String() (? string)
func (? *@"go/token".Token) @"go/token".IsKeyword() (? bool)
func (? *@"go/token".Token) @"go/token".IsLiteral() (? bool)
func (? *@"go/token".Token) @"go/token".IsOperator() (? bool)
func (? *@"go/token".Token) @"go/token".Precedence() (? int)
func (? *@"go/token".Token) @"go/token".String() (? string)
type @"reflect".Value struct { @"reflect".typ *@"reflect".rtype; @"reflect".val @"unsafe".Pointer; ? @"reflect".flag }
func (? @"reflect".Value) @"reflect".Addr() (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Bool() (? bool)
func (? @"reflect".Value) @"reflect".Bytes() (? []byte)
func (? @"reflect".Value) @"reflect".Call(@"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".CallSlice(@"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".CanAddr() (? bool)
func (? @"reflect".Value) @"reflect".CanInterface() (? bool)
func (? @"reflect".Value) @"reflect".CanSet() (? bool)
func (? @"reflect".Value) @"reflect".Cap() (? int)
func (? @"reflect".Value) @"reflect".Close() ()
func (? @"reflect".Value) @"reflect".Complex() (? complex128)
func (? @"reflect".Value) @"reflect".Convert(@"reflect".t @"reflect".Type) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Elem() (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Field(@"reflect".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByIndex(@"reflect".index []int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByName(@"reflect".name string) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".FieldByNameFunc(@"reflect".match func (? string) (? bool)) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Float() (? float64)
func (? @"reflect".Value) @"reflect".Index(@"reflect".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Int() (? int64)
func (? @"reflect".Value) @"reflect".Interface() (@"reflect".i interface {  })
func (? @"reflect".Value) @"reflect".InterfaceData() (? [2]uintptr)
func (? @"reflect".Value) @"reflect".IsNil() (? bool)
func (? @"reflect".Value) @"reflect".IsValid() (? bool)
func (? @"reflect".Value) @"reflect".Kind() (? @"reflect".Kind)
func (? @"reflect".Value) @"reflect".Len() (? int)
func (? @"reflect".Value) @"reflect".MapIndex(@"reflect".key @"reflect".Value) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".MapKeys() (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".Method(@"reflect".i int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".MethodByName(@"reflect".name string) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".NumField() (? int)
func (? @"reflect".Value) @"reflect".NumMethod() (? int)
func (? @"reflect".Value) @"reflect".OverflowComplex(@"reflect".x complex128) (? bool)
func (? @"reflect".Value) @"reflect".OverflowFloat(@"reflect".x float64) (? bool)
func (? @"reflect".Value) @"reflect".OverflowInt(@"reflect".x int64) (? bool)
func (? @"reflect".Value) @"reflect".OverflowUint(@"reflect".x uint64) (? bool)
func (? @"reflect".Value) @"reflect".Pointer() (? uintptr)
func (? @"reflect".Value) @"reflect".Recv() (@"reflect".x @"reflect".Value, @"reflect".ok bool)
func (? @"reflect".Value) @"reflect".Send(@"reflect".x @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".Set(@"reflect".x @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".SetBool(@"reflect".x bool) ()
func (? @"reflect".Value) @"reflect".SetBytes(@"reflect".x []byte) ()
func (? @"reflect".Value) @"reflect".SetCap(@"reflect".n int) ()
func (? @"reflect".Value) @"reflect".SetComplex(@"reflect".x complex128) ()
func (? @"reflect".Value) @"reflect".SetFloat(@"reflect".x float64) ()
func (? @"reflect".Value) @"reflect".SetInt(@"reflect".x int64) ()
func (? @"reflect".Value) @"reflect".SetLen(@"reflect".n int) ()
func (? @"reflect".Value) @"reflect".SetMapIndex(@"reflect".key @"reflect".Value, @"reflect".val @"reflect".Value) ()
func (? @"reflect".Value) @"reflect".SetPointer(@"reflect".x @"unsafe".Pointer) ()
func (? @"reflect".Value) @"reflect".SetString(@"reflect".x string) ()
func (? @"reflect".Value) @"reflect".SetUint(@"reflect".x uint64) ()
func (? @"reflect".Value) @"reflect".Slice(@"reflect".i int, @"reflect".j int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".Slice3(@"reflect".i int, @"reflect".j int, @"reflect".k int) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".String() (? string)
func (? @"reflect".Value) @"reflect".TryRecv() (@"reflect".x @"reflect".Value, @"reflect".ok bool)
func (? @"reflect".Value) @"reflect".TrySend(@"reflect".x @"reflect".Value) (? bool)
func (? @"reflect".Value) @"reflect".Type() (? @"reflect".Type)
func (? @"reflect".Value) @"reflect".Uint() (? uint64)
func (? @"reflect".Value) @"reflect".UnsafeAddr() (? uintptr)
func (? @"reflect".Value) @"reflect".assignTo(@"reflect".context string, @"reflect".dst *@"reflect".rtype, @"reflect".target *interface {  }) (? @"reflect".Value)
func (? @"reflect".Value) @"reflect".call(@"reflect".op string, @"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? @"reflect".Value) @"reflect".iword() (? @"reflect".iword)
func (? @"reflect".Value) @"reflect".recv(@"reflect".nb bool) (@"reflect".val @"reflect".Value, @"reflect".ok bool)
func (? @"reflect".Value) @"reflect".runes() (? []rune)
func (? @"reflect".Value) @"reflect".send(@"reflect".x @"reflect".Value, @"reflect".nb bool) (@"reflect".selected bool)
func (? @"reflect".Value) @"reflect".setRunes(@"reflect".x []rune) ()
func (? *@"reflect".Value) @"reflect".Addr() (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Bool() (? bool)
func (? *@"reflect".Value) @"reflect".Bytes() (? []byte)
func (? *@"reflect".Value) @"reflect".Call(@"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".CallSlice(@"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".CanAddr() (? bool)
func (? *@"reflect".Value) @"reflect".CanInterface() (? bool)
func (? *@"reflect".Value) @"reflect".CanSet() (? bool)
func (? *@"reflect".Value) @"reflect".Cap() (? int)
func (? *@"reflect".Value) @"reflect".Close() ()
func (? *@"reflect".Value) @"reflect".Complex() (? complex128)
func (? *@"reflect".Value) @"reflect".Convert(@"reflect".t @"reflect".Type) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Elem() (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Field(@"reflect".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByIndex(@"reflect".index []int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByName(@"reflect".name string) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".FieldByNameFunc(@"reflect".match func (? string) (? bool)) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Float() (? float64)
func (? *@"reflect".Value) @"reflect".Index(@"reflect".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Int() (? int64)
func (? *@"reflect".Value) @"reflect".Interface() (@"reflect".i interface {  })
func (? *@"reflect".Value) @"reflect".InterfaceData() (? [2]uintptr)
func (? *@"reflect".Value) @"reflect".IsNil() (? bool)
func (? *@"reflect".Value) @"reflect".IsValid() (? bool)
func (? *@"reflect".Value) @"reflect".Kind() (? @"reflect".Kind)
func (? *@"reflect".Value) @"reflect".Len() (? int)
func (? *@"reflect".Value) @"reflect".MapIndex(@"reflect".key @"reflect".Value) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".MapKeys() (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".Method(@"reflect".i int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".MethodByName(@"reflect".name string) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".NumField() (? int)
func (? *@"reflect".Value) @"reflect".NumMethod() (? int)
func (? *@"reflect".Value) @"reflect".OverflowComplex(@"reflect".x complex128) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowFloat(@"reflect".x float64) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowInt(@"reflect".x int64) (? bool)
func (? *@"reflect".Value) @"reflect".OverflowUint(@"reflect".x uint64) (? bool)
func (? *@"reflect".Value) @"reflect".Pointer() (? uintptr)
func (? *@"reflect".Value) @"reflect".Recv() (@"reflect".x @"reflect".Value, @"reflect".ok bool)
func (? *@"reflect".Value) @"reflect".Send(@"reflect".x @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".Set(@"reflect".x @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".SetBool(@"reflect".x bool) ()
func (? *@"reflect".Value) @"reflect".SetBytes(@"reflect".x []byte) ()
func (? *@"reflect".Value) @"reflect".SetCap(@"reflect".n int) ()
func (? *@"reflect".Value) @"reflect".SetComplex(@"reflect".x complex128) ()
func (? *@"reflect".Value) @"reflect".SetFloat(@"reflect".x float64) ()
func (? *@"reflect".Value) @"reflect".SetInt(@"reflect".x int64) ()
func (? *@"reflect".Value) @"reflect".SetLen(@"reflect".n int) ()
func (? *@"reflect".Value) @"reflect".SetMapIndex(@"reflect".key @"reflect".Value, @"reflect".val @"reflect".Value) ()
func (? *@"reflect".Value) @"reflect".SetPointer(@"reflect".x @"unsafe".Pointer) ()
func (? *@"reflect".Value) @"reflect".SetString(@"reflect".x string) ()
func (? *@"reflect".Value) @"reflect".SetUint(@"reflect".x uint64) ()
func (? *@"reflect".Value) @"reflect".Slice(@"reflect".i int, @"reflect".j int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".Slice3(@"reflect".i int, @"reflect".j int, @"reflect".k int) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".String() (? string)
func (? *@"reflect".Value) @"reflect".TryRecv() (@"reflect".x @"reflect".Value, @"reflect".ok bool)
func (? *@"reflect".Value) @"reflect".TrySend(@"reflect".x @"reflect".Value) (? bool)
func (? *@"reflect".Value) @"reflect".Type() (? @"reflect".Type)
func (? *@"reflect".Value) @"reflect".Uint() (? uint64)
func (? *@"reflect".Value) @"reflect".UnsafeAddr() (? uintptr)
func (? *@"reflect".Value) @"reflect".assignTo(@"reflect".context string, @"reflect".dst *@"reflect".rtype, @"reflect".target *interface {  }) (? @"reflect".Value)
func (? *@"reflect".Value) @"reflect".call(@"reflect".op string, @"reflect".in []@"reflect".Value) (? []@"reflect".Value)
func (? *@"reflect".Value) @"reflect".iword() (? @"reflect".iword)
func (? *@"reflect".Value) @"reflect".recv(@"reflect".nb bool) (@"reflect".val @"reflect".Value, @"reflect".ok bool)
func (? *@"reflect".Value) @"reflect".runes() (? []rune)
func (? *@"reflect".Value) @"reflect".send(@"reflect".x @"reflect".Value, @"reflect".nb bool) (@"reflect".selected bool)
func (? *@"reflect".Value) @"reflect".setRunes(@"reflect".x []rune) ()
type @"io".Writer interface { @"io".Write(@"io".p []byte) (@"io".n int, @"io".err error) }
import sync "sync"
type @"go/token".FileSet struct { @"go/token".mutex @"sync".RWMutex; @"go/token".base int; @"go/token".files []*@"go/token".File; @"go/token".last *@"go/token".File }
func (? *@"go/token".FileSet) @"go/token".AddFile(@"go/token".filename string, @"go/token".base int, @"go/token".size int) (? *@"go/token".File)
func (? *@"go/token".FileSet) @"go/token".Base() (? int)
func (? *@"go/token".FileSet) @"go/token".File(@"go/token".p @"go/token".Pos) (@"go/token".f *@"go/token".File)
func (? *@"go/token".FileSet) @"go/token".Iterate(@"go/token".f func (? *@"go/token".File) (? bool)) ()
func (? *@"go/token".FileSet) @"go/token".Position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
func (? *@"go/token".FileSet) @"go/token".Read(@"go/token".decode func (? interface {  }) (? error)) (? error)
func (? *@"go/token".FileSet) @"go/token".Write(@"go/token".encode func (? interface {  }) (? error)) (? error)
func (? *@"go/token".FileSet) @"go/token".file(@"go/token".p @"go/token".Pos) (? *@"go/token".File)
type @"go/token".Position struct { @"go/token".Filename string; @"go/token".Offset int; @"go/token".Line int; @"go/token".Column int }
func (? @"go/token".Position) @"go/token".String() (? string)
func (? *@"go/token".Position) @"go/token".IsValid() (? bool)
func (? *@"go/token".Position) @"go/token".String() (? string)
type @"go/scanner".ErrorList []*@"go/scanner".Error
func (? @"go/scanner".ErrorList) @"go/scanner".Err() (? error)
func (? @"go/scanner".ErrorList) @"go/scanner".Error() (? string)
func (? @"go/scanner".ErrorList) @"go/scanner".Len() (? int)
func (? @"go/scanner".ErrorList) @"go/scanner".Less(@"go/scanner".i int, @"go/scanner".j int) (? bool)
func (? @"go/scanner".ErrorList) @"go/scanner".Sort() ()
func (? @"go/scanner".ErrorList) @"go/scanner".Swap(@"go/scanner".i int, @"go/scanner".j int) ()
func (? *@"go/scanner".ErrorList) @"go/scanner".Add(@"go/scanner".pos @"go/token".Position, @"go/scanner".msg string) ()
func (? *@"go/scanner".ErrorList) @"go/scanner".Err() (? error)
func (? *@"go/scanner".ErrorList) @"go/scanner".Error() (? string)
func (? *@"go/scanner".ErrorList) @"go/scanner".Len() (? int)
func (? *@"go/scanner".ErrorList) @"go/scanner".Less(@"go/scanner".i int, @"go/scanner".j int) (? bool)
func (? *@"go/scanner".ErrorList) @"go/scanner".RemoveMultiples() ()
func (? *@"go/scanner".ErrorList) @"go/scanner".Reset() ()
func (? *@"go/scanner".ErrorList) @"go/scanner".Sort() ()
func (? *@"go/scanner".ErrorList) @"go/scanner".Swap(@"go/scanner".i int, @"go/scanner".j int) ()
type @"reflect".rtype struct { @"reflect".size uintptr; @"reflect".hash uint32; _ uint8; @"reflect".align uint8; @"reflect".fieldAlign uint8; @"reflect".kind uint8; @"reflect".alg *uintptr; @"reflect".gc @"unsafe".Pointer; @"reflect".string *string; ? *@"reflect".uncommonType; @"reflect".ptrToThis *@"reflect".rtype }
func (? *@"reflect".rtype) @"reflect".Align() (? int)
func (? *@"reflect".rtype) @"reflect".AssignableTo(@"reflect".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".Bits() (? int)
func (? *@"reflect".rtype) @"reflect".ChanDir() (? @"reflect".ChanDir)
func (? *@"reflect".rtype) @"reflect".ConvertibleTo(@"reflect".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".Elem() (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".Field(@"reflect".i int) (? @"reflect".StructField)
func (? *@"reflect".rtype) @"reflect".FieldAlign() (? int)
func (? *@"reflect".rtype) @"reflect".FieldByIndex(@"reflect".index []int) (? @"reflect".StructField)
func (? *@"reflect".rtype) @"reflect".FieldByName(@"reflect".name string) (? @"reflect".StructField, ? bool)
func (? *@"reflect".rtype) @"reflect".FieldByNameFunc(@"reflect".match func (? string) (? bool)) (? @"reflect".StructField, ? bool)
func (? *@"reflect".rtype) @"reflect".Implements(@"reflect".u @"reflect".Type) (? bool)
func (? *@"reflect".rtype) @"reflect".In(@"reflect".i int) (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".IsVariadic() (? bool)
func (? *@"reflect".rtype) @"reflect".Key() (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".Kind() (? @"reflect".Kind)
func (? *@"reflect".rtype) @"reflect".Len() (? int)
func (? *@"reflect".rtype) @"reflect".Method(@"reflect".i int) (@"reflect".m @"reflect".Method)
func (? *@"reflect".rtype) @"reflect".MethodByName(@"reflect".name string) (@"reflect".m @"reflect".Method, @"reflect".ok bool)
func (? *@"reflect".rtype) @"reflect".Name() (? string)
func (? *@"reflect".rtype) @"reflect".NumField() (? int)
func (? *@"reflect".rtype) @"reflect".NumIn() (? int)
func (? *@"reflect".rtype) @"reflect".NumMethod() (? int)
func (? *@"reflect".rtype) @"reflect".NumOut() (? int)
func (? *@"reflect".rtype) @"reflect".Out(@"reflect".i int) (? @"reflect".Type)
func (? *@"reflect".rtype) @"reflect".PkgPath() (? string)
func (? *@"reflect".rtype) @"reflect".Size() (? uintptr)
func (? *@"reflect".rtype) @"reflect".String() (? string)
func (? *@"reflect".rtype) @"reflect".common() (? *@"reflect".rtype)
func (? *@"reflect".rtype) @"reflect".ptrTo() (? *@"reflect".rtype)
type @"reflect".flag uintptr
func (? @"reflect".flag) @"reflect".kind() (? @"reflect".Kind)
func (? @"reflect".flag) @"reflect".mustBe(@"reflect".expected @"reflect".Kind) ()
func (? @"reflect".flag) @"reflect".mustBeAssignable() ()
func (? @"reflect".flag) @"reflect".mustBeExported() ()
func (? *@"reflect".flag) @"reflect".kind() (? @"reflect".Kind)
func (? *@"reflect".flag) @"reflect".mustBe(@"reflect".expected @"reflect".Kind) ()
func (? *@"reflect".flag) @"reflect".mustBeAssignable() ()
func (? *@"reflect".flag) @"reflect".mustBeExported() ()
type @"reflect".Type interface { @"reflect".Align() (? int); @"reflect".AssignableTo(@"reflect".u @"reflect".Type) (? bool); @"reflect".Bits() (? int); @"reflect".ChanDir() (? @"reflect".ChanDir); @"reflect".ConvertibleTo(@"reflect".u @"reflect".Type) (? bool); @"reflect".Elem() (? @"reflect".Type); @"reflect".Field(@"reflect".i int) (? @"reflect".StructField); @"reflect".FieldAlign() (? int); @"reflect".FieldByIndex(@"reflect".index []int) (? @"reflect".StructField); @"reflect".FieldByName(@"reflect".name string) (? @"reflect".StructField, ? bool); @"reflect".FieldByNameFunc(@"reflect".match func (? string) (? bool)) (? @"reflect".StructField, ? bool); @"reflect".Implements(@"reflect".u @"reflect".Type) (? bool); @"reflect".In(@"reflect".i int) (? @"reflect".Type); @"reflect".IsVariadic() (? bool); @"reflect".Key() (? @"reflect".Type); @"reflect".Kind() (? @"reflect".Kind); @"reflect".Len() (? int); @"reflect".Method(? int) (? @"reflect".Method); @"reflect".MethodByName(? string) (? @"reflect".Method, ? bool); @"reflect".Name() (? string); @"reflect".NumField() (? int); @"reflect".NumIn() (? int); @"reflect".NumMethod() (? int); @"reflect".NumOut() (? int); @"reflect".Out(@"reflect".i int) (? @"reflect".Type); @"reflect".PkgPath() (? string); @"reflect".Size() (? uintptr); @"reflect".String() (? string); @"reflect".common() (? *@"reflect".rtype); @"reflect".uncommon() (? *@"reflect".uncommonType) }
type @"reflect".Kind uint
func (? @"reflect".Kind) @"reflect".String() (? string)
func (? *@"reflect".Kind) @"reflect".String() (? string)
type @"reflect".iword @"unsafe".Pointer
type @"sync".RWMutex struct { @"sync".w @"sync".Mutex; @"sync".writerSem uint32; @"sync".readerSem uint32; @"sync".readerCount int32; @"sync".readerWait int32 }
func (? *@"sync".RWMutex) @"sync".Lock() ()
func (? *@"sync".RWMutex) @"sync".RLock() ()
func (? *@"sync".RWMutex) @"sync".RLocker() (? @"sync".Locker)
func (? *@"sync".RWMutex) @"sync".RUnlock() ()
func (? *@"sync".RWMutex) @"sync".Unlock() ()
type @"go/token".File struct { @"go/token".set *@"go/token".FileSet; @"go/token".name string; @"go/token".base int; @"go/token".size int; @"go/token".lines []int; @"go/token".infos []@"go/token".lineInfo }
func (? *@"go/token".File) @"go/token".AddLine(@"go/token".offset int) ()
func (? *@"go/token".File) @"go/token".AddLineInfo(@"go/token".offset int, @"go/token".filename string, @"go/token".line int) ()
func (? *@"go/token".File) @"go/token".Base() (? int)
func (? *@"go/token".File) @"go/token".Line(@"go/token".p @"go/token".Pos) (? int)
func (? *@"go/token".File) @"go/token".LineCount() (? int)
func (? *@"go/token".File) @"go/token".MergeLine(@"go/token".line int) ()
func (? *@"go/token".File) @"go/token".Name() (? string)
func (? *@"go/token".File) @"go/token".Offset(@"go/token".p @"go/token".Pos) (? int)
func (? *@"go/token".File) @"go/token".Pos(@"go/token".offset int) (? @"go/token".Pos)
func (? *@"go/token".File) @"go/token".Position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
func (? *@"go/token".File) @"go/token".SetLines(@"go/token".lines []int) (? bool)
func (? *@"go/token".File) @"go/token".SetLinesForContent(@"go/token".content []byte) ()
func (? *@"go/token".File) @"go/token".Size() (? int)
func (? *@"go/token".File) @"go/token".info(@"go/token".offset int) (@"go/token".filename string, @"go/token".line int, @"go/token".column int)
func (? *@"go/token".File) @"go/token".position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
type @"go/scanner".Error struct { @"go/scanner".Pos @"go/token".Position; @"go/scanner".Msg string }
func (? @"go/scanner".Error) @"go/scanner".Error() (? string)
func (? *@"go/scanner".Error) @"go/scanner".Error() (? string)
type @"reflect".uncommonType struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".methods []@"reflect".method }
func (? *@"reflect".uncommonType) @"reflect".Method(@"reflect".i int) (@"reflect".m @"reflect".Method)
func (? *@"reflect".uncommonType) @"reflect".MethodByName(@"reflect".name string) (@"reflect".m @"reflect".Method, @"reflect".ok bool)
func (? *@"reflect".uncommonType) @"reflect".Name() (? string)
func (? *@"reflect".uncommonType) @"reflect".NumMethod() (? int)
func (? *@"reflect".uncommonType) @"reflect".PkgPath() (? string)
func (? *@"reflect".uncommonType) @"reflect".uncommon() (? *@"reflect".uncommonType)
type @"reflect".ChanDir int
func (? @"reflect".ChanDir) @"reflect".String() (? string)
func (? *@"reflect".ChanDir) @"reflect".String() (? string)
type @"reflect".StructField struct { @"reflect".Name string; @"reflect".PkgPath string; @"reflect".Type @"reflect".Type; @"reflect".Tag @"reflect".StructTag; @"reflect".Offset uintptr; @"reflect".Index []int; @"reflect".Anonymous bool }
type @"reflect".Method struct { @"reflect".Name string; @"reflect".PkgPath string; @"reflect".Type @"reflect".Type; @"reflect".Func @"reflect".Value; @"reflect".Index int }
type @"sync".Mutex struct { @"sync".state int32; @"sync".sema uint32 }
func (? *@"sync".Mutex) @"sync".Lock() ()
func (? *@"sync".Mutex) @"sync".Unlock() ()
type @"sync".Locker interface { @"sync".Lock() (); @"sync".Unlock() () }
type @"go/token".lineInfo struct { @"go/token".Offset int; @"go/token".Filename string; @"go/token".Line int }
type @"reflect".method struct { @"reflect".name *string; @"reflect".pkgPath *string; @"reflect".mtyp *@"reflect".rtype; @"reflect".typ *@"reflect".rtype; @"reflect".ifn @"unsafe".Pointer; @"reflect".tfn @"unsafe".Pointer }
type @"reflect".StructTag string
func (? @"reflect".StructTag) @"reflect".Get(@"reflect".key string) (? string)
func (? *@"reflect".StructTag) @"reflect".Get(@"reflect".key string) (? string)
$$
0Å≤runtimeerrorssync/atomicsynciounicodeunicode/utf8bytesmathsyscalltimeosstrconvreflectfmtsortgo/tokenstringspath/filepath
go/scannergo/ast0ÅŒ0go/tokentoken0stringsstrings0unicodeunicode0unicode/utf8utf80bytesbytes0
fmtfmt0sortsort0strconvstrconv0ioio0osos0reflectreflect0
go/scannerscanner0É∞0ÅÚNodeV	Node = go$pkg.Node = go$newType(0, "Interface", "ast.Node", "Node", "go/ast", null);
w		Node.init([["End", "", (go$funcType([], [token.Pos], false))], ["Pos", "", (go$funcType([], [token.Pos], false))]]);
0Node00go/tokenPos0Ç)ExprV	Expr = go$pkg.Expr = go$newType(0, "Interface", "ast.Expr", "Expr", "go/ast", null);
Å≠		Expr.init([["End", "", (go$funcType([], [token.Pos], false))], ["Pos", "", (go$funcType([], [token.Pos], false))], ["exprNode", "go/ast", (go$funcType([], [], false))]]);
0Expr00go/tokenPos0Ç)StmtV	Stmt = go$pkg.Stmt = go$newType(0, "Interface", "ast.Stmt", "Stmt", "go/ast", null);
Å≠		Stmt.init([["End", "", (go$funcType([], [token.Pos], false))], ["Pos", "", (go$funcType([], [token.Pos], false))], ["stmtNode", "go/ast", (go$funcType([], [], false))]]);
0Stmt00go/tokenPos0Ç)DeclV	Decl = go$pkg.Decl = go$newType(0, "Interface", "ast.Decl", "Decl", "go/ast", null);
Å≠		Decl.init([["End", "", (go$funcType([], [token.Pos], false))], ["Pos", "", (go$funcType([], [token.Pos], false))], ["declNode", "go/ast", (go$funcType([], [], false))]]);
0Decl00go/tokenPos0Ç◊CommentÅÔ	Comment = go$pkg.Comment = go$newType(0, "Struct", "ast.Comment", "Comment", "go/ast", function(Slash_, Text_) {
		this.go$val = this;
		this.Slash = Slash_ !== undefined ? Slash_ : 0;
		this.Text = Text_ !== undefined ? Text_ : "";
	});
Åª		Comment.init([["Slash", "", token.Pos, ""], ["Text", "", Go$String, ""]]);
		(go$ptrType(Comment)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false]];
0	Comment00go/tokenPos0Ç#CommentGroupÅ	CommentGroup = go$pkg.CommentGroup = go$newType(0, "Struct", "ast.CommentGroup", "CommentGroup", "go/ast", function(List_) {
		this.go$val = this;
		this.List = List_ !== undefined ? List_ : (go$sliceType((go$ptrType(Comment)))).nil;
	});
ÅÈ		CommentGroup.init([["List", "", (go$sliceType((go$ptrType(Comment)))), ""]]);
		(go$ptrType(CommentGroup)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["Text", "", [], [Go$String], false]];
0CommentGroup0$0go/astComment0go/tokenPos0Ç”FieldÇ	Field = go$pkg.Field = go$newType(0, "Struct", "ast.Field", "Field", "go/ast", function(Doc_, Names_, Type_, Tag_, Comment_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Names = Names_ !== undefined ? Names_ : (go$sliceType((go$ptrType(Ident)))).nil;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Tag = Tag_ !== undefined ? Tag_ : (go$ptrType(BasicLit)).nil;
		this.Comment = Comment_ !== undefined ? Comment_ : (go$ptrType(CommentGroup)).nil;
	});
ÇS		Field.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Names", "", (go$sliceType((go$ptrType(Ident)))), ""], ["Type", "", Expr, ""], ["Tag", "", (go$ptrType(BasicLit)), ""], ["Comment", "", (go$ptrType(CommentGroup)), ""]]);
		(go$ptrType(Field)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false]];
0Field0^0go/astCommentGroup0go/astIdent0go/astBasicLit0go/astExpr0go/tokenPos0ÇÕ	FieldListÇf	FieldList = go$pkg.FieldList = go$newType(0, "Struct", "ast.FieldList", "FieldList", "go/ast", function(Opening_, List_, Closing_) {
		this.go$val = this;
		this.Opening = Opening_ !== undefined ? Opening_ : 0;
		this.List = List_ !== undefined ? List_ : (go$sliceType((go$ptrType(Field)))).nil;
		this.Closing = Closing_ !== undefined ? Closing_ : 0;
	});
Ç#		FieldList.init([["Opening", "", token.Pos, ""], ["List", "", (go$sliceType((go$ptrType(Field)))), ""], ["Closing", "", token.Pos, ""]]);
		(go$ptrType(FieldList)).methods = [["End", "", [], [token.Pos], false], ["NumFields", "", [], [Go$Int], false], ["Pos", "", [], [token.Pos], false]];
0	FieldList0"0go/astField0go/tokenPos0ÇÓBadExprÅ‚	BadExpr = go$pkg.BadExpr = go$newType(0, "Struct", "ast.BadExpr", "BadExpr", "go/ast", function(From_, To_) {
		this.go$val = this;
		this.From = From_ !== undefined ? From_ : 0;
		this.To = To_ !== undefined ? To_ : 0;
	});
Åﬂ		BadExpr.init([["From", "", token.Pos, ""], ["To", "", token.Pos, ""]]);
		(go$ptrType(BadExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	BadExpr00go/tokenPos0ÇŒIdentÇ8	Ident = go$pkg.Ident = go$newType(0, "Struct", "ast.Ident", "Ident", "go/ast", function(NamePos_, Name_, Obj_) {
		this.go$val = this;
		this.NamePos = NamePos_ !== undefined ? NamePos_ : 0;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Obj = Obj_ !== undefined ? Obj_ : (go$ptrType(Object)).nil;
	});
ÇY		Ident.init([["NamePos", "", token.Pos, ""], ["Name", "", Go$String, ""], ["Obj", "", (go$ptrType(Object)), ""]]);
		(go$ptrType(Ident)).methods = [["End", "", [], [token.Pos], false], ["IsExported", "", [], [Go$Bool], false], ["Pos", "", [], [token.Pos], false], ["String", "", [], [Go$String], false], ["exprNode", "go/ast", [], [], false]];
0Ident0#0go/astObject0go/tokenPos0ÇEllipsisÅ˝	Ellipsis = go$pkg.Ellipsis = go$newType(0, "Struct", "ast.Ellipsis", "Ellipsis", "go/ast", function(Ellipsis_, Elt_) {
		this.go$val = this;
		this.Ellipsis = Ellipsis_ !== undefined ? Ellipsis_ : 0;
		this.Elt = Elt_ !== undefined ? Elt_ : null;
	});
Å·		Ellipsis.init([["Ellipsis", "", token.Pos, ""], ["Elt", "", Expr, ""]]);
		(go$ptrType(Ellipsis)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
Ellipsis0!0go/tokenPos0go/astExpr0ÇÑBasicLitÇ9	BasicLit = go$pkg.BasicLit = go$newType(0, "Struct", "ast.BasicLit", "BasicLit", "go/ast", function(ValuePos_, Kind_, Value_) {
		this.go$val = this;
		this.ValuePos = ValuePos_ !== undefined ? ValuePos_ : 0;
		this.Kind = Kind_ !== undefined ? Kind_ : 0;
		this.Value = Value_ !== undefined ? Value_ : "";
	});
Ç		BasicLit.init([["ValuePos", "", token.Pos, ""], ["Kind", "", token.Token, ""], ["Value", "", Go$String, ""]]);
		(go$ptrType(BasicLit)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
BasicLit0$0go/tokenPos0go/tokenToken0ÇpFuncLitÇ	FuncLit = go$pkg.FuncLit = go$newType(0, "Struct", "ast.FuncLit", "FuncLit", "go/ast", function(Type_, Body_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : (go$ptrType(FuncType)).nil;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Å¸		FuncLit.init([["Type", "", (go$ptrType(FuncType)), ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(FuncLit)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	FuncLit0:0go/astFuncType0go/ast	BlockStmt0go/tokenPos0ÇCompositeLitÇî	CompositeLit = go$pkg.CompositeLit = go$newType(0, "Struct", "ast.CompositeLit", "CompositeLit", "go/ast", function(Type_, Lbrace_, Elts_, Rbrace_) {
		this.go$val = this;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Lbrace = Lbrace_ !== undefined ? Lbrace_ : 0;
		this.Elts = Elts_ !== undefined ? Elts_ : (go$sliceType(Expr)).nil;
		this.Rbrace = Rbrace_ !== undefined ? Rbrace_ : 0;
	});
Ç/		CompositeLit.init([["Type", "", Expr, ""], ["Lbrace", "", token.Pos, ""], ["Elts", "", (go$sliceType(Expr)), ""], ["Rbrace", "", token.Pos, ""]]);
		(go$ptrType(CompositeLit)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0CompositeLit0!0go/astExpr0go/tokenPos0Ço	ParenExprÇ/	ParenExpr = go$pkg.ParenExpr = go$newType(0, "Struct", "ast.ParenExpr", "ParenExpr", "go/ast", function(Lparen_, X_, Rparen_) {
		this.go$val = this;
		this.Lparen = Lparen_ !== undefined ? Lparen_ : 0;
		this.X = X_ !== undefined ? X_ : null;
		this.Rparen = Rparen_ !== undefined ? Rparen_ : 0;
	});
Å˛		ParenExpr.init([["Lparen", "", token.Pos, ""], ["X", "", Expr, ""], ["Rparen", "", token.Pos, ""]]);
		(go$ptrType(ParenExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	ParenExpr0!0go/tokenPos0go/astExpr0ÇLSelectorExprÇ	SelectorExpr = go$pkg.SelectorExpr = go$newType(0, "Struct", "ast.SelectorExpr", "SelectorExpr", "go/ast", function(X_, Sel_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.Sel = Sel_ !== undefined ? Sel_ : (go$ptrType(Ident)).nil;
	});
ÅÏ		SelectorExpr.init([["X", "", Expr, ""], ["Sel", "", (go$ptrType(Ident)), ""]]);
		(go$ptrType(SelectorExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0SelectorExpr020go/astIdent0go/astExpr0go/tokenPos0Ç∆	IndexExprÇl	IndexExpr = go$pkg.IndexExpr = go$newType(0, "Struct", "ast.IndexExpr", "IndexExpr", "go/ast", function(X_, Lbrack_, Index_, Rbrack_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.Lbrack = Lbrack_ !== undefined ? Lbrack_ : 0;
		this.Index = Index_ !== undefined ? Index_ : null;
		this.Rbrack = Rbrack_ !== undefined ? Rbrack_ : 0;
	});
Ç		IndexExpr.init([["X", "", Expr, ""], ["Lbrack", "", token.Pos, ""], ["Index", "", Expr, ""], ["Rbrack", "", token.Pos, ""]]);
		(go$ptrType(IndexExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	IndexExpr0!0go/astExpr0go/tokenPos0Ç∏	SliceExprÇ	SliceExpr = go$pkg.SliceExpr = go$newType(0, "Struct", "ast.SliceExpr", "SliceExpr", "go/ast", function(X_, Lbrack_, Low_, High_, Max_, Slice3_, Rbrack_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.Lbrack = Lbrack_ !== undefined ? Lbrack_ : 0;
		this.Low = Low_ !== undefined ? Low_ : null;
		this.High = High_ !== undefined ? High_ : null;
		this.Max = Max_ !== undefined ? Max_ : null;
		this.Slice3 = Slice3_ !== undefined ? Slice3_ : false;
		this.Rbrack = Rbrack_ !== undefined ? Rbrack_ : 0;
	});
Ça		SliceExpr.init([["X", "", Expr, ""], ["Lbrack", "", token.Pos, ""], ["Low", "", Expr, ""], ["High", "", Expr, ""], ["Max", "", Expr, ""], ["Slice3", "", Go$Bool, ""], ["Rbrack", "", token.Pos, ""]]);
		(go$ptrType(SliceExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	SliceExpr0!0go/astExpr0go/tokenPos0ÇÈTypeAssertExprÇ|	TypeAssertExpr = go$pkg.TypeAssertExpr = go$newType(0, "Struct", "ast.TypeAssertExpr", "TypeAssertExpr", "go/ast", function(X_, Lparen_, Type_, Rparen_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.Lparen = Lparen_ !== undefined ? Lparen_ : 0;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Rparen = Rparen_ !== undefined ? Rparen_ : 0;
	});
Ç 		TypeAssertExpr.init([["X", "", Expr, ""], ["Lparen", "", token.Pos, ""], ["Type", "", Expr, ""], ["Rparen", "", token.Pos, ""]]);
		(go$ptrType(TypeAssertExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0TypeAssertExpr0!0go/astExpr0go/tokenPos0ÇNCallExprÇ∆	CallExpr = go$pkg.CallExpr = go$newType(0, "Struct", "ast.CallExpr", "CallExpr", "go/ast", function(Fun_, Lparen_, Args_, Ellipsis_, Rparen_) {
		this.go$val = this;
		this.Fun = Fun_ !== undefined ? Fun_ : null;
		this.Lparen = Lparen_ !== undefined ? Lparen_ : 0;
		this.Args = Args_ !== undefined ? Args_ : (go$sliceType(Expr)).nil;
		this.Ellipsis = Ellipsis_ !== undefined ? Ellipsis_ : 0;
		this.Rparen = Rparen_ !== undefined ? Rparen_ : 0;
	});
ÇG		CallExpr.init([["Fun", "", Expr, ""], ["Lparen", "", token.Pos, ""], ["Args", "", (go$sliceType(Expr)), ""], ["Ellipsis", "", token.Pos, ""], ["Rparen", "", token.Pos, ""]]);
		(go$ptrType(CallExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
CallExpr0!0go/astExpr0go/tokenPos0ÇˇStarExprÅÂ	StarExpr = go$pkg.StarExpr = go$newType(0, "Struct", "ast.StarExpr", "StarExpr", "go/ast", function(Star_, X_) {
		this.go$val = this;
		this.Star = Star_ !== undefined ? Star_ : 0;
		this.X = X_ !== undefined ? X_ : null;
	});
Å€		StarExpr.init([["Star", "", token.Pos, ""], ["X", "", Expr, ""]]);
		(go$ptrType(StarExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
StarExpr0!0go/tokenPos0go/astExpr0Çk	UnaryExprÇ	UnaryExpr = go$pkg.UnaryExpr = go$newType(0, "Struct", "ast.UnaryExpr", "UnaryExpr", "go/ast", function(OpPos_, Op_, X_) {
		this.go$val = this;
		this.OpPos = OpPos_ !== undefined ? OpPos_ : 0;
		this.Op = Op_ !== undefined ? Op_ : 0;
		this.X = X_ !== undefined ? X_ : null;
	});
Å˚		UnaryExpr.init([["OpPos", "", token.Pos, ""], ["Op", "", token.Token, ""], ["X", "", Expr, ""]]);
		(go$ptrType(UnaryExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	UnaryExpr040go/tokenPos0go/tokenToken0go/astExpr0Ç∂
BinaryExprÇL	BinaryExpr = go$pkg.BinaryExpr = go$newType(0, "Struct", "ast.BinaryExpr", "BinaryExpr", "go/ast", function(X_, OpPos_, Op_, Y_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.OpPos = OpPos_ !== undefined ? OpPos_ : 0;
		this.Op = Op_ !== undefined ? Op_ : 0;
		this.Y = Y_ !== undefined ? Y_ : null;
	});
Ç		BinaryExpr.init([["X", "", Expr, ""], ["OpPos", "", token.Pos, ""], ["Op", "", token.Token, ""], ["Y", "", Expr, ""]]);
		(go$ptrType(BinaryExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
BinaryExpr040go/astExpr0go/tokenPos0go/tokenToken0ÇÖKeyValueExprÇ>	KeyValueExpr = go$pkg.KeyValueExpr = go$newType(0, "Struct", "ast.KeyValueExpr", "KeyValueExpr", "go/ast", function(Key_, Colon_, Value_) {
		this.go$val = this;
		this.Key = Key_ !== undefined ? Key_ : null;
		this.Colon = Colon_ !== undefined ? Colon_ : 0;
		this.Value = Value_ !== undefined ? Value_ : null;
	});
Åˇ		KeyValueExpr.init([["Key", "", Expr, ""], ["Colon", "", token.Pos, ""], ["Value", "", Expr, ""]]);
		(go$ptrType(KeyValueExpr)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0KeyValueExpr0!0go/astExpr0go/tokenPos0vChanDir\	ChanDir = go$pkg.ChanDir = go$newType(4, "Int", "ast.ChanDir", "ChanDir", "go/ast", null);
 0	ChanDir0 0Çh	ArrayTypeÇ.	ArrayType = go$pkg.ArrayType = go$newType(0, "Struct", "ast.ArrayType", "ArrayType", "go/ast", function(Lbrack_, Len_, Elt_) {
		this.go$val = this;
		this.Lbrack = Lbrack_ !== undefined ? Lbrack_ : 0;
		this.Len = Len_ !== undefined ? Len_ : null;
		this.Elt = Elt_ !== undefined ? Elt_ : null;
	});
Å¯		ArrayType.init([["Lbrack", "", token.Pos, ""], ["Len", "", Expr, ""], ["Elt", "", Expr, ""]]);
		(go$ptrType(ArrayType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	ArrayType0!0go/tokenPos0go/astExpr0Ç÷
StructTypeÇr	StructType = go$pkg.StructType = go$newType(0, "Struct", "ast.StructType", "StructType", "go/ast", function(Struct_, Fields_, Incomplete_) {
		this.go$val = this;
		this.Struct = Struct_ !== undefined ? Struct_ : 0;
		this.Fields = Fields_ !== undefined ? Fields_ : (go$ptrType(FieldList)).nil;
		this.Incomplete = Incomplete_ !== undefined ? Incomplete_ : false;
	});
Ç		StructType.init([["Struct", "", token.Pos, ""], ["Fields", "", (go$ptrType(FieldList)), ""], ["Incomplete", "", Go$Bool, ""]]);
		(go$ptrType(StructType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
StructType0&0go/ast	FieldList0go/tokenPos0Ç”FuncTypeÇl	FuncType = go$pkg.FuncType = go$newType(0, "Struct", "ast.FuncType", "FuncType", "go/ast", function(Func_, Params_, Results_) {
		this.go$val = this;
		this.Func = Func_ !== undefined ? Func_ : 0;
		this.Params = Params_ !== undefined ? Params_ : (go$ptrType(FieldList)).nil;
		this.Results = Results_ !== undefined ? Results_ : (go$ptrType(FieldList)).nil;
	});
Ç!		FuncType.init([["Func", "", token.Pos, ""], ["Params", "", (go$ptrType(FieldList)), ""], ["Results", "", (go$ptrType(FieldList)), ""]]);
		(go$ptrType(FuncType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
FuncType0&0go/ast	FieldList0go/tokenPos0ÇInterfaceTypeÇé	InterfaceType = go$pkg.InterfaceType = go$newType(0, "Struct", "ast.InterfaceType", "InterfaceType", "go/ast", function(Interface_, Methods_, Incomplete_) {
		this.go$val = this;
		this.Interface = Interface_ !== undefined ? Interface_ : 0;
		this.Methods = Methods_ !== undefined ? Methods_ : (go$ptrType(FieldList)).nil;
		this.Incomplete = Incomplete_ !== undefined ? Incomplete_ : false;
	});
Ç$		InterfaceType.init([["Interface", "", token.Pos, ""], ["Methods", "", (go$ptrType(FieldList)), ""], ["Incomplete", "", Go$Bool, ""]]);
		(go$ptrType(InterfaceType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0InterfaceType0&0go/ast	FieldList0go/tokenPos0ÇSMapTypeÇ"	MapType = go$pkg.MapType = go$newType(0, "Struct", "ast.MapType", "MapType", "go/ast", function(Map_, Key_, Value_) {
		this.go$val = this;
		this.Map = Map_ !== undefined ? Map_ : 0;
		this.Key = Key_ !== undefined ? Key_ : null;
		this.Value = Value_ !== undefined ? Value_ : null;
	});
ÅÛ		MapType.init([["Map", "", token.Pos, ""], ["Key", "", Expr, ""], ["Value", "", Expr, ""]]);
		(go$ptrType(MapType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0	MapType0!0go/tokenPos0go/astExpr0Ç—ChanTypeÇe	ChanType = go$pkg.ChanType = go$newType(0, "Struct", "ast.ChanType", "ChanType", "go/ast", function(Begin_, Arrow_, Dir_, Value_) {
		this.go$val = this;
		this.Begin = Begin_ !== undefined ? Begin_ : 0;
		this.Arrow = Arrow_ !== undefined ? Arrow_ : 0;
		this.Dir = Dir_ !== undefined ? Dir_ : 0;
		this.Value = Value_ !== undefined ? Value_ : null;
	});
Ç		ChanType.init([["Begin", "", token.Pos, ""], ["Arrow", "", token.Pos, ""], ["Dir", "", ChanDir, ""], ["Value", "", Expr, ""]]);
		(go$ptrType(ChanType)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["exprNode", "go/ast", [], [], false]];
0
ChanType040go/tokenPos0go/astChanDir0go/astExpr0ÇÓBadStmtÅ‚	BadStmt = go$pkg.BadStmt = go$newType(0, "Struct", "ast.BadStmt", "BadStmt", "go/ast", function(From_, To_) {
		this.go$val = this;
		this.From = From_ !== undefined ? From_ : 0;
		this.To = To_ !== undefined ? To_ : 0;
	});
Åﬂ		BadStmt.init([["From", "", token.Pos, ""], ["To", "", token.Pos, ""]]);
		(go$ptrType(BadStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	BadStmt00go/tokenPos0ÇªDeclStmtÅª	DeclStmt = go$pkg.DeclStmt = go$newType(0, "Struct", "ast.DeclStmt", "DeclStmt", "go/ast", function(Decl_) {
		this.go$val = this;
		this.Decl = Decl_ !== undefined ? Decl_ : null;
	});
Å¡		DeclStmt.init([["Decl", "", Decl, ""]]);
		(go$ptrType(DeclStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
DeclStmt0!0go/astDecl0go/tokenPos0ÇŒ	EmptyStmtÅ–	EmptyStmt = go$pkg.EmptyStmt = go$newType(0, "Struct", "ast.EmptyStmt", "EmptyStmt", "go/ast", function(Semicolon_) {
		this.go$val = this;
		this.Semicolon = Semicolon_ !== undefined ? Semicolon_ : 0;
	});
ÅÕ		EmptyStmt.init([["Semicolon", "", token.Pos, ""]]);
		(go$ptrType(EmptyStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	EmptyStmt00go/tokenPos0Ç∂LabeledStmtÇQ	LabeledStmt = go$pkg.LabeledStmt = go$newType(0, "Struct", "ast.LabeledStmt", "LabeledStmt", "go/ast", function(Label_, Colon_, Stmt_) {
		this.go$val = this;
		this.Label = Label_ !== undefined ? Label_ : (go$ptrType(Ident)).nil;
		this.Colon = Colon_ !== undefined ? Colon_ : 0;
		this.Stmt = Stmt_ !== undefined ? Stmt_ : null;
	});
Ç		LabeledStmt.init([["Label", "", (go$ptrType(Ident)), ""], ["Colon", "", token.Pos, ""], ["Stmt", "", Stmt, ""]]);
		(go$ptrType(LabeledStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0LabeledStmt020go/astIdent0go/tokenPos0go/astStmt0Ç¨ExprStmtÅØ	ExprStmt = go$pkg.ExprStmt = go$newType(0, "Struct", "ast.ExprStmt", "ExprStmt", "go/ast", function(X_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
	});
Åæ		ExprStmt.init([["X", "", Expr, ""]]);
		(go$ptrType(ExprStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
ExprStmt0!0go/astExpr0go/tokenPos0ÇjSendStmtÇ2	SendStmt = go$pkg.SendStmt = go$newType(0, "Struct", "ast.SendStmt", "SendStmt", "go/ast", function(Chan_, Arrow_, Value_) {
		this.go$val = this;
		this.Chan = Chan_ !== undefined ? Chan_ : null;
		this.Arrow = Arrow_ !== undefined ? Arrow_ : 0;
		this.Value = Value_ !== undefined ? Value_ : null;
	});
Å¯		SendStmt.init([["Chan", "", Expr, ""], ["Arrow", "", token.Pos, ""], ["Value", "", Expr, ""]]);
		(go$ptrType(SendStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
SendStmt0!0go/astExpr0go/tokenPos0Ç}
IncDecStmtÇ'	IncDecStmt = go$pkg.IncDecStmt = go$newType(0, "Struct", "ast.IncDecStmt", "IncDecStmt", "go/ast", function(X_, TokPos_, Tok_) {
		this.go$val = this;
		this.X = X_ !== undefined ? X_ : null;
		this.TokPos = TokPos_ !== undefined ? TokPos_ : 0;
		this.Tok = Tok_ !== undefined ? Tok_ : 0;
	});
Åˇ		IncDecStmt.init([["X", "", Expr, ""], ["TokPos", "", token.Pos, ""], ["Tok", "", token.Token, ""]]);
		(go$ptrType(IncDecStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
IncDecStmt040go/astExpr0go/tokenPos0go/tokenToken0Ç
AssignStmtÇå	AssignStmt = go$pkg.AssignStmt = go$newType(0, "Struct", "ast.AssignStmt", "AssignStmt", "go/ast", function(Lhs_, TokPos_, Tok_, Rhs_) {
		this.go$val = this;
		this.Lhs = Lhs_ !== undefined ? Lhs_ : (go$sliceType(Expr)).nil;
		this.TokPos = TokPos_ !== undefined ? TokPos_ : 0;
		this.Tok = Tok_ !== undefined ? Tok_ : 0;
		this.Rhs = Rhs_ !== undefined ? Rhs_ : (go$sliceType(Expr)).nil;
	});
Ç8		AssignStmt.init([["Lhs", "", (go$sliceType(Expr)), ""], ["TokPos", "", token.Pos, ""], ["Tok", "", token.Token, ""], ["Rhs", "", (go$sliceType(Expr)), ""]]);
		(go$ptrType(AssignStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
AssignStmt040go/astExpr0go/tokenPos0go/tokenToken0Ç GoStmtÅ˜	GoStmt = go$pkg.GoStmt = go$newType(0, "Struct", "ast.GoStmt", "GoStmt", "go/ast", function(Go_, Call_) {
		this.go$val = this;
		this.Go = Go_ !== undefined ? Go_ : 0;
		this.Call = Call_ !== undefined ? Call_ : (go$ptrType(CallExpr)).nil;
	});
ÅÍ		GoStmt.init([["Go", "", token.Pos, ""], ["Call", "", (go$ptrType(CallExpr)), ""]]);
		(go$ptrType(GoStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0GoStmt0%0go/astCallExpr0go/tokenPos0ÇH	DeferStmtÇ	DeferStmt = go$pkg.DeferStmt = go$newType(0, "Struct", "ast.DeferStmt", "DeferStmt", "go/ast", function(Defer_, Call_) {
		this.go$val = this;
		this.Defer = Defer_ !== undefined ? Defer_ : 0;
		this.Call = Call_ !== undefined ? Call_ : (go$ptrType(CallExpr)).nil;
	});
ÅÛ		DeferStmt.init([["Defer", "", token.Pos, ""], ["Call", "", (go$ptrType(CallExpr)), ""]]);
		(go$ptrType(DeferStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	DeferStmt0%0go/astCallExpr0go/tokenPos0Ç\
ReturnStmtÇ!	ReturnStmt = go$pkg.ReturnStmt = go$newType(0, "Struct", "ast.ReturnStmt", "ReturnStmt", "go/ast", function(Return_, Results_) {
		this.go$val = this;
		this.Return = Return_ !== undefined ? Return_ : 0;
		this.Results = Results_ !== undefined ? Results_ : (go$sliceType(Expr)).nil;
	});
Å˜		ReturnStmt.init([["Return", "", token.Pos, ""], ["Results", "", (go$sliceType(Expr)), ""]]);
		(go$ptrType(ReturnStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
ReturnStmt0!0go/astExpr0go/tokenPos0Çµ
BranchStmtÇJ	BranchStmt = go$pkg.BranchStmt = go$newType(0, "Struct", "ast.BranchStmt", "BranchStmt", "go/ast", function(TokPos_, Tok_, Label_) {
		this.go$val = this;
		this.TokPos = TokPos_ !== undefined ? TokPos_ : 0;
		this.Tok = Tok_ !== undefined ? Tok_ : 0;
		this.Label = Label_ !== undefined ? Label_ : (go$ptrType(Ident)).nil;
	});
Ç		BranchStmt.init([["TokPos", "", token.Pos, ""], ["Tok", "", token.Token, ""], ["Label", "", (go$ptrType(Ident)), ""]]);
		(go$ptrType(BranchStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
BranchStmt050go/astIdent0go/tokenPos0go/tokenToken0Ç£	BlockStmtÇO	BlockStmt = go$pkg.BlockStmt = go$newType(0, "Struct", "ast.BlockStmt", "BlockStmt", "go/ast", function(Lbrace_, List_, Rbrace_) {
		this.go$val = this;
		this.Lbrace = Lbrace_ !== undefined ? Lbrace_ : 0;
		this.List = List_ !== undefined ? List_ : (go$sliceType(Stmt)).nil;
		this.Rbrace = Rbrace_ !== undefined ? Rbrace_ : 0;
	});
Ç		BlockStmt.init([["Lbrace", "", token.Pos, ""], ["List", "", (go$sliceType(Stmt)), ""], ["Rbrace", "", token.Pos, ""]]);
		(go$ptrType(BlockStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	BlockStmt0!0go/astStmt0go/tokenPos0Ç8IfStmtÇ£	IfStmt = go$pkg.IfStmt = go$newType(0, "Struct", "ast.IfStmt", "IfStmt", "go/ast", function(If_, Init_, Cond_, Body_, Else_) {
		this.go$val = this;
		this.If = If_ !== undefined ? If_ : 0;
		this.Init = Init_ !== undefined ? Init_ : null;
		this.Cond = Cond_ !== undefined ? Cond_ : null;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
		this.Else = Else_ !== undefined ? Else_ : null;
	});
Ç3		IfStmt.init([["If", "", token.Pos, ""], ["Init", "", Stmt, ""], ["Cond", "", Expr, ""], ["Body", "", (go$ptrType(BlockStmt)), ""], ["Else", "", Stmt, ""]]);
		(go$ptrType(IfStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0IfStmt0F0go/ast	BlockStmt0go/tokenPos0go/astStmt0go/astExpr0Ç!
CaseClauseÇî	CaseClause = go$pkg.CaseClause = go$newType(0, "Struct", "ast.CaseClause", "CaseClause", "go/ast", function(Case_, List_, Colon_, Body_) {
		this.go$val = this;
		this.Case = Case_ !== undefined ? Case_ : 0;
		this.List = List_ !== undefined ? List_ : (go$sliceType(Expr)).nil;
		this.Colon = Colon_ !== undefined ? Colon_ : 0;
		this.Body = Body_ !== undefined ? Body_ : (go$sliceType(Stmt)).nil;
	});
Ç8		CaseClause.init([["Case", "", token.Pos, ""], ["List", "", (go$sliceType(Expr)), ""], ["Colon", "", token.Pos, ""], ["Body", "", (go$sliceType(Stmt)), ""]]);
		(go$ptrType(CaseClause)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
CaseClause010go/astExpr0go/astStmt0go/tokenPos0Ç
SwitchStmtÇÜ	SwitchStmt = go$pkg.SwitchStmt = go$newType(0, "Struct", "ast.SwitchStmt", "SwitchStmt", "go/ast", function(Switch_, Init_, Tag_, Body_) {
		this.go$val = this;
		this.Switch = Switch_ !== undefined ? Switch_ : 0;
		this.Init = Init_ !== undefined ? Init_ : null;
		this.Tag = Tag_ !== undefined ? Tag_ : null;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Ç&		SwitchStmt.init([["Switch", "", token.Pos, ""], ["Init", "", Stmt, ""], ["Tag", "", Expr, ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(SwitchStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
SwitchStmt0F0go/ast	BlockStmt0go/tokenPos0go/astStmt0go/astExpr0Ç5TypeSwitchStmtÇ¢	TypeSwitchStmt = go$pkg.TypeSwitchStmt = go$newType(0, "Struct", "ast.TypeSwitchStmt", "TypeSwitchStmt", "go/ast", function(Switch_, Init_, Assign_, Body_) {
		this.go$val = this;
		this.Switch = Switch_ !== undefined ? Switch_ : 0;
		this.Init = Init_ !== undefined ? Init_ : null;
		this.Assign = Assign_ !== undefined ? Assign_ : null;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Ç1		TypeSwitchStmt.init([["Switch", "", token.Pos, ""], ["Init", "", Stmt, ""], ["Assign", "", Stmt, ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(TypeSwitchStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0TypeSwitchStmt060go/ast	BlockStmt0go/tokenPos0go/astStmt0ÇÌ
CommClauseÇÄ	CommClause = go$pkg.CommClause = go$newType(0, "Struct", "ast.CommClause", "CommClause", "go/ast", function(Case_, Comm_, Colon_, Body_) {
		this.go$val = this;
		this.Case = Case_ !== undefined ? Case_ : 0;
		this.Comm = Comm_ !== undefined ? Comm_ : null;
		this.Colon = Colon_ !== undefined ? Colon_ : 0;
		this.Body = Body_ !== undefined ? Body_ : (go$sliceType(Stmt)).nil;
	});
Ç(		CommClause.init([["Case", "", token.Pos, ""], ["Comm", "", Stmt, ""], ["Colon", "", token.Pos, ""], ["Body", "", (go$sliceType(Stmt)), ""]]);
		(go$ptrType(CommClause)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
CommClause0!0go/astStmt0go/tokenPos0ÇX
SelectStmtÇ	SelectStmt = go$pkg.SelectStmt = go$newType(0, "Struct", "ast.SelectStmt", "SelectStmt", "go/ast", function(Select_, Body_) {
		this.go$val = this;
		this.Select = Select_ !== undefined ? Select_ : 0;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Å˜		SelectStmt.init([["Select", "", token.Pos, ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(SelectStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0
SelectStmt0&0go/ast	BlockStmt0go/tokenPos0ÇEForStmtÇ´	ForStmt = go$pkg.ForStmt = go$newType(0, "Struct", "ast.ForStmt", "ForStmt", "go/ast", function(For_, Init_, Cond_, Post_, Body_) {
		this.go$val = this;
		this.For = For_ !== undefined ? For_ : 0;
		this.Init = Init_ !== undefined ? Init_ : null;
		this.Cond = Cond_ !== undefined ? Cond_ : null;
		this.Post = Post_ !== undefined ? Post_ : null;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Ç6		ForStmt.init([["For", "", token.Pos, ""], ["Init", "", Stmt, ""], ["Cond", "", Expr, ""], ["Post", "", Stmt, ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(ForStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	ForStmt0F0go/ast	BlockStmt0go/tokenPos0go/astStmt0go/astExpr0Çˆ	RangeStmtÇ	RangeStmt = go$pkg.RangeStmt = go$newType(0, "Struct", "ast.RangeStmt", "RangeStmt", "go/ast", function(For_, Key_, Value_, TokPos_, Tok_, X_, Body_) {
		this.go$val = this;
		this.For = For_ !== undefined ? For_ : 0;
		this.Key = Key_ !== undefined ? Key_ : null;
		this.Value = Value_ !== undefined ? Value_ : null;
		this.TokPos = TokPos_ !== undefined ? TokPos_ : 0;
		this.Tok = Tok_ !== undefined ? Tok_ : 0;
		this.X = X_ !== undefined ? X_ : null;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Çt		RangeStmt.init([["For", "", token.Pos, ""], ["Key", "", Expr, ""], ["Value", "", Expr, ""], ["TokPos", "", token.Pos, ""], ["Tok", "", token.Token, ""], ["X", "", Expr, ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(RangeStmt)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["stmtNode", "go/ast", [], [], false]];
0	RangeStmt0I0go/ast	BlockStmt0go/tokenPos0go/astExpr0go/tokenToken0Ç)SpecV	Spec = go$pkg.Spec = go$newType(0, "Interface", "ast.Spec", "Spec", "go/ast", null);
Å≠		Spec.init([["End", "", (go$funcType([], [token.Pos], false))], ["Pos", "", (go$funcType([], [token.Pos], false))], ["specNode", "go/ast", (go$funcType([], [], false))]]);
0Spec00go/tokenPos0Ç˛
ImportSpecÇ	ImportSpec = go$pkg.ImportSpec = go$newType(0, "Struct", "ast.ImportSpec", "ImportSpec", "go/ast", function(Doc_, Name_, Path_, Comment_, EndPos_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Ident)).nil;
		this.Path = Path_ !== undefined ? Path_ : (go$ptrType(BasicLit)).nil;
		this.Comment = Comment_ !== undefined ? Comment_ : (go$ptrType(CommentGroup)).nil;
		this.EndPos = EndPos_ !== undefined ? EndPos_ : 0;
	});
Ç{		ImportSpec.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Name", "", (go$ptrType(Ident)), ""], ["Path", "", (go$ptrType(BasicLit)), ""], ["Comment", "", (go$ptrType(CommentGroup)), ""], ["EndPos", "", token.Pos, ""]]);
		(go$ptrType(ImportSpec)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["specNode", "go/ast", [], [], false]];
0
ImportSpec0N0go/astCommentGroup0go/astIdent0go/astBasicLit0go/tokenPos0Ç	ValueSpecÇ"	ValueSpec = go$pkg.ValueSpec = go$newType(0, "Struct", "ast.ValueSpec", "ValueSpec", "go/ast", function(Doc_, Names_, Type_, Values_, Comment_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Names = Names_ !== undefined ? Names_ : (go$sliceType((go$ptrType(Ident)))).nil;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Values = Values_ !== undefined ? Values_ : (go$sliceType(Expr)).nil;
		this.Comment = Comment_ !== undefined ? Comment_ : (go$ptrType(CommentGroup)).nil;
	});
ÇÉ		ValueSpec.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Names", "", (go$sliceType((go$ptrType(Ident)))), ""], ["Type", "", Expr, ""], ["Values", "", (go$sliceType(Expr)), ""], ["Comment", "", (go$ptrType(CommentGroup)), ""]]);
		(go$ptrType(ValueSpec)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["specNode", "go/ast", [], [], false]];
0	ValueSpec0J0go/astCommentGroup0go/astIdent0go/astExpr0go/tokenPos0ÇeTypeSpecÇµ	TypeSpec = go$pkg.TypeSpec = go$newType(0, "Struct", "ast.TypeSpec", "TypeSpec", "go/ast", function(Doc_, Name_, Type_, Comment_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Ident)).nil;
		this.Type = Type_ !== undefined ? Type_ : null;
		this.Comment = Comment_ !== undefined ? Comment_ : (go$ptrType(CommentGroup)).nil;
	});
ÇF		TypeSpec.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Name", "", (go$ptrType(Ident)), ""], ["Type", "", Expr, ""], ["Comment", "", (go$ptrType(CommentGroup)), ""]]);
		(go$ptrType(TypeSpec)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["specNode", "go/ast", [], [], false]];
0
TypeSpec0J0go/astCommentGroup0go/astIdent0go/astExpr0go/tokenPos0ÇÓBadDeclÅ‚	BadDecl = go$pkg.BadDecl = go$newType(0, "Struct", "ast.BadDecl", "BadDecl", "go/ast", function(From_, To_) {
		this.go$val = this;
		this.From = From_ !== undefined ? From_ : 0;
		this.To = To_ !== undefined ? To_ : 0;
	});
Åﬂ		BadDecl.init([["From", "", token.Pos, ""], ["To", "", token.Pos, ""]]);
		(go$ptrType(BadDecl)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["declNode", "go/ast", [], [], false]];
0	BadDecl00go/tokenPos0ÇÏGenDeclÇ
	GenDecl = go$pkg.GenDecl = go$newType(0, "Struct", "ast.GenDecl", "GenDecl", "go/ast", function(Doc_, TokPos_, Tok_, Lparen_, Specs_, Rparen_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.TokPos = TokPos_ !== undefined ? TokPos_ : 0;
		this.Tok = Tok_ !== undefined ? Tok_ : 0;
		this.Lparen = Lparen_ !== undefined ? Lparen_ : 0;
		this.Specs = Specs_ !== undefined ? Specs_ : (go$sliceType(Spec)).nil;
		this.Rparen = Rparen_ !== undefined ? Rparen_ : 0;
	});
Çx		GenDecl.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["TokPos", "", token.Pos, ""], ["Tok", "", token.Token, ""], ["Lparen", "", token.Pos, ""], ["Specs", "", (go$sliceType(Spec)), ""], ["Rparen", "", token.Pos, ""]]);
		(go$ptrType(GenDecl)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["declNode", "go/ast", [], [], false]];
0	GenDecl0L0go/astCommentGroup0go/astSpec0go/tokenPos0go/tokenToken0Ç!FuncDeclÇ	FuncDecl = go$pkg.FuncDecl = go$newType(0, "Struct", "ast.FuncDecl", "FuncDecl", "go/ast", function(Doc_, Recv_, Name_, Type_, Body_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Recv = Recv_ !== undefined ? Recv_ : (go$ptrType(FieldList)).nil;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Ident)).nil;
		this.Type = Type_ !== undefined ? Type_ : (go$ptrType(FuncType)).nil;
		this.Body = Body_ !== undefined ? Body_ : (go$ptrType(BlockStmt)).nil;
	});
Ç}		FuncDecl.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Recv", "", (go$ptrType(FieldList)), ""], ["Name", "", (go$ptrType(Ident)), ""], ["Type", "", (go$ptrType(FuncType)), ""], ["Body", "", (go$ptrType(BlockStmt)), ""]]);
		(go$ptrType(FuncDecl)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false], ["declNode", "go/ast", [], [], false]];
0
FuncDecl0x0go/astCommentGroup0go/ast	FieldList0go/astIdent0go/astFuncType0go/ast	BlockStmt0go/tokenPos0Ç FileÇD	File = go$pkg.File = go$newType(0, "Struct", "ast.File", "File", "go/ast", function(Doc_, Package_, Name_, Decls_, Scope_, Imports_, Unresolved_, Comments_) {
		this.go$val = this;
		this.Doc = Doc_ !== undefined ? Doc_ : (go$ptrType(CommentGroup)).nil;
		this.Package = Package_ !== undefined ? Package_ : 0;
		this.Name = Name_ !== undefined ? Name_ : (go$ptrType(Ident)).nil;
		this.Decls = Decls_ !== undefined ? Decls_ : (go$sliceType(Decl)).nil;
		this.Scope = Scope_ !== undefined ? Scope_ : (go$ptrType(Scope)).nil;
		this.Imports = Imports_ !== undefined ? Imports_ : (go$sliceType((go$ptrType(ImportSpec)))).nil;
		this.Unresolved = Unresolved_ !== undefined ? Unresolved_ : (go$sliceType((go$ptrType(Ident)))).nil;
		this.Comments = Comments_ !== undefined ? Comments_ : (go$sliceType((go$ptrType(CommentGroup)))).nil;
	});
Ç˝		File.init([["Doc", "", (go$ptrType(CommentGroup)), ""], ["Package", "", token.Pos, ""], ["Name", "", (go$ptrType(Ident)), ""], ["Decls", "", (go$sliceType(Decl)), ""], ["Scope", "", (go$ptrType(Scope)), ""], ["Imports", "", (go$sliceType((go$ptrType(ImportSpec)))), ""], ["Unresolved", "", (go$sliceType((go$ptrType(Ident)))), ""], ["Comments", "", (go$sliceType((go$ptrType(CommentGroup)))), ""]]);
		(go$ptrType(File)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false]];
0File0q0go/astCommentGroup0go/astIdent0go/astDecl0go/astScope0go/ast
ImportSpec0go/tokenPos0Ç4PackageÇâ	Package = go$pkg.Package = go$newType(0, "Struct", "ast.Package", "Package", "go/ast", function(Name_, Scope_, Imports_, Files_) {
		this.go$val = this;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Scope = Scope_ !== undefined ? Scope_ : (go$ptrType(Scope)).nil;
		this.Imports = Imports_ !== undefined ? Imports_ : false;
		this.Files = Files_ !== undefined ? Files_ : false;
	});
ÇI		Package.init([["Name", "", Go$String, ""], ["Scope", "", (go$ptrType(Scope)), ""], ["Imports", "", (go$mapType(Go$String, (go$ptrType(Object)))), ""], ["Files", "", (go$mapType(Go$String, (go$ptrType(File)))), ""]]);
		(go$ptrType(Package)).methods = [["End", "", [], [token.Pos], false], ["Pos", "", [], [token.Pos], false]];
0	Package0D0go/astScope0go/astObject0go/astFile0go/tokenPos0Ç‰byPosV	byPos = go$pkg.byPos = go$newType(0, "Slice", "ast.byPos", "byPos", "go/ast", null);
Ç^		byPos.init((go$ptrType(CommentGroup)));
		byPos.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
		(go$ptrType(byPos)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
0byPos00go/astCommentGroup0Çc
CommentMaph	CommentMap = go$pkg.CommentMap = go$newType(0, "Map", "ast.CommentMap", "CommentMap", "go/ast", null);
Ç±		CommentMap.init(Node, (go$sliceType((go$ptrType(CommentGroup)))));
		CommentMap.methods = [["Comments", "", [], [(go$sliceType((go$ptrType(CommentGroup))))], false], ["Filter", "", [Node], [CommentMap], false], ["String", "", [], [Go$String], false], ["Update", "", [Node, Node], [Node], false], ["addComment", "go/ast", [Node, (go$ptrType(CommentGroup))], [], false]];
		(go$ptrType(CommentMap)).methods = [["Comments", "", [], [(go$sliceType((go$ptrType(CommentGroup))))], false], ["Filter", "", [Node], [CommentMap], false], ["String", "", [], [Go$String], false], ["Update", "", [Node, Node], [Node], false], ["addComment", "go/ast", [Node, (go$ptrType(CommentGroup))], [], false]];
0
CommentMap0(0go/astNode0go/astCommentGroup0ÇÛ
byIntervalj	byInterval = go$pkg.byInterval = go$newType(0, "Slice", "ast.byInterval", "byInterval", "go/ast", null);
ÇW		byInterval.init(Node);
		byInterval.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
		(go$ptrType(byInterval)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
0
byInterval00go/astNode0Ç≤commentListReaderÇà	commentListReader = go$pkg.commentListReader = go$newType(0, "Struct", "ast.commentListReader", "commentListReader", "go/ast", function(fset_, list_, index_, comment_, pos_, end_) {
		this.go$val = this;
		this.fset = fset_ !== undefined ? fset_ : (go$ptrType(token.FileSet)).nil;
		this.list = list_ !== undefined ? list_ : (go$sliceType((go$ptrType(CommentGroup)))).nil;
		this.index = index_ !== undefined ? index_ : 0;
		this.comment = comment_ !== undefined ? comment_ : (go$ptrType(CommentGroup)).nil;
		this.pos = pos_ !== undefined ? pos_ : new token.Position.Ptr();
		this.end = end_ !== undefined ? end_ : new token.Position.Ptr();
	});
Çµ		commentListReader.init([["fset", "go/ast", (go$ptrType(token.FileSet)), ""], ["list", "go/ast", (go$sliceType((go$ptrType(CommentGroup)))), ""], ["index", "go/ast", Go$Int, ""], ["comment", "go/ast", (go$ptrType(CommentGroup)), ""], ["pos", "go/ast", token.Position, ""], ["end", "go/ast", token.Position, ""]]);
		(go$ptrType(commentListReader)).methods = [["eol", "go/ast", [], [Go$Bool], false], ["next", "go/ast", [], [], false]];
0commentListReader0C0go/tokenFileSet0go/astCommentGroup0go/tokenPosition0Ç:	nodeStackf	nodeStack = go$pkg.nodeStack = go$newType(0, "Slice", "ast.nodeStack", "nodeStack", "go/ast", null);
Åî		nodeStack.init(Node);
		(go$ptrType(nodeStack)).methods = [["pop", "go/ast", [token.Pos], [Node], false], ["push", "go/ast", [Node], [], false]];
0	nodeStack0!0go/astNode0go/tokenPos0ÅüFilterY	Filter = go$pkg.Filter = go$newType(0, "Func", "ast.Filter", "Filter", "go/ast", null);
.		Filter.init([Go$String], [Go$Bool], false);
0Filter0 0ÅÉ	MergeModee	MergeMode = go$pkg.MergeMode = go$newType(4, "Uint", "ast.MergeMode", "MergeMode", "go/ast", null);
 0	MergeMode0 0ÇbposSpanÅÍ	posSpan = go$pkg.posSpan = go$newType(0, "Struct", "ast.posSpan", "posSpan", "go/ast", function(Start_, End_) {
		this.go$val = this;
		this.Start = Start_ !== undefined ? Start_ : 0;
		this.End = End_ !== undefined ? End_ : 0;
	});
L		posSpan.init([["Start", "", token.Pos, ""], ["End", "", token.Pos, ""]]);
0	posSpan00go/tokenPos0ÇbyImportSpecr	byImportSpec = go$pkg.byImportSpec = go$newType(0, "Slice", "ast.byImportSpec", "byImportSpec", "go/ast", null);
Ç]		byImportSpec.init(Spec);
		byImportSpec.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
		(go$ptrType(byImportSpec)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
0byImportSpec00go/astSpec0Ç#byCommentPosr	byCommentPos = go$pkg.byCommentPos = go$newType(0, "Slice", "ast.byCommentPos", "byCommentPos", "go/ast", null);
Çs		byCommentPos.init((go$ptrType(CommentGroup)));
		byCommentPos.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
		(go$ptrType(byCommentPos)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
0byCommentPos00go/astCommentGroup0Å„FieldFilterm	FieldFilter = go$pkg.FieldFilter = go$newType(0, "Func", "ast.FieldFilter", "FieldFilter", "go/ast", null);
B		FieldFilter.init([Go$String, reflect.Value], [Go$Bool], false);
0FieldFilter00reflectValue0Ç‚printerÇS	printer = go$pkg.printer = go$newType(0, "Struct", "ast.printer", "printer", "go/ast", function(output_, fset_, filter_, ptrmap_, indent_, last_, line_) {
		this.go$val = this;
		this.output = output_ !== undefined ? output_ : null;
		this.fset = fset_ !== undefined ? fset_ : (go$ptrType(token.FileSet)).nil;
		this.filter = filter_ !== undefined ? filter_ : go$throwNilPointerError;
		this.ptrmap = ptrmap_ !== undefined ? ptrmap_ : false;
		this.indent = indent_ !== undefined ? indent_ : 0;
		this.last = last_ !== undefined ? last_ : 0;
		this.line = line_ !== undefined ? line_ : 0;
	});
Ç%		printer.init([["output", "go/ast", io.Writer, ""], ["fset", "go/ast", (go$ptrType(token.FileSet)), ""], ["filter", "go/ast", FieldFilter, ""], ["ptrmap", "go/ast", (go$mapType(go$emptyInterface, Go$Int)), ""], ["indent", "go/ast", Go$Int, ""], ["last", "go/ast", Go$Uint8, ""], ["line", "go/ast", Go$Int, ""]]);
		(go$ptrType(printer)).methods = [["Write", "", [(go$sliceType(Go$Uint8))], [Go$Int, go$error], false], ["print", "go/ast", [reflect.Value], [], false], ["printf", "go/ast", [Go$String, (go$sliceType(go$emptyInterface))], [], true]];
0	printer0L0go/tokenFileSet0ioWriter0go/astFieldFilter0reflectValue0Ç
localErrorÅø	localError = go$pkg.localError = go$newType(0, "Struct", "ast.localError", "localError", "go/ast", function(err_) {
		this.go$val = this;
		this.err = err_ !== undefined ? err_ : null;
	});
6		localError.init([["err", "go/ast", go$error, ""]]);
0
localError0 0ÇK
pkgBuilderÇ0	pkgBuilder = go$pkg.pkgBuilder = go$newType(0, "Struct", "ast.pkgBuilder", "pkgBuilder", "go/ast", function(fset_, errors_) {
		this.go$val = this;
		this.fset = fset_ !== undefined ? fset_ : (go$ptrType(token.FileSet)).nil;
		this.errors = errors_ !== undefined ? errors_ : scanner.ErrorList.nil;
	});
Çï		pkgBuilder.init([["fset", "go/ast", (go$ptrType(token.FileSet)), ""], ["errors", "go/ast", scanner.ErrorList, ""]]);
		(go$ptrType(pkgBuilder)).methods = [["declare", "go/ast", [(go$ptrType(Scope)), (go$ptrType(Scope)), (go$ptrType(Object))], [], false], ["error", "go/ast", [token.Pos, Go$String], [], false], ["errorf", "go/ast", [token.Pos, Go$String, (go$sliceType(go$emptyInterface))], [], true]];
0
pkgBuilder0b0go/tokenFileSet0
go/scanner	ErrorList0go/astScope0go/astObject0go/tokenPos0ÇImportera	Importer = go$pkg.Importer = go$newType(0, "Func", "ast.Importer", "Importer", "go/ast", null);
v		Importer.init([(go$mapType(Go$String, (go$ptrType(Object)))), Go$String], [(go$ptrType(Object)), go$error], false);
0
Importer00go/astObject0ÇÅScopeÇ	Scope = go$pkg.Scope = go$newType(0, "Struct", "ast.Scope", "Scope", "go/ast", function(Outer_, Objects_) {
		this.go$val = this;
		this.Outer = Outer_ !== undefined ? Outer_ : (go$ptrType(Scope)).nil;
		this.Objects = Objects_ !== undefined ? Objects_ : false;
	});
ÇI		Scope.init([["Outer", "", (go$ptrType(Scope)), ""], ["Objects", "", (go$mapType(Go$String, (go$ptrType(Object)))), ""]]);
		(go$ptrType(Scope)).methods = [["Insert", "", [(go$ptrType(Object))], [(go$ptrType(Object))], false], ["Lookup", "", [Go$String], [(go$ptrType(Object))], false], ["String", "", [], [Go$String], false]];
0Scope00go/astObject0Ç“ObjectÇí	Object = go$pkg.Object = go$newType(0, "Struct", "ast.Object", "Object", "go/ast", function(Kind_, Name_, Decl_, Data_, Type_) {
		this.go$val = this;
		this.Kind = Kind_ !== undefined ? Kind_ : 0;
		this.Name = Name_ !== undefined ? Name_ : "";
		this.Decl = Decl_ !== undefined ? Decl_ : null;
		this.Data = Data_ !== undefined ? Data_ : null;
		this.Type = Type_ !== undefined ? Type_ : null;
	});
Ç 		Object.init([["Kind", "", ObjKind, ""], ["Name", "", Go$String, ""], ["Decl", "", go$emptyInterface, ""], ["Data", "", go$emptyInterface, ""], ["Type", "", go$emptyInterface, ""]]);
		(go$ptrType(Object)).methods = [["Pos", "", [], [token.Pos], false]];
0Object0$0go/astObjKind0go/tokenPos0ÇObjKind\	ObjKind = go$pkg.ObjKind = go$newType(4, "Int", "ast.ObjKind", "ObjKind", "go/ast", null);
Åä		ObjKind.methods = [["String", "", [], [Go$String], false]];
		(go$ptrType(ObjKind)).methods = [["String", "", [], [Go$String], false]];
0	ObjKind0 0Å÷Visitorb	Visitor = go$pkg.Visitor = go$newType(0, "Interface", "ast.Visitor", "Visitor", "go/ast", null);
J		Visitor.init([["Visit", "", (go$funcType([Node], [Visitor], false))]]);
0	Visitor00go/astNode0Çc	inspectore	inspector = go$pkg.inspector = go$newType(0, "Func", "ast.inspector", "inspector", "go/ast", null);
Åº		inspector.init([Node], [Go$Bool], false);
		inspector.methods = [["Visit", "", [Node], [Visitor], false]];
		(go$ptrType(inspector)).methods = [["Visit", "", [Node], [Visitor], false]];
0	inspector0#0go/astNode0go/astVisitor0Åø Åò	Comment.Ptr.prototype.Pos = function() {
		var c;
		c = this;
		return c.Slash;
	};
	Comment.prototype.Pos = function() { return this.go$val.Pos(); };
 0	Comment00go/astComment0Å‰ ÅΩ	Comment.Ptr.prototype.End = function() {
		var c;
		c = this;
		return (((c.Slash >> 0) + c.Text.length >> 0) >> 0);
	};
	Comment.prototype.End = function() { return this.go$val.End(); };
 0	Comment00go/astComment0Ç} ÇK	CommentGroup.Ptr.prototype.Pos = function() {
		var g, _slice, _index;
		g = this;
		return (_slice = g.List, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos();
	};
	CommentGroup.prototype.Pos = function() { return this.go$val.Pos(); };
 0CommentGroup00go/astCommentGroup0Çî Çb	CommentGroup.Ptr.prototype.End = function() {
		var g, _slice, _index;
		g = this;
		return (_slice = g.List, _index = (g.List.length - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
	};
	CommentGroup.prototype.End = function() { return this.go$val.End(); };
 0CommentGroup00go/astCommentGroup0ÅâisWhitespacee	isWhitespace = function(ch) {
		return (ch === 32) || (ch === 9) || (ch === 10) || (ch === 13);
	};
 0isWhitespace0 0Ç
stripTrailingWhitespaceÅ∑	stripTrailingWhitespace = function(s) {
		var i;
		i = s.length;
		while (i > 0 && isWhitespace(s.charCodeAt((i - 1 >> 0)))) {
			i = i - 1 >> 0;
		}
		return s.substring(0, i);
	};
 0stripTrailingWhitespace00go/astisWhitespace0Ç Çõ	CommentGroup.Ptr.prototype.Text = function() {
		var g, comments, _ref, _i, _slice, _index, c, i, _slice$1, _index$1, lines, _ref$1, _i$1, _slice$2, _index$2, c$1, _ref$2, cl, _ref$3, _i$2, _slice$3, _index$3, l, n, _ref$4, _i$3, _slice$4, _index$4, line, _slice$5, _index$5, _slice$6, _index$6, _slice$7, _index$7;
		g = this;
		if (g === (go$ptrType(CommentGroup)).nil) {
			return "";
		}
		comments = (go$sliceType(Go$String)).make(g.List.length, 0, function() { return ""; });
		_ref = g.List;
		_i = 0;
		while (_i < _ref.length) {
			c = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			_slice$1 = comments, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = c.Text) : go$throwRuntimeError("index out of range");
			_i++;
		}
		lines = (go$sliceType(Go$String)).make(0, 10, function() { return ""; });
		_ref$1 = comments;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			c$1 = (_slice$2 = _ref$1, _index$2 = _i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			_ref$2 = c$1.charCodeAt(1);
			if (_ref$2 === 47) {
				c$1 = c$1.substring(2);
				if (c$1.length > 0 && (c$1.charCodeAt(0) === 32)) {
					c$1 = c$1.substring(1);
				}
			} else if (_ref$2 === 42) {
				c$1 = c$1.substring(2, (c$1.length - 2 >> 0));
			}
			cl = strings.Split(c$1, "\n");
			_ref$3 = cl;
			_i$2 = 0;
			while (_i$2 < _ref$3.length) {
				l = (_slice$3 = _ref$3, _index$3 = _i$2, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
				lines = go$append(lines, stripTrailingWhitespace(l));
				_i$2++;
			}
			_i$1++;
		}
		n = 0;
		_ref$4 = lines;
		_i$3 = 0;
		while (_i$3 < _ref$4.length) {
			line = (_slice$4 = _ref$4, _index$4 = _i$3, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"));
			if (!(line === "") || n > 0 && !((_slice$5 = lines, _index$5 = (n - 1 >> 0), (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")) === "")) {
				_slice$6 = lines, _index$6 = n, (_index$6 >= 0 && _index$6 < _slice$6.length) ? (_slice$6.array[_slice$6.offset + _index$6] = line) : go$throwRuntimeError("index out of range");
				n = n + 1 >> 0;
			}
			_i$3++;
		}
		lines = go$subslice(lines, 0, n);
		if (n > 0 && !((_slice$7 = lines, _index$7 = (n - 1 >> 0), (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")) === "")) {
			lines = go$append(lines, "");
		}
		return strings.Join(lines, "\n");
	};
	CommentGroup.prototype.Text = function() { return this.go$val.Text(); };
 0CommentGroup0^0go/astCommentGroup0stringsSplit0!go/aststripTrailingWhitespace0stringsJoin0Çö Çv	Field.Ptr.prototype.Pos = function() {
		var f, _slice, _index;
		f = this;
		if (f.Names.length > 0) {
			return (_slice = f.Names, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos();
		}
		return f.Type.Pos();
	};
	Field.prototype.Pos = function() { return this.go$val.Pos(); };
 0Field00go/astField0Ç ÅÂ	Field.Ptr.prototype.End = function() {
		var f;
		f = this;
		if (!(f.Tag === (go$ptrType(BasicLit)).nil)) {
			return f.Tag.End();
		}
		return f.Type.End();
	};
	Field.prototype.End = function() { return this.go$val.End(); };
 0Field0%0go/astField0go/astBasicLit0Çı Ç∏	FieldList.Ptr.prototype.Pos = function() {
		var f, _slice, _index;
		f = this;
		if ((new token.Pos(f.Opening)).IsValid()) {
			return f.Opening;
		}
		if (f.List.length > 0) {
			return (_slice = f.List, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos();
		}
		return 0;
	};
	FieldList.prototype.Pos = function() { return this.go$val.Pos(); };
 0	FieldList0&0go/ast	FieldList0go/tokenPos0Ç Ç÷	FieldList.Ptr.prototype.End = function() {
		var f, n, _slice, _index;
		f = this;
		if ((new token.Pos(f.Closing)).IsValid()) {
			return f.Closing + 1 >> 0;
		}
		if (n = f.List.length, n > 0) {
			return (_slice = f.List, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		return 0;
	};
	FieldList.prototype.End = function() { return this.go$val.End(); };
 0	FieldList0&0go/ast	FieldList0go/tokenPos0Çr ÇF	FieldList.Ptr.prototype.NumFields = function() {
		var f, n, _ref, _i, _slice, _index, g, m;
		f = this;
		n = 0;
		if (!(f === (go$ptrType(FieldList)).nil)) {
			_ref = f.List;
			_i = 0;
			while (_i < _ref.length) {
				g = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				m = g.Names.length;
				if (m === 0) {
					m = 1;
				}
				n = n + (m) >> 0;
				_i++;
			}
		}
		return n;
	};
	FieldList.prototype.NumFields = function() { return this.go$val.NumFields(); };
 0	FieldList00go/ast	FieldList0Åæ Åó	BadExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.From;
	};
	BadExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0	BadExpr00go/astBadExpr0Åπ Åñ	Ident.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.NamePos;
	};
	Ident.prototype.Pos = function() { return this.go$val.Pos(); };
 0Ident00go/astIdent0Å∆ Åù	Ellipsis.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Ellipsis;
	};
	Ellipsis.prototype.Pos = function() { return this.go$val.Pos(); };
 0
Ellipsis00go/astEllipsis0Å∆ Åù	BasicLit.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.ValuePos;
	};
	BasicLit.prototype.Pos = function() { return this.go$val.Pos(); };
 0
BasicLit00go/astBasicLit0Åƒ Åù	FuncLit.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Type.Pos();
	};
	FuncLit.prototype.Pos = function() { return this.go$val.Pos(); };
 0	FuncLit00go/astFuncLit0Ç ÅÌ	CompositeLit.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		if (!(go$interfaceIsEqual(x.Type, null))) {
			return x.Type.Pos();
		}
		return x.Lbrace;
	};
	CompositeLit.prototype.Pos = function() { return this.go$val.Pos(); };
 0CompositeLit00go/astCompositeLit0Å» Åù	ParenExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Lparen;
	};
	ParenExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0	ParenExpr00go/ast	ParenExpr0Å’ Å§	SelectorExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.X.Pos();
	};
	SelectorExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0SelectorExpr00go/astSelectorExpr0Å… Åû	IndexExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.X.Pos();
	};
	IndexExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0	IndexExpr00go/ast	IndexExpr0Å… Åû	SliceExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.X.Pos();
	};
	SliceExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0	SliceExpr00go/ast	SliceExpr0Å› Å®	TypeAssertExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.X.Pos();
	};
	TypeAssertExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0TypeAssertExpr00go/astTypeAssertExpr0Å« Åû	CallExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Fun.Pos();
	};
	CallExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0
CallExpr00go/astCallExpr0Å¬ Åô	StarExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Star;
	};
	StarExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0
StarExpr00go/astStarExpr0Å« Åú	UnaryExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.OpPos;
	};
	UnaryExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0	UnaryExpr00go/ast	UnaryExpr0ÅÕ Å†	BinaryExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.X.Pos();
	};
	BinaryExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0
BinaryExpr00go/ast
BinaryExpr0Å◊ Å¶	KeyValueExpr.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Key.Pos();
	};
	KeyValueExpr.prototype.Pos = function() { return this.go$val.Pos(); };
 0KeyValueExpr00go/astKeyValueExpr0Å» Åù	ArrayType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Lbrack;
	};
	ArrayType.prototype.Pos = function() { return this.go$val.Pos(); };
 0	ArrayType00go/ast	ArrayType0ÅÃ Åü	StructType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Struct;
	};
	StructType.prototype.Pos = function() { return this.go$val.Pos(); };
 0
StructType00go/ast
StructType0Ç^ Ç	FuncType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		if ((new token.Pos(x.Func)).IsValid() || x.Params === (go$ptrType(FieldList)).nil) {
			return x.Func;
		}
		return x.Params.Pos();
	};
	FuncType.prototype.Pos = function() { return this.go$val.Pos(); };
 0
FuncType0:0go/astFuncType0go/tokenPos0go/ast	FieldList0Å€ Å®	InterfaceType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Interface;
	};
	InterfaceType.prototype.Pos = function() { return this.go$val.Pos(); };
 0InterfaceType00go/astInterfaceType0ÅΩ Åñ	MapType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Map;
	};
	MapType.prototype.Pos = function() { return this.go$val.Pos(); };
 0	MapType00go/astMapType0Å√ Åö	ChanType.Ptr.prototype.Pos = function() {
		var x;
		x = this;
		return x.Begin;
	};
	ChanType.prototype.Pos = function() { return this.go$val.Pos(); };
 0
ChanType00go/astChanType0Åº Åï	BadExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.To;
	};
	BadExpr.prototype.End = function() { return this.go$val.End(); };
 0	BadExpr00go/astBadExpr0Åﬁ Åª	Ident.Ptr.prototype.End = function() {
		var x;
		x = this;
		return (((x.NamePos >> 0) + x.Name.length >> 0) >> 0);
	};
	Ident.prototype.End = function() { return this.go$val.End(); };
 0Ident00go/astIdent0Ç ÅÓ	Ellipsis.Ptr.prototype.End = function() {
		var x;
		x = this;
		if (!(go$interfaceIsEqual(x.Elt, null))) {
			return x.Elt.End();
		}
		return x.Ellipsis + 3 >> 0;
	};
	Ellipsis.prototype.End = function() { return this.go$val.End(); };
 0
Ellipsis00go/astEllipsis0ÅÏ Å√	BasicLit.Ptr.prototype.End = function() {
		var x;
		x = this;
		return (((x.ValuePos >> 0) + x.Value.length >> 0) >> 0);
	};
	BasicLit.prototype.End = function() { return this.go$val.End(); };
 0
BasicLit00go/astBasicLit0Åƒ Åù	FuncLit.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Body.End();
	};
	FuncLit.prototype.End = function() { return this.go$val.End(); };
 0	FuncLit00go/astFuncLit0Å› Å¨	CompositeLit.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rbrace + 1 >> 0;
	};
	CompositeLit.prototype.End = function() { return this.go$val.End(); };
 0CompositeLit00go/astCompositeLit0Å— Å¶	ParenExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rparen + 1 >> 0;
	};
	ParenExpr.prototype.End = function() { return this.go$val.End(); };
 0	ParenExpr00go/ast	ParenExpr0Å◊ Å¶	SelectorExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Sel.End();
	};
	SelectorExpr.prototype.End = function() { return this.go$val.End(); };
 0SelectorExpr00go/astSelectorExpr0Å— Å¶	IndexExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rbrack + 1 >> 0;
	};
	IndexExpr.prototype.End = function() { return this.go$val.End(); };
 0	IndexExpr00go/ast	IndexExpr0Å— Å¶	SliceExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rbrack + 1 >> 0;
	};
	SliceExpr.prototype.End = function() { return this.go$val.End(); };
 0	SliceExpr00go/ast	SliceExpr0ÅÂ Å∞	TypeAssertExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rparen + 1 >> 0;
	};
	TypeAssertExpr.prototype.End = function() { return this.go$val.End(); };
 0TypeAssertExpr00go/astTypeAssertExpr0ÅÕ Å§	CallExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Rparen + 1 >> 0;
	};
	CallExpr.prototype.End = function() { return this.go$val.End(); };
 0
CallExpr00go/astCallExpr0Å≈ Åú	StarExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.X.End();
	};
	StarExpr.prototype.End = function() { return this.go$val.End(); };
 0
StarExpr00go/astStarExpr0Å… Åû	UnaryExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.X.End();
	};
	UnaryExpr.prototype.End = function() { return this.go$val.End(); };
 0	UnaryExpr00go/ast	UnaryExpr0ÅÕ Å†	BinaryExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Y.End();
	};
	BinaryExpr.prototype.End = function() { return this.go$val.End(); };
 0
BinaryExpr00go/ast
BinaryExpr0ÅŸ Å®	KeyValueExpr.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Value.End();
	};
	KeyValueExpr.prototype.End = function() { return this.go$val.End(); };
 0KeyValueExpr00go/astKeyValueExpr0ÅÀ Å†	ArrayType.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Elt.End();
	};
	ArrayType.prototype.End = function() { return this.go$val.End(); };
 0	ArrayType00go/ast	ArrayType0Å“ Å•	StructType.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Fields.End();
	};
	StructType.prototype.End = function() { return this.go$val.End(); };
 0
StructType00go/ast
StructType0Ç4 Åˆ	FuncType.Ptr.prototype.End = function() {
		var x;
		x = this;
		if (!(x.Results === (go$ptrType(FieldList)).nil)) {
			return x.Results.End();
		}
		return x.Params.End();
	};
	FuncType.prototype.End = function() { return this.go$val.End(); };
 0
FuncType0)0go/astFuncType0go/ast	FieldList0Åﬂ Å¨	InterfaceType.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Methods.End();
	};
	InterfaceType.prototype.End = function() { return this.go$val.End(); };
 0InterfaceType00go/astInterfaceType0Å≈ Åû	MapType.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Value.End();
	};
	MapType.prototype.End = function() { return this.go$val.End(); };
 0	MapType00go/astMapType0Å… Å†	ChanType.Ptr.prototype.End = function() {
		var x;
		x = this;
		return x.Value.End();
	};
	ChanType.prototype.End = function() { return this.go$val.End(); };
 0
ChanType00go/astChanType0Å± ÅÄ	BadExpr.Ptr.prototype.exprNode = function() {
	};
	BadExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0BadExprexprNode00go/astBadExpr0Å® |	Ident.Ptr.prototype.exprNode = function() {
	};
	Ident.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0IdentexprNode00go/astIdent0Åµ ÅÇ	Ellipsis.Ptr.prototype.exprNode = function() {
	};
	Ellipsis.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0EllipsisexprNode00go/astEllipsis0Åµ ÅÇ	BasicLit.Ptr.prototype.exprNode = function() {
	};
	BasicLit.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0BasicLitexprNode00go/astBasicLit0Å± ÅÄ	FuncLit.Ptr.prototype.exprNode = function() {
	};
	FuncLit.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0FuncLitexprNode00go/astFuncLit0Å≈ Åä	CompositeLit.Ptr.prototype.exprNode = function() {
	};
	CompositeLit.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0CompositeLitexprNode00go/astCompositeLit0Åπ ÅÑ	ParenExpr.Ptr.prototype.exprNode = function() {
	};
	ParenExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0	ParenExprexprNode00go/ast	ParenExpr0Å≈ Åä	SelectorExpr.Ptr.prototype.exprNode = function() {
	};
	SelectorExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0SelectorExprexprNode00go/astSelectorExpr0Åπ ÅÑ	IndexExpr.Ptr.prototype.exprNode = function() {
	};
	IndexExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0	IndexExprexprNode00go/ast	IndexExpr0Åπ ÅÑ	SliceExpr.Ptr.prototype.exprNode = function() {
	};
	SliceExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0	SliceExprexprNode00go/ast	SliceExpr0ÅÕ Åé	TypeAssertExpr.Ptr.prototype.exprNode = function() {
	};
	TypeAssertExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0TypeAssertExprexprNode00go/astTypeAssertExpr0Åµ ÅÇ	CallExpr.Ptr.prototype.exprNode = function() {
	};
	CallExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0CallExprexprNode00go/astCallExpr0Åµ ÅÇ	StarExpr.Ptr.prototype.exprNode = function() {
	};
	StarExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0StarExprexprNode00go/astStarExpr0Åπ ÅÑ	UnaryExpr.Ptr.prototype.exprNode = function() {
	};
	UnaryExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0	UnaryExprexprNode00go/ast	UnaryExpr0ÅΩ ÅÜ	BinaryExpr.Ptr.prototype.exprNode = function() {
	};
	BinaryExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0
BinaryExprexprNode00go/ast
BinaryExpr0Å≈ Åä	KeyValueExpr.Ptr.prototype.exprNode = function() {
	};
	KeyValueExpr.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0KeyValueExprexprNode00go/astKeyValueExpr0Åπ ÅÑ	ArrayType.Ptr.prototype.exprNode = function() {
	};
	ArrayType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0	ArrayTypeexprNode00go/ast	ArrayType0ÅΩ ÅÜ	StructType.Ptr.prototype.exprNode = function() {
	};
	StructType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0
StructTypeexprNode00go/ast
StructType0Åµ ÅÇ	FuncType.Ptr.prototype.exprNode = function() {
	};
	FuncType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0FuncTypeexprNode00go/astFuncType0Å… Åå	InterfaceType.Ptr.prototype.exprNode = function() {
	};
	InterfaceType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0InterfaceTypeexprNode00go/astInterfaceType0Å± ÅÄ	MapType.Ptr.prototype.exprNode = function() {
	};
	MapType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0MapTypeexprNode00go/astMapType0Åµ ÅÇ	ChanType.Ptr.prototype.exprNode = function() {
	};
	ChanType.prototype.exprNode = function() { return this.go$val.exprNode(); };
 0ChanTypeexprNode00go/astChanType0Å≠NewIdentn	NewIdent = go$pkg.NewIdent = function(name) {
		return new Ident.Ptr(0, name, (go$ptrType(Object)).nil);
	};
 0
NewIdent0#0go/astObject0go/astIdent0Å˙
IsExportedÅ°	IsExported = go$pkg.IsExported = function(name) {
		var _tuple, ch;
		_tuple = utf8.DecodeRuneInString(name), ch = _tuple[0];
		return unicode.IsUpper(ch);
	};
 0
IsExported080"unicode/utf8DecodeRuneInString0unicodeIsUpper0Å Å∑	Ident.Ptr.prototype.IsExported = function() {
		var id;
		id = this;
		return IsExported(id.Name);
	};
	Ident.prototype.IsExported = function() { return this.go$val.IsExported(); };
 0Ident0'0go/astIdent0go/ast
IsExported0Ç Å·	Ident.Ptr.prototype.String = function() {
		var id;
		id = this;
		if (!(id === (go$ptrType(Ident)).nil)) {
			return id.Name;
		}
		return "<nil>";
	};
	Ident.prototype.String = function() { return this.go$val.String(); };
 0Ident00go/astIdent0Åæ Åó	BadStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.From;
	};
	BadStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	BadStmt00go/astBadStmt0Å» Åü	DeclStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Decl.Pos();
	};
	DeclStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
DeclStmt00go/astDeclStmt0ÅÀ Å†	EmptyStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Semicolon;
	};
	EmptyStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	EmptyStmt00go/ast	EmptyStmt0Å’ Å¶	LabeledStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Label.Pos();
	};
	LabeledStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0LabeledStmt00go/astLabeledStmt0Å≈ Åú	ExprStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.X.Pos();
	};
	ExprStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
ExprStmt00go/astExprStmt0Å» Åü	SendStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Chan.Pos();
	};
	SendStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
SendStmt00go/astSendStmt0ÅÕ Å†	IncDecStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.X.Pos();
	};
	IncDecStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
IncDecStmt00go/ast
IncDecStmt0Çt ÇF	AssignStmt.Ptr.prototype.Pos = function() {
		var s, _slice, _index;
		s = this;
		return (_slice = s.Lhs, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos();
	};
	AssignStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
AssignStmt00go/ast
AssignStmt0Å∏ Åì	GoStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Go;
	};
	GoStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0GoStmt00go/astGoStmt0Å« Åú	DeferStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Defer;
	};
	DeferStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	DeferStmt00go/ast	DeferStmt0ÅÃ Åü	ReturnStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Return;
	};
	ReturnStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
ReturnStmt00go/ast
ReturnStmt0ÅÃ Åü	BranchStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.TokPos;
	};
	BranchStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
BranchStmt00go/ast
BranchStmt0Å» Åù	BlockStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Lbrace;
	};
	BlockStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	BlockStmt00go/ast	BlockStmt0Å∏ Åì	IfStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.If;
	};
	IfStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0IfStmt00go/astIfStmt0Å  Åù	CaseClause.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Case;
	};
	CaseClause.prototype.Pos = function() { return this.go$val.Pos(); };
 0
CaseClause00go/ast
CaseClause0ÅÃ Åü	SwitchStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Switch;
	};
	SwitchStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
SwitchStmt00go/ast
SwitchStmt0Å‹ Åß	TypeSwitchStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Switch;
	};
	TypeSwitchStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0TypeSwitchStmt00go/astTypeSwitchStmt0Å  Åù	CommClause.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Case;
	};
	CommClause.prototype.Pos = function() { return this.go$val.Pos(); };
 0
CommClause00go/ast
CommClause0ÅÃ Åü	SelectStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Select;
	};
	SelectStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0
SelectStmt00go/ast
SelectStmt0ÅΩ Åñ	ForStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.For;
	};
	ForStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	ForStmt00go/astForStmt0Å≈ Åö	RangeStmt.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.For;
	};
	RangeStmt.prototype.Pos = function() { return this.go$val.Pos(); };
 0	RangeStmt00go/ast	RangeStmt0Åº Åï	BadStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.To;
	};
	BadStmt.prototype.End = function() { return this.go$val.End(); };
 0	BadStmt00go/astBadStmt0Å» Åü	DeclStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Decl.End();
	};
	DeclStmt.prototype.End = function() { return this.go$val.End(); };
 0
DeclStmt00go/astDeclStmt0Å‘ Å©	EmptyStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Semicolon + 1 >> 0;
	};
	EmptyStmt.prototype.End = function() { return this.go$val.End(); };
 0	EmptyStmt00go/ast	EmptyStmt0Å‘ Å•	LabeledStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Stmt.End();
	};
	LabeledStmt.prototype.End = function() { return this.go$val.End(); };
 0LabeledStmt00go/astLabeledStmt0Å≈ Åú	ExprStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.X.End();
	};
	ExprStmt.prototype.End = function() { return this.go$val.End(); };
 0
ExprStmt00go/astExprStmt0Å… Å†	SendStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Value.End();
	};
	SendStmt.prototype.End = function() { return this.go$val.End(); };
 0
SendStmt00go/astSendStmt0Å’ Å®	IncDecStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.TokPos + 2 >> 0;
	};
	IncDecStmt.prototype.End = function() { return this.go$val.End(); };
 0
IncDecStmt00go/ast
IncDecStmt0Çä Ç\	AssignStmt.Ptr.prototype.End = function() {
		var s, _slice, _index;
		s = this;
		return (_slice = s.Rhs, _index = (s.Rhs.length - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
	};
	AssignStmt.prototype.End = function() { return this.go$val.End(); };
 0
AssignStmt00go/ast
AssignStmt0Å¿ Åõ	GoStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Call.End();
	};
	GoStmt.prototype.End = function() { return this.go$val.End(); };
 0GoStmt00go/astGoStmt0ÅÃ Å°	DeferStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Call.End();
	};
	DeferStmt.prototype.End = function() { return this.go$val.End(); };
 0	DeferStmt00go/ast	DeferStmt0ÇÃ Çû	ReturnStmt.Ptr.prototype.End = function() {
		var s, n, _slice, _index;
		s = this;
		if (n = s.Results.length, n > 0) {
			return (_slice = s.Results, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		return s.Return + 6 >> 0;
	};
	ReturnStmt.prototype.End = function() { return this.go$val.End(); };
 0
ReturnStmt00go/ast
ReturnStmt0Ç~ Ç,	BranchStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		if (!(s.Label === (go$ptrType(Ident)).nil)) {
			return s.Label.End();
		}
		return (((s.TokPos >> 0) + (new token.Token(s.Tok)).String().length >> 0) >> 0);
	};
	BranchStmt.prototype.End = function() { return this.go$val.End(); };
 0
BranchStmt0:0go/ast
BranchStmt0go/astIdent0go/tokenToken0Å— Å¶	BlockStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Rbrace + 1 >> 0;
	};
	BlockStmt.prototype.End = function() { return this.go$val.End(); };
 0	BlockStmt00go/ast	BlockStmt0Ç
 ÅÂ	IfStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		if (!(go$interfaceIsEqual(s.Else, null))) {
			return s.Else.End();
		}
		return s.Body.End();
	};
	IfStmt.prototype.End = function() { return this.go$val.End(); };
 0IfStmt00go/astIfStmt0Ç≈ Çó	CaseClause.Ptr.prototype.End = function() {
		var s, n, _slice, _index;
		s = this;
		if (n = s.Body.length, n > 0) {
			return (_slice = s.Body, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		return s.Colon + 1 >> 0;
	};
	CaseClause.prototype.End = function() { return this.go$val.End(); };
 0
CaseClause00go/ast
CaseClause0Å– Å£	SwitchStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Body.End();
	};
	SwitchStmt.prototype.End = function() { return this.go$val.End(); };
 0
SwitchStmt00go/ast
SwitchStmt0Å‡ Å´	TypeSwitchStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Body.End();
	};
	TypeSwitchStmt.prototype.End = function() { return this.go$val.End(); };
 0TypeSwitchStmt00go/astTypeSwitchStmt0Ç≈ Çó	CommClause.Ptr.prototype.End = function() {
		var s, n, _slice, _index;
		s = this;
		if (n = s.Body.length, n > 0) {
			return (_slice = s.Body, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		return s.Colon + 1 >> 0;
	};
	CommClause.prototype.End = function() { return this.go$val.End(); };
 0
CommClause00go/ast
CommClause0Å– Å£	SelectStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Body.End();
	};
	SelectStmt.prototype.End = function() { return this.go$val.End(); };
 0
SelectStmt00go/ast
SelectStmt0Åƒ Åù	ForStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Body.End();
	};
	ForStmt.prototype.End = function() { return this.go$val.End(); };
 0	ForStmt00go/astForStmt0ÅÃ Å°	RangeStmt.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Body.End();
	};
	RangeStmt.prototype.End = function() { return this.go$val.End(); };
 0	RangeStmt00go/ast	RangeStmt0Å± ÅÄ	BadStmt.Ptr.prototype.stmtNode = function() {
	};
	BadStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0BadStmtstmtNode00go/astBadStmt0Åµ ÅÇ	DeclStmt.Ptr.prototype.stmtNode = function() {
	};
	DeclStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0DeclStmtstmtNode00go/astDeclStmt0Åπ ÅÑ	EmptyStmt.Ptr.prototype.stmtNode = function() {
	};
	EmptyStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0	EmptyStmtstmtNode00go/ast	EmptyStmt0Å¡ Åà	LabeledStmt.Ptr.prototype.stmtNode = function() {
	};
	LabeledStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0LabeledStmtstmtNode00go/astLabeledStmt0Åµ ÅÇ	ExprStmt.Ptr.prototype.stmtNode = function() {
	};
	ExprStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0ExprStmtstmtNode00go/astExprStmt0Åµ ÅÇ	SendStmt.Ptr.prototype.stmtNode = function() {
	};
	SendStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0SendStmtstmtNode00go/astSendStmt0ÅΩ ÅÜ	IncDecStmt.Ptr.prototype.stmtNode = function() {
	};
	IncDecStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
IncDecStmtstmtNode00go/ast
IncDecStmt0ÅΩ ÅÜ	AssignStmt.Ptr.prototype.stmtNode = function() {
	};
	AssignStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
AssignStmtstmtNode00go/ast
AssignStmt0Å¨ ~	GoStmt.Ptr.prototype.stmtNode = function() {
	};
	GoStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0GoStmtstmtNode00go/astGoStmt0Åπ ÅÑ	DeferStmt.Ptr.prototype.stmtNode = function() {
	};
	DeferStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0	DeferStmtstmtNode00go/ast	DeferStmt0ÅΩ ÅÜ	ReturnStmt.Ptr.prototype.stmtNode = function() {
	};
	ReturnStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
ReturnStmtstmtNode00go/ast
ReturnStmt0ÅΩ ÅÜ	BranchStmt.Ptr.prototype.stmtNode = function() {
	};
	BranchStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
BranchStmtstmtNode00go/ast
BranchStmt0Åπ ÅÑ	BlockStmt.Ptr.prototype.stmtNode = function() {
	};
	BlockStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0	BlockStmtstmtNode00go/ast	BlockStmt0Å¨ ~	IfStmt.Ptr.prototype.stmtNode = function() {
	};
	IfStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0IfStmtstmtNode00go/astIfStmt0ÅΩ ÅÜ	CaseClause.Ptr.prototype.stmtNode = function() {
	};
	CaseClause.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
CaseClausestmtNode00go/ast
CaseClause0ÅΩ ÅÜ	SwitchStmt.Ptr.prototype.stmtNode = function() {
	};
	SwitchStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
SwitchStmtstmtNode00go/ast
SwitchStmt0ÅÕ Åé	TypeSwitchStmt.Ptr.prototype.stmtNode = function() {
	};
	TypeSwitchStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0TypeSwitchStmtstmtNode00go/astTypeSwitchStmt0ÅΩ ÅÜ	CommClause.Ptr.prototype.stmtNode = function() {
	};
	CommClause.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
CommClausestmtNode00go/ast
CommClause0ÅΩ ÅÜ	SelectStmt.Ptr.prototype.stmtNode = function() {
	};
	SelectStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0
SelectStmtstmtNode00go/ast
SelectStmt0Å± ÅÄ	ForStmt.Ptr.prototype.stmtNode = function() {
	};
	ForStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0ForStmtstmtNode00go/astForStmt0Åπ ÅÑ	RangeStmt.Ptr.prototype.stmtNode = function() {
	};
	RangeStmt.prototype.stmtNode = function() { return this.go$val.stmtNode(); };
 0	RangeStmtstmtNode00go/ast	RangeStmt0Ç, ÅÓ	ImportSpec.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		if (!(s.Name === (go$ptrType(Ident)).nil)) {
			return s.Name.Pos();
		}
		return s.Path.Pos();
	};
	ImportSpec.prototype.Pos = function() { return this.go$val.Pos(); };
 0
ImportSpec0'0go/ast
ImportSpec0go/astIdent0Çr ÇF	ValueSpec.Ptr.prototype.Pos = function() {
		var s, _slice, _index;
		s = this;
		return (_slice = s.Names, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos();
	};
	ValueSpec.prototype.Pos = function() { return this.go$val.Pos(); };
 0	ValueSpec00go/ast	ValueSpec0Å» Åü	TypeSpec.Ptr.prototype.Pos = function() {
		var s;
		s = this;
		return s.Name.Pos();
	};
	TypeSpec.prototype.Pos = function() { return this.go$val.Pos(); };
 0
TypeSpec00go/astTypeSpec0Ç Åÿ	ImportSpec.Ptr.prototype.End = function() {
		var s;
		s = this;
		if (!((s.EndPos === 0))) {
			return s.EndPos;
		}
		return s.Path.End();
	};
	ImportSpec.prototype.End = function() { return this.go$val.End(); };
 0
ImportSpec00go/ast
ImportSpec0Ç‹ Ç∞	ValueSpec.Ptr.prototype.End = function() {
		var s, n, _slice, _index, _slice$1, _index$1;
		s = this;
		if (n = s.Values.length, n > 0) {
			return (_slice = s.Values, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		if (!(go$interfaceIsEqual(s.Type, null))) {
			return s.Type.End();
		}
		return (_slice$1 = s.Names, _index$1 = (s.Names.length - 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).End();
	};
	ValueSpec.prototype.End = function() { return this.go$val.End(); };
 0	ValueSpec00go/ast	ValueSpec0Å» Åü	TypeSpec.Ptr.prototype.End = function() {
		var s;
		s = this;
		return s.Type.End();
	};
	TypeSpec.prototype.End = function() { return this.go$val.End(); };
 0
TypeSpec00go/astTypeSpec0ÅΩ ÅÜ	ImportSpec.Ptr.prototype.specNode = function() {
	};
	ImportSpec.prototype.specNode = function() { return this.go$val.specNode(); };
 0
ImportSpecspecNode00go/ast
ImportSpec0Åπ ÅÑ	ValueSpec.Ptr.prototype.specNode = function() {
	};
	ValueSpec.prototype.specNode = function() { return this.go$val.specNode(); };
 0	ValueSpecspecNode00go/ast	ValueSpec0Åµ ÅÇ	TypeSpec.Ptr.prototype.specNode = function() {
	};
	TypeSpec.prototype.specNode = function() { return this.go$val.specNode(); };
 0TypeSpecspecNode00go/astTypeSpec0Åæ Åó	BadDecl.Ptr.prototype.Pos = function() {
		var d;
		d = this;
		return d.From;
	};
	BadDecl.prototype.Pos = function() { return this.go$val.Pos(); };
 0	BadDecl00go/astBadDecl0Å¿ Åô	GenDecl.Ptr.prototype.Pos = function() {
		var d;
		d = this;
		return d.TokPos;
	};
	GenDecl.prototype.Pos = function() { return this.go$val.Pos(); };
 0	GenDecl00go/astGenDecl0Å» Åü	FuncDecl.Ptr.prototype.Pos = function() {
		var d;
		d = this;
		return d.Type.Pos();
	};
	FuncDecl.prototype.Pos = function() { return this.go$val.Pos(); };
 0
FuncDecl00go/astFuncDecl0Åº Åï	BadDecl.Ptr.prototype.End = function() {
		var d;
		d = this;
		return d.To;
	};
	BadDecl.prototype.End = function() { return this.go$val.End(); };
 0	BadDecl00go/astBadDecl0Ç… Çê	GenDecl.Ptr.prototype.End = function() {
		var d, _slice, _index;
		d = this;
		if ((new token.Pos(d.Rparen)).IsValid()) {
			return d.Rparen + 1 >> 0;
		}
		return (_slice = d.Specs, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
	};
	GenDecl.prototype.End = function() { return this.go$val.End(); };
 0	GenDecl0$0go/astGenDecl0go/tokenPos0Ç, ÅÓ	FuncDecl.Ptr.prototype.End = function() {
		var d;
		d = this;
		if (!(d.Body === (go$ptrType(BlockStmt)).nil)) {
			return d.Body.End();
		}
		return d.Type.End();
	};
	FuncDecl.prototype.End = function() { return this.go$val.End(); };
 0
FuncDecl0)0go/astFuncDecl0go/ast	BlockStmt0Å± ÅÄ	BadDecl.Ptr.prototype.declNode = function() {
	};
	BadDecl.prototype.declNode = function() { return this.go$val.declNode(); };
 0BadDecldeclNode00go/astBadDecl0Å± ÅÄ	GenDecl.Ptr.prototype.declNode = function() {
	};
	GenDecl.prototype.declNode = function() { return this.go$val.declNode(); };
 0GenDecldeclNode00go/astGenDecl0Åµ ÅÇ	FuncDecl.Ptr.prototype.declNode = function() {
	};
	FuncDecl.prototype.declNode = function() { return this.go$val.declNode(); };
 0FuncDecldeclNode00go/astFuncDecl0Åµ Åî	File.Ptr.prototype.Pos = function() {
		var f;
		f = this;
		return f.Package;
	};
	File.prototype.Pos = function() { return this.go$val.Pos(); };
 0File00go/astFile0Ç´ Çâ	File.Ptr.prototype.End = function() {
		var f, n, _slice, _index;
		f = this;
		if (n = f.Decls.length, n > 0) {
			return (_slice = f.Decls, _index = (n - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End();
		}
		return f.Name.End();
	};
	File.prototype.End = function() { return this.go$val.End(); };
 0File00go/astFile0Åπ Åí	Package.Ptr.prototype.Pos = function() {
		var p;
		p = this;
		return 0;
	};
	Package.prototype.Pos = function() { return this.go$val.Pos(); };
 0	Package00go/astPackage0Åπ Åí	Package.Ptr.prototype.End = function() {
		var p;
		p = this;
		return 0;
	};
	Package.prototype.End = function() { return this.go$val.End(); };
 0	Package00go/astPackage0Å¬ Åü	byPos.prototype.Len = function() {
		var a;
		a = this;
		return a.length;
	};
	go$ptrType(byPos).prototype.Len = function() { return this.go$get().Len(); };
 0byPos00go/astbyPos0Ç7 Ç	byPos.prototype.Less = function(i, j) {
		var a, _slice, _index, _slice$1, _index$1;
		a = this;
		return (_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos() < (_slice$1 = a, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Pos();
	};
	go$ptrType(byPos).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0byPos00go/astbyPos0Çƒ Ç†	byPos.prototype.Swap = function(i, j) {
		var a, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		a = this;
		_tuple = [(_slice = a, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = a, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = a, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = a, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byPos).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0byPos00go/astbyPos0Ç,sortCommentsÅ÷	sortComments = function(list) {
		var orderedList;
		if (orderedList = go$subslice(new byPos(list.array), list.offset, list.offset + list.length), !sort.IsSorted(orderedList)) {
			sort.Sort(orderedList);
		}
	};
 0sortComments010sortIsSorted0go/astbyPos0sortSort0Ç◊ ÇÖ	CommentMap.prototype.addComment = function(n, c) {
		var cmap, _entry, list, _key;
		cmap = this.go$val;
		list = (_entry = cmap[(n || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : (go$sliceType((go$ptrType(CommentGroup)))).nil);
		if (list.length === 0) {
			list = new (go$sliceType((go$ptrType(CommentGroup))))([c]);
		} else {
			list = go$append(list, c);
		}
		_key = n, (cmap || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: list };
	};
	go$ptrType(CommentMap).prototype.addComment = function(n, c) { return new CommentMap(this.go$get()).addComment(n, c); };
 0
CommentMap
addComment0.0go/ast
CommentMap0go/astCommentGroup0Å÷ Å©	byInterval.prototype.Len = function() {
		var a;
		a = this;
		return a.length;
	};
	go$ptrType(byInterval).prototype.Len = function() { return this.go$get().Len(); };
 0
byInterval00go/ast
byInterval0Ç$ Çˆ	byInterval.prototype.Less = function(i, j) {
		var a, _slice, _index, _slice$1, _index$1, _tuple, pi, pj, _slice$2, _index$2, _slice$3, _index$3;
		a = this;
		_tuple = [(_slice = a, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos(), (_slice$1 = a, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Pos()], pi = _tuple[0], pj = _tuple[1];
		return pi < pj || (pi === pj) && (_slice$2 = a, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).End() > (_slice$3 = a, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")).End();
	};
	go$ptrType(byInterval).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0
byInterval00go/ast
byInterval0Çÿ Ç™	byInterval.prototype.Swap = function(i, j) {
		var a, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		a = this;
		_tuple = [(_slice = a, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = a, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = a, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = a, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byInterval).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0
byInterval00go/ast
byInterval0ÇÔnodeListÇÉ	nodeList = function(n) {
		var list;
		list = (go$sliceType(Node)).nil;
		Inspect(n, (function(n$1) {
			var _ref, _type;
			_ref = n$1;
			_type = _ref !== null ? _ref.constructor : null;
			if (_type === null || _type === (go$ptrType(CommentGroup)) || _type === (go$ptrType(Comment))) {
				return false;
			}
			list = go$append(list, n$1);
			return true;
		}));
		return list;
	};
 0
nodeList0N0go/astNode0go/astInspect0go/astCommentGroup0go/astComment0Å˝ ÅΩ	commentListReader.Ptr.prototype.eol = function() {
		var r;
		r = this;
		return r.index >= r.list.length;
	};
	commentListReader.prototype.eol = function() { return this.go$val.eol(); };
 0commentListReadereol00go/astcommentListReader0Ç: Ç”	commentListReader.Ptr.prototype.next = function() {
		var r, _slice, _index, _struct, _struct$1;
		r = this;
		if (!r.eol()) {
			r.comment = (_slice = r.list, _index = r.index, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			r.pos = (_struct = r.fset.Position(r.comment.Pos()), new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column));
			r.end = (_struct$1 = r.fset.Position(r.comment.End()), new token.Position.Ptr(_struct$1.Filename, _struct$1.Offset, _struct$1.Line, _struct$1.Column));
			r.index = r.index + 1 >> 0;
		}
	};
	commentListReader.prototype.next = function() { return this.go$val.next(); };
 0commentListReadernext0B0go/astcommentListReader0go/asteol0go/tokenPosition0ÇW Ç	go$ptrType(nodeStack).prototype.push = function(n) {
		var s;
		s = this;
		s.pop(n.Pos());
		s.go$set(go$append((s.go$get()), n));
	};
	nodeStack.prototype.push = function(n) { var obj = this; return (new (go$ptrType(nodeStack))(function() { return obj; }, null)).push(n); };
 0	nodeStackpush0$0go/ast	nodeStack0go/astpop0ÇV Ç%	go$ptrType(nodeStack).prototype.pop = function(pos) {
		var top, s, i, _slice, _index, _slice$1, _index$1;
		top = null;
		s = this;
		i = s.go$get().length;
		while (i > 0 && (_slice = (s.go$get()), _index = (i - 1 >> 0), (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).End() <= pos) {
			top = (_slice$1 = (s.go$get()), _index$1 = (i - 1 >> 0), (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
			i = i - 1 >> 0;
		}
		s.go$set(go$subslice((s.go$get()), 0, i));
		top = top;
		return top;
	};
	nodeStack.prototype.pop = function(pos) { var obj = this; return (new (go$ptrType(nodeStack))(function() { return obj; }, null)).pop(pos); };
 0	nodeStackpop00go/ast	nodeStack0ÇNewCommentMapÇä	NewCommentMap = go$pkg.NewCommentMap = function(fset, node, comments) {
		var cmap, tmp, r, nodes, p, pend, pg, pgend, stack, _ref, _i, _slice, _index, q, qpos, _struct, top, v, _struct$1, assoc, _struct$2, _ref$1, _type, v$1;
		if (comments.length === 0) {
			return false;
		}
		cmap = new Go$Map();
		tmp = (go$sliceType((go$ptrType(CommentGroup)))).make(comments.length, 0, function() { return (go$ptrType(CommentGroup)).nil; });
		go$copySlice(tmp, comments);
		sortComments(tmp);
		r = new commentListReader.Ptr(fset, tmp, 0, (go$ptrType(CommentGroup)).nil, new token.Position.Ptr(), new token.Position.Ptr());
		r.next();
		nodes = nodeList(node);
		nodes = go$append(nodes, null);
		p = null, pend = new token.Position.Ptr(), pg = null, pgend = new token.Position.Ptr(), stack = nodeStack.nil;
		_ref = nodes;
		_i = 0;
		while (_i < _ref.length) {
			q = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			qpos = new token.Position.Ptr();
			if (!(go$interfaceIsEqual(q, null))) {
				qpos = (_struct = fset.Position(q.Pos()), new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column));
			} else {
				qpos.Offset = 1073741824;
				qpos.Line = 1073741824;
			}
			while (r.end.Offset <= qpos.Offset) {
				if (top = (new (go$ptrType(nodeStack))(function() { return stack; }, function(v) { stack = v; })).pop(r.comment.Pos()), !(go$interfaceIsEqual(top, null))) {
					pg = top;
					pgend = (_struct$1 = fset.Position(pg.End()), new token.Position.Ptr(_struct$1.Filename, _struct$1.Offset, _struct$1.Line, _struct$1.Column));
				}
				assoc = null;
				if (!(go$interfaceIsEqual(pg, null)) && ((pgend.Line === r.pos.Line) || ((pgend.Line + 1 >> 0) === r.pos.Line) && (r.end.Line + 1 >> 0) < qpos.Line)) {
					assoc = pg;
				} else if (!(go$interfaceIsEqual(p, null)) && ((pend.Line === r.pos.Line) || ((pend.Line + 1 >> 0) === r.pos.Line) && (r.end.Line + 1 >> 0) < qpos.Line || go$interfaceIsEqual(q, null))) {
					assoc = p;
				} else {
					if (go$interfaceIsEqual(q, null)) {
						throw go$panic(new Go$String("internal error: no comments should be associated with sentinel"));
					}
					assoc = q;
				}
				(new CommentMap(cmap)).addComment(assoc, r.comment);
				if (r.eol()) {
					return cmap;
				}
				r.next();
			}
			p = q;
			pend = (_struct$2 = fset.Position(p.End()), new token.Position.Ptr(_struct$2.Filename, _struct$2.Offset, _struct$2.Line, _struct$2.Column));
			_ref$1 = q;
			_type = _ref$1 !== null ? _ref$1.constructor : null;
			if (_type === (go$ptrType(File)) || _type === (go$ptrType(Field)) || Decl.implementedBy.indexOf(_type) !== -1 || Spec.implementedBy.indexOf(_type) !== -1 || Stmt.implementedBy.indexOf(_type) !== -1) {
				(new (go$ptrType(nodeStack))(function() { return stack; }, function(v$1) { stack = v$1; })).push(q);
			}
			_i++;
		}
		return cmap;
	};
 0NewCommentMap0Ç\0go/astSpec0go/tokenPosition0go/astnodeList0go/astFile0go/astDecl0go/astCommentGroup0go/astsortComments0go/tokenFileSet0go/astpop0go/ast
addComment0go/ast
CommentMap0go/astField0go/astpush0go/astcommentListReader0go/astnext0go/ast	nodeStack0go/asteol0go/astStmt0ÇW Ç	CommentMap.prototype.Update = function(old, new$1) {
		var cmap, list, _entry, _entry$1, _key;
		cmap = this.go$val;
		if (list = (_entry = cmap[(old || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : (go$sliceType((go$ptrType(CommentGroup)))).nil), list.length > 0) {
			delete cmap[(old || go$interfaceNil).go$key()];
			_key = new$1, (cmap || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: go$appendSlice((_entry$1 = cmap[(new$1 || go$interfaceNil).go$key()], _entry$1 !== undefined ? _entry$1.v : (go$sliceType((go$ptrType(CommentGroup)))).nil), list) };
		}
		return new$1;
	};
	go$ptrType(CommentMap).prototype.Update = function(old, new$1) { return new CommentMap(this.go$get()).Update(old, new$1); };
 0
CommentMap0.0go/ast
CommentMap0go/astCommentGroup0Ç« Çn	CommentMap.prototype.Filter = function(node) {
		var cmap, umap;
		cmap = this.go$val;
		umap = new Go$Map();
		Inspect(node, (function(n) {
			var g, _entry, _key;
			if (g = (_entry = cmap[(n || go$interfaceNil).go$key()], _entry !== undefined ? _entry.v : (go$sliceType((go$ptrType(CommentGroup)))).nil), g.length > 0) {
				_key = n, (umap || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: g };
			}
			return true;
		}));
		return umap;
	};
	go$ptrType(CommentMap).prototype.Filter = function(node) { return new CommentMap(this.go$get()).Filter(node); };
 0
CommentMap0A0go/ast
CommentMap0go/astInspect0go/astCommentGroup0Çü ÇA	CommentMap.prototype.Comments = function() {
		var cmap, list, _ref, _i, _keys, _entry, e;
		cmap = this.go$val;
		list = (go$sliceType((go$ptrType(CommentGroup)))).make(0, go$keys(cmap).length, function() { return (go$ptrType(CommentGroup)).nil; });
		_ref = cmap;
		_i = 0;
		_keys = go$keys(_ref);
		while (_i < _keys.length) {
			_entry = _ref[_keys[_i]];
			e = _entry.v;
			list = go$appendSlice(list, e);
			_i++;
		}
		sortComments(list);
		return list;
	};
	go$ptrType(CommentMap).prototype.Comments = function() { return new CommentMap(this.go$get()).Comments(); };
 0
CommentMap0F0go/ast
CommentMap0go/astCommentGroup0go/astsortComments0ÇsummaryÇﬁ	summary = function(list) {
		var buf, _ref, _i, _slice, _index, group, _ref$1, _i$1, _slice$1, _index$1, comment, bytes$1, _ref$2, _i$2, _slice$2, _index$2, b, i, _ref$3, _slice$3, _index$3;
		buf = new bytes.Buffer.Ptr();
		_ref = list;
		_i = 0;
		loop:
		while (_i < _ref.length) {
			group = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_ref$1 = group.List;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				comment = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (buf.Len() >= 40) {
					break loop;
				}
				buf.WriteString(comment.Text);
				_i$1++;
			}
			_i++;
		}
		if (buf.Len() > 40) {
			buf.Truncate(37);
			buf.WriteString("...");
		}
		bytes$1 = buf.Bytes();
		_ref$2 = bytes$1;
		_i$2 = 0;
		while (_i$2 < _ref$2.length) {
			b = (_slice$2 = _ref$2, _index$2 = _i$2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
			i = _i$2;
			_ref$3 = b;
			if (_ref$3 === 9 || _ref$3 === 10 || _ref$3 === 13) {
				_slice$3 = bytes$1, _index$3 = i, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = 32) : go$throwRuntimeError("index out of range");
			}
			_i$2++;
		}
		return go$bytesToString(bytes$1);
	};
 0	summary00bytesBuffer0Ç” Ç?	CommentMap.prototype.String = function() {
		var cmap, buf, _ref, _i, _keys, _entry, comment, node, s, ok, _tuple, ident;
		cmap = this.go$val;
		buf = new bytes.Buffer.Ptr();
		fmt.Fprintln(buf, new (go$sliceType(go$emptyInterface))([new Go$String("CommentMap {")]));
		_ref = cmap;
		_i = 0;
		_keys = go$keys(_ref);
		while (_i < _keys.length) {
			_entry = _ref[_keys[_i]];
			comment = _entry.v;
			node = _entry.k;
			s = "";
			if (_tuple = (node !== null && node.constructor === (go$ptrType(Ident)) ? [node.go$val, true] : [(go$ptrType(Ident)).nil, false]), ident = _tuple[0], ok = _tuple[1], ok) {
				s = ident.Name;
			} else {
				s = fmt.Sprintf("%T", new (go$sliceType(go$emptyInterface))([node]));
			}
			fmt.Fprintf(buf, "\t%p  %20s:  %s\n", new (go$sliceType(go$emptyInterface))([node, new Go$String(s), new Go$String(summary(comment))]));
			_i++;
		}
		fmt.Fprintln(buf, new (go$sliceType(go$emptyInterface))([new Go$String("}")]));
		return buf.String();
	};
	go$ptrType(CommentMap).prototype.String = function() { return new CommentMap(this.go$get()).String(); };
 0
CommentMap0|0go/ast
CommentMap0bytesBuffer0fmtFprintln0go/astIdent0fmtSprintf0fmtFprintf0go/astsummary0zexportFilter@	exportFilter = function(name) {
		return IsExported(name);
	};
 0exportFilter00go/ast
IsExported0Å∂FileExportsf	FileExports = go$pkg.FileExports = function(src) {
		return filterFile(src, exportFilter, true);
	};
 0FileExports0.0go/ast
filterFile0go/astexportFilter0Å»PackageExportso	PackageExports = go$pkg.PackageExports = function(pkg) {
		return filterPackage(pkg, exportFilter, true);
	};
 0PackageExports010go/astfilterPackage0go/astexportFilter0ÇÄfilterIdentListÇT	filterIdentList = function(list, f) {
		var j, _ref, _i, _slice, _index, x, _slice$1, _index$1;
		j = 0;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (f(x.Name)) {
				_slice$1 = list, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = x) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			_i++;
		}
		return go$subslice(list, 0, j);
	};
 0filterIdentList0 0Çµ	fieldNameÇX	fieldName = function(x) {
		var t, _ref, _type, ok, _tuple, x$1;
		_ref = x;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(Ident))) {
			t = _ref.go$val;
			return t;
		} else if (_type === (go$ptrType(SelectorExpr))) {
			t = _ref.go$val;
			if (_tuple = (x$1 = t.X, (x$1 !== null && x$1.constructor === (go$ptrType(Ident)) ? [x$1.go$val, true] : [(go$ptrType(Ident)).nil, false])), ok = _tuple[1], ok) {
				return t.Sel;
			}
		} else if (_type === (go$ptrType(StarExpr))) {
			t = _ref.go$val;
			return fieldName(t.X);
		}
		return (go$ptrType(Ident)).nil;
	};
 0	fieldName0=0go/astIdent0go/astSelectorExpr0go/astStarExpr0ÇØfilterFieldListÇ	filterFieldList = function(fields, filter, export$1) {
		var removedFields, list, j, _ref, _i, _slice, _index, f, keepField, name, n, _slice$1, _index$1;
		removedFields = false;
		if (fields === (go$ptrType(FieldList)).nil) {
			removedFields = false;
			return removedFields;
		}
		list = fields.List;
		j = 0;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			f = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			keepField = false;
			if (f.Names.length === 0) {
				name = fieldName(f.Type);
				keepField = !(name === (go$ptrType(Ident)).nil) && filter(name.Name);
			} else {
				n = f.Names.length;
				f.Names = filterIdentList(f.Names, filter);
				if (f.Names.length < n) {
					removedFields = true;
				}
				keepField = f.Names.length > 0;
			}
			if (keepField) {
				if (export$1) {
					filterType(f.Type, filter, export$1);
				}
				_slice$1 = list, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = f) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			_i++;
		}
		if (j < list.length) {
			removedFields = true;
		}
		fields.List = go$subslice(list, 0, j);
		return removedFields;
	};
 0filterFieldList0l0go/ast	FieldList0go/ast	fieldName0go/astIdent0go/astfilterIdentList0go/ast
filterType0ÇEfilterParamListÇÓ	filterParamList = function(fields, filter, export$1) {
		var b, _ref, _i, _slice, _index, f;
		if (fields === (go$ptrType(FieldList)).nil) {
			return false;
		}
		b = false;
		_ref = fields.List;
		_i = 0;
		while (_i < _ref.length) {
			f = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (filterType(f.Type, filter, export$1)) {
				b = true;
			}
			_i++;
		}
		return b;
	};
 0filterParamList0+0go/ast	FieldList0go/ast
filterType0Ç0
filterTypeÇ2	filterType = function(typ, f, export$1) {
		var t, _ref, _type, b1, b2, b1$1, b2$1;
		_ref = typ;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(Ident))) {
			t = _ref.go$val;
			return f(t.Name);
		} else if (_type === (go$ptrType(ParenExpr))) {
			t = _ref.go$val;
			return filterType(t.X, f, export$1);
		} else if (_type === (go$ptrType(ArrayType))) {
			t = _ref.go$val;
			return filterType(t.Elt, f, export$1);
		} else if (_type === (go$ptrType(StructType))) {
			t = _ref.go$val;
			if (filterFieldList(t.Fields, f, export$1)) {
				t.Incomplete = true;
			}
			return t.Fields.List.length > 0;
		} else if (_type === (go$ptrType(FuncType))) {
			t = _ref.go$val;
			b1 = filterParamList(t.Params, f, export$1);
			b2 = filterParamList(t.Results, f, export$1);
			return b1 || b2;
		} else if (_type === (go$ptrType(InterfaceType))) {
			t = _ref.go$val;
			if (filterFieldList(t.Methods, f, export$1)) {
				t.Incomplete = true;
			}
			return t.Methods.List.length > 0;
		} else if (_type === (go$ptrType(MapType))) {
			t = _ref.go$val;
			b1$1 = filterType(t.Key, f, export$1);
			b2$1 = filterType(t.Value, f, export$1);
			return b1$1 || b2$1;
		} else if (_type === (go$ptrType(ChanType))) {
			t = _ref.go$val;
			return filterType(t.Value, f, export$1);
		}
		return false;
	};
 0
filterType0Å€0go/astIdent0go/ast	ParenExpr0go/ast
StructType0go/astFuncType0go/astMapType0go/astChanType0go/ast	ArrayType0go/astInterfaceType0go/astfilterFieldList0go/astfilterParamList0ÇÌ
filterSpecÇq	filterSpec = function(spec, f, export$1) {
		var s, _ref, _type;
		_ref = spec;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(ValueSpec))) {
			s = _ref.go$val;
			s.Names = filterIdentList(s.Names, f);
			if (s.Names.length > 0) {
				if (export$1) {
					filterType(s.Type, f, export$1);
				}
				return true;
			}
		} else if (_type === (go$ptrType(TypeSpec))) {
			s = _ref.go$val;
			if (f(s.Name.Name)) {
				if (export$1) {
					filterType(s.Type, f, export$1);
				}
				return true;
			}
			if (!export$1) {
				return filterType(s.Type, f, export$1);
			}
		}
		return false;
	};
 0
filterSpec0Z0go/ast	ValueSpec0go/astTypeSpec0go/astfilterIdentList0go/ast
filterType0ÇÆfilterSpecListÇn	filterSpecList = function(list, f, export$1) {
		var j, _ref, _i, _slice, _index, s, _slice$1, _index$1;
		j = 0;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (filterSpec(s, f, export$1)) {
				_slice$1 = list, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = s) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			_i++;
		}
		return go$subslice(list, 0, j);
	};
 0filterSpecList00go/ast
filterSpec0Åï
FilterDecl_	FilterDecl = go$pkg.FilterDecl = function(decl, f) {
		return filterDecl(decl, f, false);
	};
 0
FilterDecl00go/ast
filterDecl0ÇÏ
filterDeclÇâ	filterDecl = function(decl, f, export$1) {
		var d, _ref, _type;
		_ref = decl;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(GenDecl))) {
			d = _ref.go$val;
			d.Specs = filterSpecList(d.Specs, f, export$1);
			return d.Specs.length > 0;
		} else if (_type === (go$ptrType(FuncDecl))) {
			d = _ref.go$val;
			return f(d.Name.Name);
		}
		return false;
	};
 0
filterDecl0A0go/astGenDecl0go/astFuncDecl0go/astfilterSpecList0Åì
FilterFile]	FilterFile = go$pkg.FilterFile = function(src, f) {
		return filterFile(src, f, false);
	};
 0
FilterFile00go/ast
filterFile0Ç≈
filterFileÇç	filterFile = function(src, f, export$1) {
		var j, _ref, _i, _slice, _index, d, _slice$1, _index$1;
		j = 0;
		_ref = src.Decls;
		_i = 0;
		while (_i < _ref.length) {
			d = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (filterDecl(d, f, export$1)) {
				_slice$1 = src.Decls, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = d) : go$throwRuntimeError("index out of range");
				j = j + 1 >> 0;
			}
			_i++;
		}
		src.Decls = go$subslice(src.Decls, 0, j);
		return j > 0;
	};
 0
filterFile00go/ast
filterDecl0Å•FilterPackagef	FilterPackage = go$pkg.FilterPackage = function(pkg, f) {
		return filterPackage(pkg, f, false);
	};
 0FilterPackage00go/astfilterPackage0ÇòfilterPackageÇZ	filterPackage = function(pkg, f, export$1) {
		var hasDecls, _ref, _i, _keys, _entry, src;
		hasDecls = false;
		_ref = pkg.Files;
		_i = 0;
		_keys = go$keys(_ref);
		while (_i < _keys.length) {
			_entry = _ref[_keys[_i]];
			src = _entry.v;
			if (filterFile(src, f, export$1)) {
				hasDecls = true;
			}
			_i++;
		}
		return hasDecls;
	};
 0filterPackage00go/ast
filterFile0ÇlnameOfÇ	nameOf = function(f) {
		var r, _slice, _index, t, p, _tuple, p$1, _tuple$1;
		if (r = f.Recv, !(r === (go$ptrType(FieldList)).nil) && (r.List.length === 1)) {
			t = (_slice = r.List, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Type;
			if (_tuple = (t !== null && t.constructor === (go$ptrType(StarExpr)) ? [t.go$val, true] : [(go$ptrType(StarExpr)).nil, false]), p = _tuple[0], !(p === (go$ptrType(StarExpr)).nil)) {
				t = p.X;
			}
			if (_tuple$1 = (t !== null && t.constructor === (go$ptrType(Ident)) ? [t.go$val, true] : [(go$ptrType(Ident)).nil, false]), p$1 = _tuple$1[0], !(p$1 === (go$ptrType(Ident)).nil)) {
				return p$1.Name + "." + f.Name.Name;
			}
		}
		return f.Name.Name;
	};
 0nameOf0:0go/ast	FieldList0go/astStarExpr0go/astIdent0Ç ÂMergePackageFilesÇ‚	MergePackageFiles = go$pkg.MergePackageFiles = function(pkg, mode) {
		var ndocs, ncomments, ndecls, filenames, i, _ref, _i, _keys, _entry, f, filename, _slice, _index, doc, pos, list, i$1, _ref$1, _i$1, _slice$1, _index$1, filename$1, _entry$1, f$1, _slice$2, _index$2, _ref$2, _i$2, _slice$3, _index$3, c, _slice$4, _index$4, decls, funcs, i$2, n, _ref$3, _i$3, _slice$5, _index$5, filename$2, _entry$2, f$2, _ref$4, _i$4, _slice$6, _index$6, d, isFun, _tuple, f$3, name, exists, _tuple$1, _entry$3, j, _slice$7, _index$7, x, _slice$8, _index$8, _slice$9, _index$9, _key, _slice$10, _index$10, _ref$5, _i$5, _slice$11, _index$11, d$1, _slice$12, _index$12, imports, seen, _ref$6, _i$6, _slice$13, _index$13, filename$3, _entry$4, f$4, _ref$7, _i$7, _slice$14, _index$14, imp, path, _entry$5, _key$1, _ref$8, _i$8, _keys$1, _entry$6, f$5, comments, i$3, _ref$9, _i$9, _keys$2, _entry$7, f$6;
		ndocs = 0;
		ncomments = 0;
		ndecls = 0;
		filenames = (go$sliceType(Go$String)).make(go$keys(pkg.Files).length, 0, function() { return ""; });
		i = 0;
		_ref = pkg.Files;
		_i = 0;
		_keys = go$keys(_ref);
		while (_i < _keys.length) {
			_entry = _ref[_keys[_i]];
			f = _entry.v;
			filename = _entry.k;
			_slice = filenames, _index = i, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = filename) : go$throwRuntimeError("index out of range");
			i = i + 1 >> 0;
			if (!(f.Doc === (go$ptrType(CommentGroup)).nil)) {
				ndocs = ndocs + ((f.Doc.List.length + 1 >> 0)) >> 0;
			}
			ncomments = ncomments + (f.Comments.length) >> 0;
			ndecls = ndecls + (f.Decls.length) >> 0;
			_i++;
		}
		sort.Strings(filenames);
		doc = (go$ptrType(CommentGroup)).nil;
		pos = 0;
		if (ndocs > 0) {
			list = (go$sliceType((go$ptrType(Comment)))).make(ndocs - 1 >> 0, 0, function() { return (go$ptrType(Comment)).nil; });
			i$1 = 0;
			_ref$1 = filenames;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				filename$1 = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				f$1 = (_entry$1 = pkg.Files[filename$1], _entry$1 !== undefined ? _entry$1.v : (go$ptrType(File)).nil);
				if (!(f$1.Doc === (go$ptrType(CommentGroup)).nil)) {
					if (i$1 > 0) {
						_slice$2 = list, _index$2 = i$1, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = separator) : go$throwRuntimeError("index out of range");
						i$1 = i$1 + 1 >> 0;
					}
					_ref$2 = f$1.Doc.List;
					_i$2 = 0;
					while (_i$2 < _ref$2.length) {
						c = (_slice$3 = _ref$2, _index$3 = _i$2, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
						_slice$4 = list, _index$4 = i$1, (_index$4 >= 0 && _index$4 < _slice$4.length) ? (_slice$4.array[_slice$4.offset + _index$4] = c) : go$throwRuntimeError("index out of range");
						i$1 = i$1 + 1 >> 0;
						_i$2++;
					}
					if (f$1.Package > pos) {
						pos = f$1.Package;
					}
				}
				_i$1++;
			}
			doc = new CommentGroup.Ptr(list);
		}
		decls = (go$sliceType(Decl)).nil;
		if (ndecls > 0) {
			decls = (go$sliceType(Decl)).make(ndecls, 0, function() { return null; });
			funcs = new Go$Map();
			i$2 = 0;
			n = 0;
			_ref$3 = filenames;
			_i$3 = 0;
			while (_i$3 < _ref$3.length) {
				filename$2 = (_slice$5 = _ref$3, _index$5 = _i$3, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
				f$2 = (_entry$2 = pkg.Files[filename$2], _entry$2 !== undefined ? _entry$2.v : (go$ptrType(File)).nil);
				_ref$4 = f$2.Decls;
				_i$4 = 0;
				while (_i$4 < _ref$4.length) {
					d = (_slice$6 = _ref$4, _index$6 = _i$4, (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range"));
					if (!((((mode & 1) >>> 0) === 0))) {
						if (_tuple = (d !== null && d.constructor === (go$ptrType(FuncDecl)) ? [d.go$val, true] : [(go$ptrType(FuncDecl)).nil, false]), f$3 = _tuple[0], isFun = _tuple[1], isFun) {
							name = nameOf(f$3);
							if (_tuple$1 = (_entry$3 = funcs[name], _entry$3 !== undefined ? [_entry$3.v, true] : [0, false]), j = _tuple$1[0], exists = _tuple$1[1], exists) {
								if (!(go$interfaceIsEqual((_slice$7 = decls, _index$7 = j, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")), null)) && (x = (_slice$8 = decls, _index$8 = j, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range")), (x !== null && x.constructor === (go$ptrType(FuncDecl)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(FuncDecl))))).Doc === (go$ptrType(CommentGroup)).nil) {
									_slice$9 = decls, _index$9 = j, (_index$9 >= 0 && _index$9 < _slice$9.length) ? (_slice$9.array[_slice$9.offset + _index$9] = null) : go$throwRuntimeError("index out of range");
								} else {
									d = null;
								}
								n = n + 1 >> 0;
							} else {
								_key = name, (funcs || go$throwRuntimeError("assignment to entry in nil map"))[_key] = { k: _key, v: i$2 };
							}
						}
					}
					_slice$10 = decls, _index$10 = i$2, (_index$10 >= 0 && _index$10 < _slice$10.length) ? (_slice$10.array[_slice$10.offset + _index$10] = d) : go$throwRuntimeError("index out of range");
					i$2 = i$2 + 1 >> 0;
					_i$4++;
				}
				_i$3++;
			}
			if (n > 0) {
				i$2 = 0;
				_ref$5 = decls;
				_i$5 = 0;
				while (_i$5 < _ref$5.length) {
					d$1 = (_slice$11 = _ref$5, _index$11 = _i$5, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range"));
					if (!(go$interfaceIsEqual(d$1, null))) {
						_slice$12 = decls, _index$12 = i$2, (_index$12 >= 0 && _index$12 < _slice$12.length) ? (_slice$12.array[_slice$12.offset + _index$12] = d$1) : go$throwRuntimeError("index out of range");
						i$2 = i$2 + 1 >> 0;
					}
					_i$5++;
				}
				decls = go$subslice(decls, 0, i$2);
			}
		}
		imports = (go$sliceType((go$ptrType(ImportSpec)))).nil;
		if (!((((mode & 4) >>> 0) === 0))) {
			seen = new Go$Map();
			_ref$6 = filenames;
			_i$6 = 0;
			while (_i$6 < _ref$6.length) {
				filename$3 = (_slice$13 = _ref$6, _index$13 = _i$6, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range"));
				f$4 = (_entry$4 = pkg.Files[filename$3], _entry$4 !== undefined ? _entry$4.v : (go$ptrType(File)).nil);
				_ref$7 = f$4.Imports;
				_i$7 = 0;
				while (_i$7 < _ref$7.length) {
					imp = (_slice$14 = _ref$7, _index$14 = _i$7, (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range"));
					if (path = imp.Path.Value, !(_entry$5 = seen[path], _entry$5 !== undefined ? _entry$5.v : false)) {
						imports = go$append(imports, imp);
						_key$1 = path, (seen || go$throwRuntimeError("assignment to entry in nil map"))[_key$1] = { k: _key$1, v: true };
					}
					_i$7++;
				}
				_i$6++;
			}
		} else {
			_ref$8 = pkg.Files;
			_i$8 = 0;
			_keys$1 = go$keys(_ref$8);
			while (_i$8 < _keys$1.length) {
				_entry$6 = _ref$8[_keys$1[_i$8]];
				f$5 = _entry$6.v;
				imports = go$appendSlice(imports, f$5.Imports);
				_i$8++;
			}
		}
		comments = (go$sliceType((go$ptrType(CommentGroup)))).nil;
		if (((mode & 2) >>> 0) === 0) {
			comments = (go$sliceType((go$ptrType(CommentGroup)))).make(ncomments, 0, function() { return (go$ptrType(CommentGroup)).nil; });
			i$3 = 0;
			_ref$9 = pkg.Files;
			_i$9 = 0;
			_keys$2 = go$keys(_ref$9);
			while (_i$9 < _keys$2.length) {
				_entry$7 = _ref$9[_keys$2[_i$9]];
				f$6 = _entry$7.v;
				i$3 = i$3 + (go$copySlice(go$subslice(comments, i$3), f$6.Comments)) >> 0;
				_i$9++;
			}
		}
		return new File.Ptr(doc, pos, NewIdent(pkg.Name), decls, pkg.Scope, imports, (go$sliceType((go$ptrType(Ident)))).nil, comments);
	};
 0MergePackageFiles0Å“0sortStrings0go/ast	separator0go/astnameOf0go/astIdent0go/astCommentGroup0go/astComment0go/astFile0go/astDecl0go/astFuncDecl0go/ast
ImportSpec0go/astNewIdent0ÇGSortImportsÇÍ	SortImports = go$pkg.SortImports = function(fset, f) {
		var _ref, _i, _slice, _index, d, _tuple, d$1, ok, i, specs, _ref$1, _i$1, _slice$1, _index$1, s, j, _slice$2, _index$2, _slice$3, _index$3, lastSpec, lastLine, rParenLine;
		_ref = f.Decls;
		_i = 0;
		while (_i < _ref.length) {
			d = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_tuple = (d !== null && d.constructor === (go$ptrType(GenDecl)) ? [d.go$val, true] : [(go$ptrType(GenDecl)).nil, false]), d$1 = _tuple[0], ok = _tuple[1];
			if (!ok || !((d$1.Tok === 75))) {
				break;
			}
			if (!(new token.Pos(d$1.Lparen)).IsValid()) {
				_i++;
				continue;
			}
			i = 0;
			specs = go$subslice(d$1.Specs, 0, 0);
			_ref$1 = d$1.Specs;
			_i$1 = 0;
			while (_i$1 < _ref$1.length) {
				s = (_slice$1 = _ref$1, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				j = _i$1;
				if (j > i && fset.Position(s.Pos()).Line > (1 + fset.Position((_slice$2 = d$1.Specs, _index$2 = (j - 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).End()).Line >> 0)) {
					specs = go$appendSlice(specs, sortSpecs(fset, f, go$subslice(d$1.Specs, i, j)));
					i = j;
				}
				_i$1++;
			}
			specs = go$appendSlice(specs, sortSpecs(fset, f, go$subslice(d$1.Specs, i)));
			d$1.Specs = specs;
			if (d$1.Specs.length > 0) {
				lastSpec = (_slice$3 = d$1.Specs, _index$3 = (d$1.Specs.length - 1 >> 0), (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
				lastLine = fset.Position(lastSpec.Pos()).Line;
				if (rParenLine = fset.Position(d$1.Rparen).Line, rParenLine > (lastLine + 1 >> 0)) {
					fset.File(d$1.Rparen).MergeLine(rParenLine - 1 >> 0);
				}
			}
			_i++;
		}
	};
 0SortImports090go/astGenDecl0go/tokenPos0go/ast	sortSpecs0Çå
importPathÇ@	importPath = function(s) {
		var _tuple, t, err;
		_tuple = strconv.Unquote((s !== null && s.constructor === (go$ptrType(ImportSpec)) ? s.go$val : go$typeAssertionFailed(s, (go$ptrType(ImportSpec)))).Path.Value), t = _tuple[0], err = _tuple[1];
		if (go$interfaceIsEqual(err, null)) {
			return t;
		}
		return "";
	};
 0
importPath0*0strconvUnquote0go/ast
ImportSpec0ÇC
importNameÅ˚	importName = function(s) {
		var n;
		n = (s !== null && s.constructor === (go$ptrType(ImportSpec)) ? s.go$val : go$typeAssertionFailed(s, (go$ptrType(ImportSpec)))).Name;
		if (n === (go$ptrType(Ident)).nil) {
			return "";
		}
		return n.Name;
	};
 0
importName0'0go/ast
ImportSpec0go/astIdent0Ç`importCommentÇ
	importComment = function(s) {
		var c;
		c = (s !== null && s.constructor === (go$ptrType(ImportSpec)) ? s.go$val : go$typeAssertionFailed(s, (go$ptrType(ImportSpec)))).Comment;
		if (c === (go$ptrType(CommentGroup)).nil) {
			return "";
		}
		return c.Text();
	};
 0importComment0.0go/ast
ImportSpec0go/astCommentGroup0ÇœcollapseÇW	collapse = function(prev, next) {
		if (!(importPath(next) === importPath(prev)) || !(importName(next) === importName(prev))) {
			return false;
		}
		return (prev !== null && prev.constructor === (go$ptrType(ImportSpec)) ? prev.go$val : go$typeAssertionFailed(prev, (go$ptrType(ImportSpec)))).Comment === (go$ptrType(CommentGroup)).nil;
	};
 0
collapse0Z0go/ast
importPath0go/ast
importName0go/ast
ImportSpec0go/astCommentGroup0Ç†	sortSpecsÇ€	sortSpecs = function(fset, f, specs) {
		var pos, _ref, _i, _slice, _index, s, i, _slice$1, _index$1, _slice$2, _index$2, lastLine, cstart, cend, _ref$1, _i$1, _slice$3, _index$3, g, i$1, _slice$4, _index$4, comments, _map, _key, importComment$1, specIndex, _ref$2, _i$2, _slice$5, _index$5, g$1, _slice$6, _index$6, x, _slice$7, _index$7, s$1, _entry, _key$1, deduped, _ref$3, _i$3, _slice$8, _index$8, s$2, i$2, _slice$9, _index$9, p, _ref$4, _i$4, _slice$10, _index$10, s$3, i$3, s$4, _slice$11, _index$11, _slice$12, _index$12, _slice$13, _index$13, _ref$5, _entry$1, _i$5, _slice$14, _index$14, g$2, _ref$6, _i$6, _slice$15, _index$15, c, _slice$16, _index$16;
		if (specs.length <= 1) {
			return specs;
		}
		pos = (go$sliceType(posSpan)).make(specs.length, 0, function() { return new posSpan.Ptr(); });
		_ref = specs;
		_i = 0;
		while (_i < _ref.length) {
			s = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			_slice$1 = pos, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = new posSpan.Ptr(s.Pos(), s.End())) : go$throwRuntimeError("index out of range");
			_i++;
		}
		lastLine = fset.Position((_slice$2 = pos, _index$2 = (pos.length - 1 >> 0), (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")).End).Line;
		cstart = f.Comments.length;
		cend = f.Comments.length;
		_ref$1 = f.Comments;
		_i$1 = 0;
		while (_i$1 < _ref$1.length) {
			g = (_slice$3 = _ref$1, _index$3 = _i$1, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range"));
			i$1 = _i$1;
			if (g.Pos() < (_slice$4 = pos, _index$4 = 0, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range")).Start) {
				_i$1++;
				continue;
			}
			if (i$1 < cstart) {
				cstart = i$1;
			}
			if (fset.Position(g.End()).Line > lastLine) {
				cend = i$1;
				break;
			}
			_i$1++;
		}
		comments = go$subslice(f.Comments, cstart, cend);
		importComment$1 = (_map = new Go$Map(), _map);
		specIndex = 0;
		_ref$2 = comments;
		_i$2 = 0;
		while (_i$2 < _ref$2.length) {
			g$1 = (_slice$5 = _ref$2, _index$5 = _i$2, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range"));
			while ((specIndex + 1 >> 0) < specs.length && (_slice$6 = pos, _index$6 = (specIndex + 1 >> 0), (_index$6 >= 0 && _index$6 < _slice$6.length) ? _slice$6.array[_slice$6.offset + _index$6] : go$throwRuntimeError("index out of range")).Start <= g$1.Pos()) {
				specIndex = specIndex + 1 >> 0;
			}
			s$1 = (x = (_slice$7 = specs, _index$7 = specIndex, (_index$7 >= 0 && _index$7 < _slice$7.length) ? _slice$7.array[_slice$7.offset + _index$7] : go$throwRuntimeError("index out of range")), (x !== null && x.constructor === (go$ptrType(ImportSpec)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(ImportSpec)))));
			_key$1 = s$1, (importComment$1 || go$throwRuntimeError("assignment to entry in nil map"))[_key$1.go$key()] = { k: _key$1, v: go$append((_entry = importComment$1[s$1.go$key()], _entry !== undefined ? _entry.v : (go$sliceType((go$ptrType(CommentGroup)))).nil), g$1) };
			_i$2++;
		}
		sort.Sort(go$subslice(new byImportSpec(specs.array), specs.offset, specs.offset + specs.length));
		deduped = go$subslice(specs, 0, 0);
		_ref$3 = specs;
		_i$3 = 0;
		while (_i$3 < _ref$3.length) {
			s$2 = (_slice$8 = _ref$3, _index$8 = _i$3, (_index$8 >= 0 && _index$8 < _slice$8.length) ? _slice$8.array[_slice$8.offset + _index$8] : go$throwRuntimeError("index out of range"));
			i$2 = _i$3;
			if ((i$2 === (specs.length - 1 >> 0)) || !collapse(s$2, (_slice$9 = specs, _index$9 = (i$2 + 1 >> 0), (_index$9 >= 0 && _index$9 < _slice$9.length) ? _slice$9.array[_slice$9.offset + _index$9] : go$throwRuntimeError("index out of range")))) {
				deduped = go$append(deduped, s$2);
			} else {
				p = s$2.Pos();
				fset.File(p).MergeLine(fset.Position(p).Line);
			}
			_i$3++;
		}
		specs = deduped;
		_ref$4 = specs;
		_i$4 = 0;
		while (_i$4 < _ref$4.length) {
			s$3 = (_slice$10 = _ref$4, _index$10 = _i$4, (_index$10 >= 0 && _index$10 < _slice$10.length) ? _slice$10.array[_slice$10.offset + _index$10] : go$throwRuntimeError("index out of range"));
			i$3 = _i$4;
			s$4 = (s$3 !== null && s$3.constructor === (go$ptrType(ImportSpec)) ? s$3.go$val : go$typeAssertionFailed(s$3, (go$ptrType(ImportSpec))));
			if (!(s$4.Name === (go$ptrType(Ident)).nil)) {
				s$4.Name.NamePos = (_slice$11 = pos, _index$11 = i$3, (_index$11 >= 0 && _index$11 < _slice$11.length) ? _slice$11.array[_slice$11.offset + _index$11] : go$throwRuntimeError("index out of range")).Start;
			}
			s$4.Path.ValuePos = (_slice$12 = pos, _index$12 = i$3, (_index$12 >= 0 && _index$12 < _slice$12.length) ? _slice$12.array[_slice$12.offset + _index$12] : go$throwRuntimeError("index out of range")).Start;
			s$4.EndPos = (_slice$13 = pos, _index$13 = i$3, (_index$13 >= 0 && _index$13 < _slice$13.length) ? _slice$13.array[_slice$13.offset + _index$13] : go$throwRuntimeError("index out of range")).End;
			_ref$5 = (_entry$1 = importComment$1[s$4.go$key()], _entry$1 !== undefined ? _entry$1.v : (go$sliceType((go$ptrType(CommentGroup)))).nil);
			_i$5 = 0;
			while (_i$5 < _ref$5.length) {
				g$2 = (_slice$14 = _ref$5, _index$14 = _i$5, (_index$14 >= 0 && _index$14 < _slice$14.length) ? _slice$14.array[_slice$14.offset + _index$14] : go$throwRuntimeError("index out of range"));
				_ref$6 = g$2.List;
				_i$6 = 0;
				while (_i$6 < _ref$6.length) {
					c = (_slice$15 = _ref$6, _index$15 = _i$6, (_index$15 >= 0 && _index$15 < _slice$15.length) ? _slice$15.array[_slice$15.offset + _index$15] : go$throwRuntimeError("index out of range"));
					c.Slash = (_slice$16 = pos, _index$16 = i$3, (_index$16 >= 0 && _index$16 < _slice$16.length) ? _slice$16.array[_slice$16.offset + _index$16] : go$throwRuntimeError("index out of range")).End;
					_i$6++;
				}
				_i$5++;
			}
			_i$4++;
		}
		sort.Sort(go$subslice(new byCommentPos(comments.array), comments.offset, comments.offset + comments.length));
		return specs;
	};
 0	sortSpecs0Å§0go/astCommentGroup0go/astbyImportSpec0go/astcollapse0go/astIdent0go/astbyCommentPos0go/astposSpan0go/ast
ImportSpec0sortSort0Åﬁ Å≠	byImportSpec.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byImportSpec).prototype.Len = function() { return this.go$get().Len(); };
 0byImportSpec00go/astbyImportSpec0Ç‡ ÇÆ	byImportSpec.prototype.Swap = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byImportSpec).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0byImportSpec00go/astbyImportSpec0Ç| Ç	byImportSpec.prototype.Less = function(i, j) {
		var x, _slice, _index, ipath, _slice$1, _index$1, jpath, _slice$2, _index$2, iname, _slice$3, _index$3, jname, _slice$4, _index$4, _slice$5, _index$5;
		x = this;
		ipath = importPath((_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")));
		jpath = importPath((_slice$1 = x, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")));
		if (!(ipath === jpath)) {
			return ipath < jpath;
		}
		iname = importName((_slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range")));
		jname = importName((_slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? _slice$3.array[_slice$3.offset + _index$3] : go$throwRuntimeError("index out of range")));
		if (!(iname === jname)) {
			return iname < jname;
		}
		return importComment((_slice$4 = x, _index$4 = i, (_index$4 >= 0 && _index$4 < _slice$4.length) ? _slice$4.array[_slice$4.offset + _index$4] : go$throwRuntimeError("index out of range"))) < importComment((_slice$5 = x, _index$5 = j, (_index$5 >= 0 && _index$5 < _slice$5.length) ? _slice$5.array[_slice$5.offset + _index$5] : go$throwRuntimeError("index out of range")));
	};
	go$ptrType(byImportSpec).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0byImportSpec0]0go/astbyImportSpec0go/ast
importPath0go/ast
importName0go/astimportComment0Åﬁ Å≠	byCommentPos.prototype.Len = function() {
		var x;
		x = this;
		return x.length;
	};
	go$ptrType(byCommentPos).prototype.Len = function() { return this.go$get().Len(); };
 0byCommentPos00go/astbyCommentPos0Ç‡ ÇÆ	byCommentPos.prototype.Swap = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		x = this;
		_tuple = [(_slice = x, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = x, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = x, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = x, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byCommentPos).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0byCommentPos00go/astbyCommentPos0ÇS Ç!	byCommentPos.prototype.Less = function(i, j) {
		var x, _slice, _index, _slice$1, _index$1;
		x = this;
		return (_slice = x, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos() < (_slice$1 = x, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Pos();
	};
	go$ptrType(byCommentPos).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0byCommentPos00go/astbyCommentPos0ÇNotNilFilterÅÁ	NotNilFilter = go$pkg.NotNilFilter = function(param, v) {
		var _ref;
		_ref = v.Kind();
		if (_ref === 18 || _ref === 19 || _ref === 20 || _ref === 21 || _ref === 22 || _ref === 23) {
			return !v.IsNil();
		}
		return true;
	};
 0NotNilFilter0 0Ç˘FprintÇW	Fprint = go$pkg.Fprint = function(w, fset, x, f) {
		var err, p, _struct;
		err = null;
		var go$deferred = [];
		try {
			p = new printer.Ptr(w, fset, f, new Go$Map(), 0, 10, 0);
			go$deferred.push({ fun: (function() {
				var e;
				if (e = go$recover(), !(go$interfaceIsEqual(e, null))) {
					err = (e !== null && e.constructor === localError ? e.go$val : go$typeAssertionFailed(e, localError)).err;
				}
			}), args: [] });
			if (go$interfaceIsEqual(x, null)) {
				p.printf("nil\n", new (go$sliceType(go$emptyInterface))([]));
				return err;
			}
			p.print((_struct = reflect.ValueOf(x), new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)));
			p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
			return err;
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return err;
		}
	};
 0Fprint0Åá0go/tokenFileSet0go/astprinter0go/ast
localError0go/astprintf0go/astprint0reflectValueOf0reflectValue0Å±Printc	Print = go$pkg.Print = function(fset, x) {
		return Fprint(os.Stdout, fset, x, NotNilFilter);
	};
 0Print080go/astFprint0osStdout0go/astNotNilFilter0Çó ÇM	printer.Ptr.prototype.Write = function(data) {
		var n, err, p, m, _ref, _i, _slice, _index, b, i, _tuple, _tuple$1, j, _tuple$2, _tuple$3;
		n = 0;
		err = null;
		p = this;
		m = 0;
		_ref = data;
		_i = 0;
		while (_i < _ref.length) {
			b = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (b === 10) {
				_tuple = p.output.Write(go$subslice(data, n, (i + 1 >> 0))), m = _tuple[0], err = _tuple[1];
				n = n + (m) >> 0;
				if (!(go$interfaceIsEqual(err, null))) {
					return [n, err];
				}
				p.line = p.line + 1 >> 0;
			} else if (p.last === 10) {
				_tuple$1 = fmt.Fprintf(p.output, "%6d  ", new (go$sliceType(go$emptyInterface))([new Go$Int(p.line)])), err = _tuple$1[1];
				if (!(go$interfaceIsEqual(err, null))) {
					return [n, err];
				}
				j = p.indent;
				while (j > 0) {
					_tuple$2 = p.output.Write(indent), err = _tuple$2[1];
					if (!(go$interfaceIsEqual(err, null))) {
						return [n, err];
					}
					j = j - 1 >> 0;
				}
			}
			p.last = b;
			_i++;
		}
		if (data.length > n) {
			_tuple$3 = p.output.Write(go$subslice(data, n)), m = _tuple$3[0], err = _tuple$3[1];
			n = n + (m) >> 0;
		}
		return [n, err];
	};
	printer.prototype.Write = function(data) { return this.go$val.Write(data); };
 0	printer050go/astprinter0fmtFprintf0go/astindent0Çœ Çy	printer.Ptr.prototype.printf = function(format, args) {
		var p, err, _tuple, x;
		p = this;
		if (_tuple = fmt.Fprintf(p, format, args), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
			throw go$panic((x = new localError.Ptr(err), new x.constructor.Struct(x)));
		}
	};
	printer.prototype.printf = function(format, args) { return this.go$val.printf(format, args); };
 0printerprintf090go/astprinter0fmtFprintf0go/ast
localError0ÇÂ Ç=	printer.Ptr.prototype.print = function(x) {
		var p, _struct, _ref, _struct$1, _ref$1, _i, _slice, _index, _struct$2, key, _struct$3, _struct$4, _struct$5, ptr, exists, _tuple, _entry, line, _key, _struct$6, _tuple$1, i, n, _struct$7, ok, _tuple$2, x$1, s, _tuple$3, i$1, n$1, _struct$8, t, first, _tuple$4, i$2, n$2, name, _struct$9, value, _struct$10, _struct$11, v, v$1, _ref$2, _type, x$2;
		p = this;
		if (!NotNilFilter("", (_struct = x, new reflect.Value.Ptr(_struct.typ, _struct.val, _struct.flag)))) {
			p.printf("nil", new (go$sliceType(go$emptyInterface))([]));
			return;
		}
		_ref = x.Kind();
		if (_ref === 20) {
			p.print((_struct$1 = x.Elem(), new reflect.Value.Ptr(_struct$1.typ, _struct$1.val, _struct$1.flag)));
		} else if (_ref === 21) {
			p.printf("%s (len = %d) {", new (go$sliceType(go$emptyInterface))([x.Type(), new Go$Int(x.Len())]));
			if (x.Len() > 0) {
				p.indent = p.indent + 1 >> 0;
				p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
				_ref$1 = x.MapKeys();
				_i = 0;
				while (_i < _ref$1.length) {
					key = (_struct$2 = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), new reflect.Value.Ptr(_struct$2.typ, _struct$2.val, _struct$2.flag));
					p.print((_struct$3 = key, new reflect.Value.Ptr(_struct$3.typ, _struct$3.val, _struct$3.flag)));
					p.printf(": ", new (go$sliceType(go$emptyInterface))([]));
					p.print((_struct$5 = x.MapIndex((_struct$4 = key, new reflect.Value.Ptr(_struct$4.typ, _struct$4.val, _struct$4.flag))), new reflect.Value.Ptr(_struct$5.typ, _struct$5.val, _struct$5.flag)));
					p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
					_i++;
				}
				p.indent = p.indent - 1 >> 0;
			}
			p.printf("}", new (go$sliceType(go$emptyInterface))([]));
		} else if (_ref === 22) {
			p.printf("*", new (go$sliceType(go$emptyInterface))([]));
			ptr = x.Interface();
			if (_tuple = (_entry = p.ptrmap[(ptr || go$interfaceNil).go$key()], _entry !== undefined ? [_entry.v, true] : [0, false]), line = _tuple[0], exists = _tuple[1], exists) {
				p.printf("(obj @ %d)", new (go$sliceType(go$emptyInterface))([new Go$Int(line)]));
			} else {
				_key = ptr, (p.ptrmap || go$throwRuntimeError("assignment to entry in nil map"))[(_key || go$interfaceNil).go$key()] = { k: _key, v: p.line };
				p.print((_struct$6 = x.Elem(), new reflect.Value.Ptr(_struct$6.typ, _struct$6.val, _struct$6.flag)));
			}
		} else if (_ref === 17) {
			p.printf("%s {", new (go$sliceType(go$emptyInterface))([x.Type()]));
			if (x.Len() > 0) {
				p.indent = p.indent + 1 >> 0;
				p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
				_tuple$1 = [0, x.Len()], i = _tuple$1[0], n = _tuple$1[1];
				while (i < n) {
					p.printf("%d: ", new (go$sliceType(go$emptyInterface))([new Go$Int(i)]));
					p.print((_struct$7 = x.Index(i), new reflect.Value.Ptr(_struct$7.typ, _struct$7.val, _struct$7.flag)));
					p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
					i = i + 1 >> 0;
				}
				p.indent = p.indent - 1 >> 0;
			}
			p.printf("}", new (go$sliceType(go$emptyInterface))([]));
		} else if (_ref === 23) {
			if (_tuple$2 = (x$1 = x.Interface(), (x$1 !== null && x$1.constructor === (go$sliceType(Go$Uint8)) ? [x$1.go$val, true] : [(go$sliceType(Go$Uint8)).nil, false])), s = _tuple$2[0], ok = _tuple$2[1], ok) {
				p.printf("%#q", new (go$sliceType(go$emptyInterface))([s]));
				return;
			}
			p.printf("%s (len = %d) {", new (go$sliceType(go$emptyInterface))([x.Type(), new Go$Int(x.Len())]));
			if (x.Len() > 0) {
				p.indent = p.indent + 1 >> 0;
				p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
				_tuple$3 = [0, x.Len()], i$1 = _tuple$3[0], n$1 = _tuple$3[1];
				while (i$1 < n$1) {
					p.printf("%d: ", new (go$sliceType(go$emptyInterface))([new Go$Int(i$1)]));
					p.print((_struct$8 = x.Index(i$1), new reflect.Value.Ptr(_struct$8.typ, _struct$8.val, _struct$8.flag)));
					p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
					i$1 = i$1 + 1 >> 0;
				}
				p.indent = p.indent - 1 >> 0;
			}
			p.printf("}", new (go$sliceType(go$emptyInterface))([]));
		} else if (_ref === 25) {
			t = x.Type();
			p.printf("%s {", new (go$sliceType(go$emptyInterface))([t]));
			p.indent = p.indent + 1 >> 0;
			first = true;
			_tuple$4 = [0, t.NumField()], i$2 = _tuple$4[0], n$2 = _tuple$4[1];
			while (i$2 < n$2) {
				if (name = t.Field(i$2).Name, IsExported(name)) {
					value = (_struct$9 = x.Field(i$2), new reflect.Value.Ptr(_struct$9.typ, _struct$9.val, _struct$9.flag));
					if (p.filter === go$throwNilPointerError || p.filter(name, (_struct$10 = value, new reflect.Value.Ptr(_struct$10.typ, _struct$10.val, _struct$10.flag)))) {
						if (first) {
							p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
							first = false;
						}
						p.printf("%s: ", new (go$sliceType(go$emptyInterface))([new Go$String(name)]));
						p.print((_struct$11 = value, new reflect.Value.Ptr(_struct$11.typ, _struct$11.val, _struct$11.flag)));
						p.printf("\n", new (go$sliceType(go$emptyInterface))([]));
					}
				}
				i$2 = i$2 + 1 >> 0;
			}
			p.indent = p.indent - 1 >> 0;
			p.printf("}", new (go$sliceType(go$emptyInterface))([]));
		} else {
			v = x.Interface();
			_ref$2 = v;
			_type = _ref$2 !== null ? _ref$2.constructor : null;
			if (_type === Go$String) {
				v$1 = _ref$2.go$val;
				p.printf("%q", new (go$sliceType(go$emptyInterface))([new Go$String(v$1)]));
				return;
			} else if (_type === token.Pos) {
				v$1 = _ref$2.go$val;
				if (!(p.fset === (go$ptrType(token.FileSet)).nil)) {
					p.printf("%s", new (go$sliceType(go$emptyInterface))([(x$2 = p.fset.Position(v$1), new x$2.constructor.Struct(x$2))]));
					return;
				}
			}
			p.printf("%v", new (go$sliceType(go$emptyInterface))([v]));
		}
	};
	printer.prototype.print = function(x) { return this.go$val.print(x); };
 0printerprint0Åã0go/astprinter0go/astNotNilFilter0reflectValue0go/astprintf0go/ast
IsExported0go/tokenPos0go/tokenFileSet0Ç Ç¢	pkgBuilder.Ptr.prototype.error = function(pos, msg) {
		var p, v, _struct;
		p = this;
		(new (go$ptrType(scanner.ErrorList))(function() { return p.errors; }, function(v) { p.errors = v; })).Add((_struct = p.fset.Position(pos), new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column)), msg);
	};
	pkgBuilder.prototype.error = function(pos, msg) { return this.go$val.error(pos, msg); };
 0
pkgBuildererror0E0go/ast
pkgBuilder0
go/scanner	ErrorList0go/tokenPosition0ÇI ÅÛ	pkgBuilder.Ptr.prototype.errorf = function(pos, format, args) {
		var p;
		p = this;
		p.error(pos, fmt.Sprintf(format, args));
	};
	pkgBuilder.prototype.errorf = function(pos, format, args) { return this.go$val.errorf(pos, format, args); };
 0
pkgBuildererrorf070go/ast
pkgBuilder0go/asterror0fmtSprintf0Ç— ÇE	pkgBuilder.Ptr.prototype.declare = function(scope, altScope, obj) {
		var p, alt, prevDecl, pos, x;
		p = this;
		alt = scope.Insert(obj);
		if (alt === (go$ptrType(Object)).nil && !(altScope === (go$ptrType(Scope)).nil)) {
			alt = altScope.Lookup(obj.Name);
		}
		if (!(alt === (go$ptrType(Object)).nil)) {
			prevDecl = "";
			if (pos = alt.Pos(), (new token.Pos(pos)).IsValid()) {
				prevDecl = fmt.Sprintf("\n\tprevious declaration at %s", new (go$sliceType(go$emptyInterface))([(x = p.fset.Position(pos), new x.constructor.Struct(x))]));
			}
			p.error(obj.Pos(), fmt.Sprintf("%s redeclared in this block%s", new (go$sliceType(go$emptyInterface))([new Go$String(obj.Name), new Go$String(prevDecl)])));
		}
	};
	pkgBuilder.prototype.declare = function(scope, altScope, obj) { return this.go$val.declare(scope, altScope, obj); };
 0
pkgBuilderdeclare0k0go/ast
pkgBuilder0go/astObject0go/astScope0go/tokenPos0fmtSprintf0go/asterror0ÇHresolveÇ		resolve = function(scope, ident) {
		var obj;
		while (!(scope === (go$ptrType(Scope)).nil)) {
			if (obj = scope.Lookup(ident.Name), !(obj === (go$ptrType(Object)).nil)) {
				ident.Obj = obj;
				return true;
			}
			scope = scope.Outer;
		}
		return false;
	};
 0	resolve0#0go/astScope0go/astObject0Ç
NewPackageÇ5	NewPackage = go$pkg.NewPackage = function(fset, files, importer, universe) {
		var p, pkgName, pkgScope, _ref, _i, _keys, _entry, file, name, _ref$1, _i$1, _keys$1, _entry$1, obj, imports, _ref$2, _i$2, _keys$2, _entry$2, file$1, importErrors, fileScope, _ref$3, _i$3, _slice, _index, spec, _tuple, path, _tuple$1, pkg, err, name$1, _ref$4, x, _i$4, _keys$3, _entry$3, obj$1, obj$2, i, _ref$5, _i$5, _slice$1, _index$1, ident, _slice$2, _index$2;
		p = new pkgBuilder.Ptr();
		p.fset = fset;
		pkgName = "";
		pkgScope = NewScope(universe);
		_ref = files;
		_i = 0;
		_keys = go$keys(_ref);
		while (_i < _keys.length) {
			_entry = _ref[_keys[_i]];
			file = _entry.v;
			name = file.Name.Name;
			if (pkgName === "") {
				pkgName = name;
			} else if (!(name === pkgName)) {
				p.errorf(file.Package, "package %s; expected %s", new (go$sliceType(go$emptyInterface))([new Go$String(name), new Go$String(pkgName)]));
				_i++;
				continue;
			}
			_ref$1 = file.Scope.Objects;
			_i$1 = 0;
			_keys$1 = go$keys(_ref$1);
			while (_i$1 < _keys$1.length) {
				_entry$1 = _ref$1[_keys$1[_i$1]];
				obj = _entry$1.v;
				p.declare(pkgScope, (go$ptrType(Scope)).nil, obj);
				_i$1++;
			}
			_i++;
		}
		imports = new Go$Map();
		_ref$2 = files;
		_i$2 = 0;
		_keys$2 = go$keys(_ref$2);
		while (_i$2 < _keys$2.length) {
			_entry$2 = _ref$2[_keys$2[_i$2]];
			file$1 = _entry$2.v;
			if (!(file$1.Name.Name === pkgName)) {
				_i$2++;
				continue;
			}
			importErrors = false;
			fileScope = NewScope(pkgScope);
			_ref$3 = file$1.Imports;
			_i$3 = 0;
			while (_i$3 < _ref$3.length) {
				spec = (_slice = _ref$3, _index = _i$3, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (importer === go$throwNilPointerError) {
					importErrors = true;
					_i$3++;
					continue;
				}
				_tuple = strconv.Unquote(spec.Path.Value), path = _tuple[0];
				_tuple$1 = importer(imports, path), pkg = _tuple$1[0], err = _tuple$1[1];
				if (!(go$interfaceIsEqual(err, null))) {
					p.errorf(spec.Path.Pos(), "could not import %s (%s)", new (go$sliceType(go$emptyInterface))([new Go$String(path), err]));
					importErrors = true;
					_i$3++;
					continue;
				}
				name$1 = pkg.Name;
				if (!(spec.Name === (go$ptrType(Ident)).nil)) {
					name$1 = spec.Name.Name;
				}
				if (name$1 === ".") {
					_ref$4 = (x = pkg.Data, (x !== null && x.constructor === (go$ptrType(Scope)) ? x.go$val : go$typeAssertionFailed(x, (go$ptrType(Scope))))).Objects;
					_i$4 = 0;
					_keys$3 = go$keys(_ref$4);
					while (_i$4 < _keys$3.length) {
						_entry$3 = _ref$4[_keys$3[_i$4]];
						obj$1 = _entry$3.v;
						p.declare(fileScope, pkgScope, obj$1);
						_i$4++;
					}
				} else if (!(name$1 === "_")) {
					obj$2 = NewObj(1, name$1);
					obj$2.Decl = spec;
					obj$2.Data = pkg.Data;
					p.declare(fileScope, pkgScope, obj$2);
				}
				_i$3++;
			}
			if (importErrors) {
				pkgScope.Outer = (go$ptrType(Scope)).nil;
			}
			i = 0;
			_ref$5 = file$1.Unresolved;
			_i$5 = 0;
			while (_i$5 < _ref$5.length) {
				ident = (_slice$1 = _ref$5, _index$1 = _i$5, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (!resolve(fileScope, ident)) {
					p.errorf(ident.Pos(), "undeclared name: %s", new (go$sliceType(go$emptyInterface))([new Go$String(ident.Name)]));
					_slice$2 = file$1.Unresolved, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = ident) : go$throwRuntimeError("index out of range");
					i = i + 1 >> 0;
				}
				_i$5++;
			}
			file$1.Unresolved = go$subslice(file$1.Unresolved, 0, i);
			pkgScope.Outer = universe;
			_i$2++;
		}
		p.errors.Sort();
		return [new Package.Ptr(pkgName, pkgScope, imports, files), p.errors.Err()];
	};
 0
NewPackage0ÅΩ0go/astNewScope0go/astIdent0go/astNewObj0go/astresolve0go/ast
pkgBuilder0go/asterrorf0go/astdeclare0go/astScope0strconvUnquote0go/astPackage0ÅéNewScopea	NewScope = go$pkg.NewScope = function(outer) {
		return new Scope.Ptr(outer, new Go$Map());
	};
 0
NewScope00go/astScope0Ç6 Ç 	Scope.Ptr.prototype.Lookup = function(name) {
		var s, _entry;
		s = this;
		return (_entry = s.Objects[name], _entry !== undefined ? _entry.v : (go$ptrType(Object)).nil);
	};
	Scope.prototype.Lookup = function(name) { return this.go$val.Lookup(name); };
 0Scope0#0go/astScope0go/astObject0Ç Çﬁ	Scope.Ptr.prototype.Insert = function(obj) {
		var alt, s, _entry, _key;
		alt = (go$ptrType(Object)).nil;
		s = this;
		if (alt = (_entry = s.Objects[obj.Name], _entry !== undefined ? _entry.v : (go$ptrType(Object)).nil), alt === (go$ptrType(Object)).nil) {
			_key = obj.Name, (s.Objects || go$throwRuntimeError("assignment to entry in nil map"))[_key] = { k: _key, v: obj };
		}
		return alt;
	};
	Scope.prototype.Insert = function(obj) { return this.go$val.Insert(obj); };
 0Scope0#0go/astScope0go/astObject0Çà Ç	Scope.Ptr.prototype.String = function() {
		var s, buf, _ref, _i, _keys, _entry, obj;
		s = this;
		buf = new bytes.Buffer.Ptr();
		fmt.Fprintf(buf, "scope %p {", new (go$sliceType(go$emptyInterface))([s]));
		if (!(s === (go$ptrType(Scope)).nil) && go$keys(s.Objects).length > 0) {
			fmt.Fprintln(buf, new (go$sliceType(go$emptyInterface))([]));
			_ref = s.Objects;
			_i = 0;
			_keys = go$keys(_ref);
			while (_i < _keys.length) {
				_entry = _ref[_keys[_i]];
				obj = _entry.v;
				fmt.Fprintf(buf, "\t%s %s\n", new (go$sliceType(go$emptyInterface))([new ObjKind(obj.Kind), new Go$String(obj.Name)]));
				_i++;
			}
		}
		fmt.Fprintf(buf, "}\n", new (go$sliceType(go$emptyInterface))([]));
		return buf.String();
	};
	Scope.prototype.String = function() { return this.go$val.String(); };
 0Scope0V0go/astScope0bytesBuffer0fmtFprintf0fmtFprintln0go/astObjKind0ÅñNewObjl	NewObj = go$pkg.NewObj = function(kind, name) {
		return new Object.Ptr(kind, name, null, null, null);
	};
 0NewObj00go/astObject0Ç	ﬂ Ç		Object.Ptr.prototype.Pos = function() {
		var obj, name, d, _ref, _type, _ref$1, _i, _slice, _index, n, _ref$2, _i$1, _slice$1, _index$1, n$1, _ref$3, _i$2, _slice$2, _index$2, x, isIdent, ident, _tuple;
		obj = this;
		name = obj.Name;
		_ref = obj.Decl;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(Field))) {
			d = _ref.go$val;
			_ref$1 = d.Names;
			_i = 0;
			while (_i < _ref$1.length) {
				n = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				if (n.Name === name) {
					return n.Pos();
				}
				_i++;
			}
		} else if (_type === (go$ptrType(ImportSpec))) {
			d = _ref.go$val;
			if (!(d.Name === (go$ptrType(Ident)).nil) && d.Name.Name === name) {
				return d.Name.Pos();
			}
			return d.Path.Pos();
		} else if (_type === (go$ptrType(ValueSpec))) {
			d = _ref.go$val;
			_ref$2 = d.Names;
			_i$1 = 0;
			while (_i$1 < _ref$2.length) {
				n$1 = (_slice$1 = _ref$2, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				if (n$1.Name === name) {
					return n$1.Pos();
				}
				_i$1++;
			}
		} else if (_type === (go$ptrType(TypeSpec))) {
			d = _ref.go$val;
			if (d.Name.Name === name) {
				return d.Name.Pos();
			}
		} else if (_type === (go$ptrType(FuncDecl))) {
			d = _ref.go$val;
			if (d.Name.Name === name) {
				return d.Name.Pos();
			}
		} else if (_type === (go$ptrType(LabeledStmt))) {
			d = _ref.go$val;
			if (d.Label.Name === name) {
				return d.Label.Pos();
			}
		} else if (_type === (go$ptrType(AssignStmt))) {
			d = _ref.go$val;
			_ref$3 = d.Lhs;
			_i$2 = 0;
			while (_i$2 < _ref$3.length) {
				x = (_slice$2 = _ref$3, _index$2 = _i$2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
				if (_tuple = (x !== null && x.constructor === (go$ptrType(Ident)) ? [x.go$val, true] : [(go$ptrType(Ident)).nil, false]), ident = _tuple[0], isIdent = _tuple[1], isIdent && ident.Name === name) {
					return ident.Pos();
				}
				_i$2++;
			}
		}
		return 0;
	};
	Object.prototype.Pos = function() { return this.go$val.Pos(); };
 0Object0Å≈0go/ast	ValueSpec0go/astFuncDecl0go/astObject0go/astField0go/ast
ImportSpec0go/astTypeSpec0go/astLabeledStmt0go/ast
AssignStmt0go/astScope0go/astIdent0Ç Å“	ObjKind.prototype.String = function() {
		var kind;
		kind = this.go$val;
		return objKindStrings[kind];
	};
	go$ptrType(ObjKind).prototype.String = function() { return new ObjKind(this.go$get()).String(); };
 0	ObjKind0-0go/astObjKind0go/astobjKindStrings0ÇxwalkIdentListÇ@	walkIdentList = function(v, list) {
		var _ref, _i, _slice, _index, x;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			Walk(v, x);
			_i++;
		}
	};
 0walkIdentList00go/astWalk0ÇuwalkExprListÇ?	walkExprList = function(v, list) {
		var _ref, _i, _slice, _index, x;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			Walk(v, x);
			_i++;
		}
	};
 0walkExprList00go/astWalk0ÇuwalkStmtListÇ?	walkStmtList = function(v, list) {
		var _ref, _i, _slice, _index, x;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			Walk(v, x);
			_i++;
		}
	};
 0walkStmtList00go/astWalk0ÇuwalkDeclListÇ?	walkDeclList = function(v, list) {
		var _ref, _i, _slice, _index, x;
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			x = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			Walk(v, x);
			_i++;
		}
	};
 0walkDeclList00go/astWalk0Ç)íWalkÇ$ê	Walk = go$pkg.Walk = function(v, node) {
		var n, _ref, _type, _ref$1, _i, _slice, _index, c, _ref$2, _i$1, _slice$1, _index$1, f, _ref$3, _i$2, _slice$2, _index$2, s, _ref$4, _i$3, _keys, _entry, f$1;
		if (v = v.Visit(node), go$interfaceIsEqual(v, null)) {
			return;
		}
		_ref = node;
		_type = _ref !== null ? _ref.constructor : null;
		if (_type === (go$ptrType(Comment))) {
			n = _ref.go$val;
		} else if (_type === (go$ptrType(CommentGroup))) {
			n = _ref.go$val;
			_ref$1 = n.List;
			_i = 0;
			while (_i < _ref$1.length) {
				c = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				Walk(v, c);
				_i++;
			}
		} else if (_type === (go$ptrType(Field))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			walkIdentList(v, n.Names);
			Walk(v, n.Type);
			if (!(n.Tag === (go$ptrType(BasicLit)).nil)) {
				Walk(v, n.Tag);
			}
			if (!(n.Comment === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Comment);
			}
		} else if (_type === (go$ptrType(FieldList))) {
			n = _ref.go$val;
			_ref$2 = n.List;
			_i$1 = 0;
			while (_i$1 < _ref$2.length) {
				f = (_slice$1 = _ref$2, _index$1 = _i$1, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"));
				Walk(v, f);
				_i$1++;
			}
		} else if (_type === (go$ptrType(BadExpr)) || _type === (go$ptrType(Ident)) || _type === (go$ptrType(BasicLit))) {
			n = _ref;
		} else if (_type === (go$ptrType(Ellipsis))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Elt, null))) {
				Walk(v, n.Elt);
			}
		} else if (_type === (go$ptrType(FuncLit))) {
			n = _ref.go$val;
			Walk(v, n.Type);
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(CompositeLit))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Type, null))) {
				Walk(v, n.Type);
			}
			walkExprList(v, n.Elts);
		} else if (_type === (go$ptrType(ParenExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
		} else if (_type === (go$ptrType(SelectorExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
			Walk(v, n.Sel);
		} else if (_type === (go$ptrType(IndexExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
			Walk(v, n.Index);
		} else if (_type === (go$ptrType(SliceExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
			if (!(go$interfaceIsEqual(n.Low, null))) {
				Walk(v, n.Low);
			}
			if (!(go$interfaceIsEqual(n.High, null))) {
				Walk(v, n.High);
			}
			if (!(go$interfaceIsEqual(n.Max, null))) {
				Walk(v, n.Max);
			}
		} else if (_type === (go$ptrType(TypeAssertExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
			if (!(go$interfaceIsEqual(n.Type, null))) {
				Walk(v, n.Type);
			}
		} else if (_type === (go$ptrType(CallExpr))) {
			n = _ref.go$val;
			Walk(v, n.Fun);
			walkExprList(v, n.Args);
		} else if (_type === (go$ptrType(StarExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
		} else if (_type === (go$ptrType(UnaryExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
		} else if (_type === (go$ptrType(BinaryExpr))) {
			n = _ref.go$val;
			Walk(v, n.X);
			Walk(v, n.Y);
		} else if (_type === (go$ptrType(KeyValueExpr))) {
			n = _ref.go$val;
			Walk(v, n.Key);
			Walk(v, n.Value);
		} else if (_type === (go$ptrType(ArrayType))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Len, null))) {
				Walk(v, n.Len);
			}
			Walk(v, n.Elt);
		} else if (_type === (go$ptrType(StructType))) {
			n = _ref.go$val;
			Walk(v, n.Fields);
		} else if (_type === (go$ptrType(FuncType))) {
			n = _ref.go$val;
			if (!(n.Params === (go$ptrType(FieldList)).nil)) {
				Walk(v, n.Params);
			}
			if (!(n.Results === (go$ptrType(FieldList)).nil)) {
				Walk(v, n.Results);
			}
		} else if (_type === (go$ptrType(InterfaceType))) {
			n = _ref.go$val;
			Walk(v, n.Methods);
		} else if (_type === (go$ptrType(MapType))) {
			n = _ref.go$val;
			Walk(v, n.Key);
			Walk(v, n.Value);
		} else if (_type === (go$ptrType(ChanType))) {
			n = _ref.go$val;
			Walk(v, n.Value);
		} else if (_type === (go$ptrType(BadStmt))) {
			n = _ref.go$val;
		} else if (_type === (go$ptrType(DeclStmt))) {
			n = _ref.go$val;
			Walk(v, n.Decl);
		} else if (_type === (go$ptrType(EmptyStmt))) {
			n = _ref.go$val;
		} else if (_type === (go$ptrType(LabeledStmt))) {
			n = _ref.go$val;
			Walk(v, n.Label);
			Walk(v, n.Stmt);
		} else if (_type === (go$ptrType(ExprStmt))) {
			n = _ref.go$val;
			Walk(v, n.X);
		} else if (_type === (go$ptrType(SendStmt))) {
			n = _ref.go$val;
			Walk(v, n.Chan);
			Walk(v, n.Value);
		} else if (_type === (go$ptrType(IncDecStmt))) {
			n = _ref.go$val;
			Walk(v, n.X);
		} else if (_type === (go$ptrType(AssignStmt))) {
			n = _ref.go$val;
			walkExprList(v, n.Lhs);
			walkExprList(v, n.Rhs);
		} else if (_type === (go$ptrType(GoStmt))) {
			n = _ref.go$val;
			Walk(v, n.Call);
		} else if (_type === (go$ptrType(DeferStmt))) {
			n = _ref.go$val;
			Walk(v, n.Call);
		} else if (_type === (go$ptrType(ReturnStmt))) {
			n = _ref.go$val;
			walkExprList(v, n.Results);
		} else if (_type === (go$ptrType(BranchStmt))) {
			n = _ref.go$val;
			if (!(n.Label === (go$ptrType(Ident)).nil)) {
				Walk(v, n.Label);
			}
		} else if (_type === (go$ptrType(BlockStmt))) {
			n = _ref.go$val;
			walkStmtList(v, n.List);
		} else if (_type === (go$ptrType(IfStmt))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Init, null))) {
				Walk(v, n.Init);
			}
			Walk(v, n.Cond);
			Walk(v, n.Body);
			if (!(go$interfaceIsEqual(n.Else, null))) {
				Walk(v, n.Else);
			}
		} else if (_type === (go$ptrType(CaseClause))) {
			n = _ref.go$val;
			walkExprList(v, n.List);
			walkStmtList(v, n.Body);
		} else if (_type === (go$ptrType(SwitchStmt))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Init, null))) {
				Walk(v, n.Init);
			}
			if (!(go$interfaceIsEqual(n.Tag, null))) {
				Walk(v, n.Tag);
			}
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(TypeSwitchStmt))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Init, null))) {
				Walk(v, n.Init);
			}
			Walk(v, n.Assign);
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(CommClause))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Comm, null))) {
				Walk(v, n.Comm);
			}
			walkStmtList(v, n.Body);
		} else if (_type === (go$ptrType(SelectStmt))) {
			n = _ref.go$val;
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(ForStmt))) {
			n = _ref.go$val;
			if (!(go$interfaceIsEqual(n.Init, null))) {
				Walk(v, n.Init);
			}
			if (!(go$interfaceIsEqual(n.Cond, null))) {
				Walk(v, n.Cond);
			}
			if (!(go$interfaceIsEqual(n.Post, null))) {
				Walk(v, n.Post);
			}
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(RangeStmt))) {
			n = _ref.go$val;
			Walk(v, n.Key);
			if (!(go$interfaceIsEqual(n.Value, null))) {
				Walk(v, n.Value);
			}
			Walk(v, n.X);
			Walk(v, n.Body);
		} else if (_type === (go$ptrType(ImportSpec))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			if (!(n.Name === (go$ptrType(Ident)).nil)) {
				Walk(v, n.Name);
			}
			Walk(v, n.Path);
			if (!(n.Comment === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Comment);
			}
		} else if (_type === (go$ptrType(ValueSpec))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			walkIdentList(v, n.Names);
			if (!(go$interfaceIsEqual(n.Type, null))) {
				Walk(v, n.Type);
			}
			walkExprList(v, n.Values);
			if (!(n.Comment === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Comment);
			}
		} else if (_type === (go$ptrType(TypeSpec))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			Walk(v, n.Name);
			Walk(v, n.Type);
			if (!(n.Comment === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Comment);
			}
		} else if (_type === (go$ptrType(BadDecl))) {
			n = _ref.go$val;
		} else if (_type === (go$ptrType(GenDecl))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			_ref$3 = n.Specs;
			_i$2 = 0;
			while (_i$2 < _ref$3.length) {
				s = (_slice$2 = _ref$3, _index$2 = _i$2, (_index$2 >= 0 && _index$2 < _slice$2.length) ? _slice$2.array[_slice$2.offset + _index$2] : go$throwRuntimeError("index out of range"));
				Walk(v, s);
				_i$2++;
			}
		} else if (_type === (go$ptrType(FuncDecl))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			if (!(n.Recv === (go$ptrType(FieldList)).nil)) {
				Walk(v, n.Recv);
			}
			Walk(v, n.Name);
			Walk(v, n.Type);
			if (!(n.Body === (go$ptrType(BlockStmt)).nil)) {
				Walk(v, n.Body);
			}
		} else if (_type === (go$ptrType(File))) {
			n = _ref.go$val;
			if (!(n.Doc === (go$ptrType(CommentGroup)).nil)) {
				Walk(v, n.Doc);
			}
			Walk(v, n.Name);
			walkDeclList(v, n.Decls);
		} else if (_type === (go$ptrType(Package))) {
			n = _ref.go$val;
			_ref$4 = n.Files;
			_i$3 = 0;
			_keys = go$keys(_ref$4);
			while (_i$3 < _keys.length) {
				_entry = _ref$4[_keys[_i$3]];
				f$1 = _entry.v;
				Walk(v, f$1);
				_i$3++;
			}
		} else {
			n = _ref;
			fmt.Printf("ast.Walk: unexpected node type %T", new (go$sliceType(go$emptyInterface))([n]));
			throw go$panic(new Go$String("ast.Walk"));
		}
		v.Visit(null);
	};
 0Walk0ÇÍ0go/ast	SliceExpr0go/ast
StructType0go/ast
AssignStmt0go/ast	BlockStmt0go/astBadStmt0go/astGoStmt0go/ast	IndexExpr0go/astKeyValueExpr0go/astLabeledStmt0go/astExprStmt0go/astBadDecl0go/ast	ParenExpr0go/ast
IncDecStmt0go/ast
CaseClause0go/ast	RangeStmt0go/astwalkIdentList0go/astwalkDeclList0go/astComment0go/astIdent0go/ast	DeferStmt0go/astFuncDecl0go/astField0go/ast	UnaryExpr0go/ast	ValueSpec0go/astCommentGroup0go/ast
ReturnStmt0go/ast	EmptyStmt0go/ast
SwitchStmt0go/astCallExpr0go/ast
BinaryExpr0go/astStarExpr0go/astFuncType0go/astMapType0go/ast
BranchStmt0go/ast	ArrayType0go/astFile0go/astwalkExprList0go/ast	FieldList0go/astFuncLit0go/astCompositeLit0go/ast
CommClause0go/astGenDecl0go/astBadExpr0go/astBasicLit0go/astTypeAssertExpr0go/astInterfaceType0go/astDeclStmt0go/astForStmt0go/astwalkStmtList0go/astIfStmt0go/astEllipsis0go/astSelectorExpr0go/astChanType0go/astSendStmt0fmtPrintf0go/astTypeSwitchStmt0go/ast
SelectStmt0go/ast
ImportSpec0go/astTypeSpec0go/astPackage0Ç' Å¸	inspector.prototype.Visit = function(node) {
		var f;
		f = this.go$val;
		if (f(node)) {
			return new inspector(f);
		}
		return null;
	};
	go$ptrType(inspector).prototype.Visit = function(node) { return new inspector(this.go$get()).Visit(node); };
 0	inspector00go/ast	inspector0ÅìInspectT	Inspect = go$pkg.Inspect = function(node, f) {
		Walk(new inspector(f), node);
	};
 0	Inspect0%0go/astWalk0go/ast	inspector0	separator  0	separator0 0indent  0indent0 0(objKindStrings  0objKindStrings0 0e  (		separator = new Comment.Ptr(0, "//");
0	separator0(0go/astComment0go/ast	separator0f  B		indent = new (go$sliceType(Go$Uint8))(go$stringToBytes(".  "));
0indent00go/astindent0Å†  l		objKindStrings = go$toNativeArray("String", ["bad", "package", "const", "type", "var", "func", "label"]);
0objKindStrings00go/astobjKindStrings0
   0 0 0
   0 0 0 