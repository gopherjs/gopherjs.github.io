0Ç•/
go/scannerÇ<package scanner
import fmt "fmt"
import token "go/token"
import io "io"
import sort "sort"
import bytes "bytes"
import filepath "path/filepath"
import strconv "strconv"
import unicode "unicode"
import utf8 "unicode/utf8"
type @"".Error struct { @"".Pos @"go/token".Position; @"".Msg string }
func (? @"".Error) @"".Error() (? string)
func (? *@"".Error) @"".Error() (? string)
type @"".ErrorHandler func (@"".pos @"go/token".Position, @"".msg string) ()
type @"".ErrorList []*@"".Error
func (? @"".ErrorList) @"".Err() (? error)
func (? @"".ErrorList) @"".Error() (? string)
func (? @"".ErrorList) @"".Len() (? int)
func (? @"".ErrorList) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".ErrorList) @"".Sort() ()
func (? @"".ErrorList) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".ErrorList) @"".Add(@"".pos @"go/token".Position, @"".msg string) ()
func (? *@"".ErrorList) @"".Err() (? error)
func (? *@"".ErrorList) @"".Error() (? string)
func (? *@"".ErrorList) @"".Len() (? int)
func (? *@"".ErrorList) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".ErrorList) @"".RemoveMultiples() ()
func (? *@"".ErrorList) @"".Reset() ()
func (? *@"".ErrorList) @"".Sort() ()
func (? *@"".ErrorList) @"".Swap(@"".i int, @"".j int) ()
type @"".Mode uint
func @"".PrintError(@"".w @"io".Writer, @"".err error) ()
const @"".ScanComments @"".Mode = 0x1
type @"".Scanner struct { @"".file *@"go/token".File; @"".dir string; @"".src []byte; @"".err @"".ErrorHandler; @"".mode @"".Mode; @"".ch rune; @"".offset int; @"".rdOffset int; @"".lineOffset int; @"".insertSemi bool; @"".ErrorCount int }
func (? *@"".Scanner) @"".Init(@"".file *@"go/token".File, @"".src []byte, @"".err @"".ErrorHandler, @"".mode @"".Mode) ()
func (? *@"".Scanner) @"".Scan() (@"".pos @"go/token".Pos, @"".tok @"go/token".Token, @"".lit string)
func (? *@"".Scanner) @"".error(@"".offs int, @"".msg string) ()
func (? *@"".Scanner) @"".findLineEnd() (? bool)
func (? *@"".Scanner) @"".interpretLineComment(@"".text []byte) ()
func (? *@"".Scanner) @"".next() ()
func (? *@"".Scanner) @"".scanChar() (? string)
func (? *@"".Scanner) @"".scanComment() (? string)
func (? *@"".Scanner) @"".scanEscape(@"".quote rune) ()
func (? *@"".Scanner) @"".scanIdentifier() (? string)
func (? *@"".Scanner) @"".scanMantissa(@"".base int) ()
func (? *@"".Scanner) @"".scanNumber(@"".seenDecimalPoint bool) (? @"go/token".Token, ? string)
func (? *@"".Scanner) @"".scanRawString() (? string)
func (? *@"".Scanner) @"".scanString() (? string)
func (? *@"".Scanner) @"".skipWhitespace() ()
func (? *@"".Scanner) @"".switch2(@"".tok0 @"go/token".Token, @"".tok1 @"go/token".Token) (? @"go/token".Token)
func (? *@"".Scanner) @"".switch3(@"".tok0 @"go/token".Token, @"".tok1 @"go/token".Token, @"".ch2 rune, @"".tok2 @"go/token".Token) (? @"go/token".Token)
func (? *@"".Scanner) @"".switch4(@"".tok0 @"go/token".Token, @"".tok1 @"go/token".Token, @"".ch2 rune, @"".tok2 @"go/token".Token, @"".tok3 @"go/token".Token) (? @"go/token".Token)
type @"go/token".Position struct { @"go/token".Filename string; @"go/token".Offset int; @"go/token".Line int; @"go/token".Column int }
func (? @"go/token".Position) @"go/token".String() (? string)
func (? *@"go/token".Position) @"go/token".IsValid() (? bool)
func (? *@"go/token".Position) @"go/token".String() (? string)
type @"io".Writer interface { @"io".Write(@"io".p []byte) (@"io".n int, @"io".err error) }
type @"go/token".File struct { @"go/token".set *@"go/token".FileSet; @"go/token".name string; @"go/token".base int; @"go/token".size int; @"go/token".lines []int; @"go/token".infos []@"go/token".lineInfo }
func (? *@"go/token".File) @"go/token".AddLine(@"go/token".offset int) ()
func (? *@"go/token".File) @"go/token".AddLineInfo(@"go/token".offset int, @"go/token".filename string, @"go/token".line int) ()
func (? *@"go/token".File) @"go/token".Base() (? int)
func (? *@"go/token".File) @"go/token".Line(@"go/token".p @"go/token".Pos) (? int)
func (? *@"go/token".File) @"go/token".LineCount() (? int)
func (? *@"go/token".File) @"go/token".MergeLine(@"go/token".line int) ()
func (? *@"go/token".File) @"go/token".Name() (? string)
func (? *@"go/token".File) @"go/token".Offset(@"go/token".p @"go/token".Pos) (? int)
func (? *@"go/token".File) @"go/token".Pos(@"go/token".offset int) (? @"go/token".Pos)
func (? *@"go/token".File) @"go/token".Position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
func (? *@"go/token".File) @"go/token".SetLines(@"go/token".lines []int) (? bool)
func (? *@"go/token".File) @"go/token".SetLinesForContent(@"go/token".content []byte) ()
func (? *@"go/token".File) @"go/token".Size() (? int)
func (? *@"go/token".File) @"go/token".info(@"go/token".offset int) (@"go/token".filename string, @"go/token".line int, @"go/token".column int)
func (? *@"go/token".File) @"go/token".position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
type @"go/token".Pos int
func (? @"go/token".Pos) @"go/token".IsValid() (? bool)
func (? *@"go/token".Pos) @"go/token".IsValid() (? bool)
type @"go/token".Token int
func (? @"go/token".Token) @"go/token".IsKeyword() (? bool)
func (? @"go/token".Token) @"go/token".IsLiteral() (? bool)
func (? @"go/token".Token) @"go/token".IsOperator() (? bool)
func (? @"go/token".Token) @"go/token".Precedence() (? int)
func (? @"go/token".Token) @"go/token".String() (? string)
func (? *@"go/token".Token) @"go/token".IsKeyword() (? bool)
func (? *@"go/token".Token) @"go/token".IsLiteral() (? bool)
func (? *@"go/token".Token) @"go/token".IsOperator() (? bool)
func (? *@"go/token".Token) @"go/token".Precedence() (? int)
func (? *@"go/token".Token) @"go/token".String() (? string)
import sync "sync"
type @"go/token".FileSet struct { @"go/token".mutex @"sync".RWMutex; @"go/token".base int; @"go/token".files []*@"go/token".File; @"go/token".last *@"go/token".File }
func (? *@"go/token".FileSet) @"go/token".AddFile(@"go/token".filename string, @"go/token".base int, @"go/token".size int) (? *@"go/token".File)
func (? *@"go/token".FileSet) @"go/token".Base() (? int)
func (? *@"go/token".FileSet) @"go/token".File(@"go/token".p @"go/token".Pos) (@"go/token".f *@"go/token".File)
func (? *@"go/token".FileSet) @"go/token".Iterate(@"go/token".f func (? *@"go/token".File) (? bool)) ()
func (? *@"go/token".FileSet) @"go/token".Position(@"go/token".p @"go/token".Pos) (@"go/token".pos @"go/token".Position)
func (? *@"go/token".FileSet) @"go/token".Read(@"go/token".decode func (? interface {  }) (? error)) (? error)
func (? *@"go/token".FileSet) @"go/token".Write(@"go/token".encode func (? interface {  }) (? error)) (? error)
func (? *@"go/token".FileSet) @"go/token".file(@"go/token".p @"go/token".Pos) (? *@"go/token".File)
type @"go/token".lineInfo struct { @"go/token".Offset int; @"go/token".Filename string; @"go/token".Line int }
type @"sync".RWMutex struct { @"sync".w @"sync".Mutex; @"sync".writerSem uint32; @"sync".readerSem uint32; @"sync".readerCount int32; @"sync".readerWait int32 }
func (? *@"sync".RWMutex) @"sync".Lock() ()
func (? *@"sync".RWMutex) @"sync".RLock() ()
func (? *@"sync".RWMutex) @"sync".RLocker() (? @"sync".Locker)
func (? *@"sync".RWMutex) @"sync".RUnlock() ()
func (? *@"sync".RWMutex) @"sync".Unlock() ()
type @"sync".Mutex struct { @"sync".state int32; @"sync".sema uint32 }
func (? *@"sync".Mutex) @"sync".Lock() ()
func (? *@"sync".Mutex) @"sync".Unlock() ()
type @"sync".Locker interface { @"sync".Lock() (); @"sync".Unlock() () }
$$
0Å™runtimeerrorssync/atomicsynciounicodeunicode/utf8bytesmathsyscalltimeosstrconvreflectfmtsortgo/tokenstringspath/filepath
go/scanner0Å†0
fmtfmt0go/tokentoken0ioio0sortsort0bytesbytes0path/filepathfilepath0strconvstrconv0unicodeunicode0unicode/utf8utf80ÇÜç0ÇErrorÅ˙	Error = go$pkg.Error = go$newType(0, "Struct", "scanner.Error", "Error", "go/scanner", function(Pos_, Msg_) {
		this.go$val = this;
		this.Pos = Pos_ !== undefined ? Pos_ : new token.Position.Ptr();
		this.Msg = Msg_ !== undefined ? Msg_ : "";
	});
ÅÁ		Error.methods = [["Error", "", [], [Go$String], false, -1]];
		(go$ptrType(Error)).methods = [["Error", "", [], [Go$String], false, -1]];
		Error.init([["Pos", "Pos", "", token.Position, ""], ["Msg", "Msg", "", Go$String, ""]]);
0Error0go/token:Position0Çù	ErrorListn	ErrorList = go$pkg.ErrorList = go$newType(0, "Slice", "scanner.ErrorList", "ErrorList", "go/scanner", null);
ÇÍ		ErrorList.methods = [["Err", "", [], [go$error], false, -1], ["Error", "", [], [Go$String], false, -1], ["Len", "", [], [Go$Int], false, -1], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false, -1], ["Sort", "", [], [], false, -1], ["Swap", "", [Go$Int, Go$Int], [], false, -1]];
		(go$ptrType(ErrorList)).methods = [["Add", "", [token.Position, Go$String], [], false, -1], ["Err", "", [], [go$error], false, -1], ["Error", "", [], [Go$String], false, -1], ["Len", "", [], [Go$Int], false, -1], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false, -1], ["RemoveMultiples", "", [], [], false, -1], ["Reset", "", [], [], false, -1], ["Sort", "", [], [], false, -1], ["Swap", "", [Go$Int, Go$Int], [], false, -1]];
		ErrorList.init((go$ptrType(Error)));
0	ErrorList0%go/scanner:Errorgo/token:Position0ÅÌErrorHandlery	ErrorHandler = go$pkg.ErrorHandler = go$newType(0, "Func", "scanner.ErrorHandler", "ErrorHandler", "go/scanner", null);
=		ErrorHandler.init([token.Position, Go$String], [], false);
0ErrorHandler0go/token:Position0Ç6ScannerÇu	Scanner = go$pkg.Scanner = go$newType(0, "Struct", "scanner.Scanner", "Scanner", "go/scanner", function(file_, dir_, src_, err_, mode_, ch_, offset_, rdOffset_, lineOffset_, insertSemi_, ErrorCount_) {
		this.go$val = this;
		this.file = file_ !== undefined ? file_ : (go$ptrType(token.File)).nil;
		this.dir = dir_ !== undefined ? dir_ : "";
		this.src = src_ !== undefined ? src_ : (go$sliceType(Go$Uint8)).nil;
		this.err = err_ !== undefined ? err_ : go$throwNilPointerError;
		this.mode = mode_ !== undefined ? mode_ : 0;
		this.ch = ch_ !== undefined ? ch_ : 0;
		this.offset = offset_ !== undefined ? offset_ : 0;
		this.rdOffset = rdOffset_ !== undefined ? rdOffset_ : 0;
		this.lineOffset = lineOffset_ !== undefined ? lineOffset_ : 0;
		this.insertSemi = insertSemi_ !== undefined ? insertSemi_ : false;
		this.ErrorCount = ErrorCount_ !== undefined ? ErrorCount_ : 0;
	});
ÇL		(go$ptrType(Scanner)).methods = [["Init", "", [(go$ptrType(token.File)), (go$sliceType(Go$Uint8)), ErrorHandler, Mode], [], false, -1], ["Scan", "", [], [token.Pos, token.Token, Go$String], false, -1], ["error", "go/scanner", [Go$Int, Go$String], [], false, -1], ["findLineEnd", "go/scanner", [], [Go$Bool], false, -1], ["interpretLineComment", "go/scanner", [(go$sliceType(Go$Uint8))], [], false, -1], ["next", "go/scanner", [], [], false, -1], ["scanChar", "go/scanner", [], [Go$String], false, -1], ["scanComment", "go/scanner", [], [Go$String], false, -1], ["scanEscape", "go/scanner", [Go$Int32], [], false, -1], ["scanIdentifier", "go/scanner", [], [Go$String], false, -1], ["scanMantissa", "go/scanner", [Go$Int], [], false, -1], ["scanNumber", "go/scanner", [Go$Bool], [token.Token, Go$String], false, -1], ["scanRawString", "go/scanner", [], [Go$String], false, -1], ["scanString", "go/scanner", [], [Go$String], false, -1], ["skipWhitespace", "go/scanner", [], [], false, -1], ["switch2", "go/scanner", [token.Token, token.Token], [token.Token], false, -1], ["switch3", "go/scanner", [token.Token, token.Token, Go$Int32, token.Token], [token.Token], false, -1], ["switch4", "go/scanner", [token.Token, token.Token, Go$Int32, token.Token, token.Token], [token.Token], false, -1]];
		Scanner.init([["file", "file", "go/scanner", (go$ptrType(token.File)), ""], ["dir", "dir", "go/scanner", Go$String, ""], ["src", "src", "go/scanner", (go$sliceType(Go$Uint8)), ""], ["err", "err", "go/scanner", ErrorHandler, ""], ["mode", "mode", "go/scanner", Mode, ""], ["ch", "ch", "go/scanner", Go$Int32, ""], ["offset", "offset", "go/scanner", Go$Int, ""], ["rdOffset", "rdOffset", "go/scanner", Go$Int, ""], ["lineOffset", "lineOffset", "go/scanner", Go$Int, ""], ["insertSemi", "insertSemi", "go/scanner", Go$Bool, ""], ["ErrorCount", "ErrorCount", "", Go$Int, ""]]);
0	Scanner0Wgo/scanner:ErrorHandlergo/scanner:Modego/token:Filego/token:Posgo/token:Token0mModeY	Mode = go$pkg.Mode = go$newType(4, "Uint", "scanner.Mode", "Mode", "go/scanner", null);
 0Mode0 0ÇÈ Ç±	Error.Ptr.prototype.Error = function() {
		var _struct, _struct$1, e;
		e = (_struct = this, new Error.Ptr((_struct$1 = _struct.Pos, new token.Position.Ptr(_struct$1.Filename, _struct$1.Offset, _struct$1.Line, _struct$1.Column)), _struct.Msg));
		if (!(e.Pos.Filename === "") || e.Pos.IsValid()) {
			return e.Pos.String() + ": " + e.Msg;
		}
		return e.Msg;
	};
	Error.prototype.Error = function() { return this.go$val.Error(); };
 0Error0%go/scanner:Errorgo/token:Position0ÇÈ Çó	go$ptrType(ErrorList).prototype.Add = function(pos, msg) {
		var p, _struct;
		p = this;
		p.go$set(go$append(p.go$get(), new Error.Ptr((_struct = pos, new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column)), msg)));
	};
	ErrorList.prototype.Add = function(pos, msg) { var obj = this; return (new (go$ptrType(ErrorList))(function() { return obj; }, null)).Add(pos, msg); };
 0	ErrorList0;go/scanner:Errorgo/scanner:ErrorListgo/token:Position0Ç6 Ç		go$ptrType(ErrorList).prototype.Reset = function() {
		var p;
		p = this;
		p.go$set(go$subslice((p.go$get()), 0, 0));
	};
	ErrorList.prototype.Reset = function() { var obj = this; return (new (go$ptrType(ErrorList))(function() { return obj; }, null)).Reset(); };
 0	ErrorList0go/scanner:ErrorList0Å” Åß	ErrorList.prototype.Len = function() {
		var p;
		p = this;
		return p.length;
	};
	go$ptrType(ErrorList).prototype.Len = function() { return this.go$get().Len(); };
 0	ErrorList0go/scanner:ErrorList0Ç’ Ç®	ErrorList.prototype.Swap = function(i, j) {
		var p, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		p = this;
		_tuple = [(_slice = p, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = p, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = p, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = p, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(ErrorList).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0	ErrorList0go/scanner:ErrorList0Ç) Ç¸	ErrorList.prototype.Less = function(i, j) {
		var p, _slice, _index, e, _slice$1, _index$1, f;
		p = this;
		e = (_slice = p, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Pos;
		f = (_slice$1 = p, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Pos;
		if (e.Filename < f.Filename) {
			return true;
		}
		if (e.Filename === f.Filename) {
			if (e.Line < f.Line) {
				return true;
			}
			if (e.Line === f.Line) {
				return e.Column < f.Column;
			}
		}
		return false;
	};
	go$ptrType(ErrorList).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0	ErrorList0go/scanner:ErrorList0Åﬁ Åß	ErrorList.prototype.Sort = function() {
		var p;
		p = this;
		sort.Sort(p);
	};
	go$ptrType(ErrorList).prototype.Sort = function() { return this.go$get().Sort(); };
 0	ErrorList0!go/scanner:ErrorList	sort:Sort0Çr Ç'	go$ptrType(ErrorList).prototype.RemoveMultiples = function() {
		var p, last, i, _ref, _i, _slice, _index, e, _struct, _slice$1, _index$1;
		p = this;
		sort.Sort(p);
		last = new token.Position.Ptr();
		i = 0;
		_ref = p.go$get();
		_i = 0;
		while (_i < _ref.length) {
			e = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!(e.Pos.Filename === last.Filename) || !((e.Pos.Line === last.Line))) {
				last = (_struct = e.Pos, new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column));
				_slice$1 = p.go$get(), _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = e) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
			}
			_i++;
		}
		p.go$set(go$subslice((p.go$get()), 0, i));
	};
	ErrorList.prototype.RemoveMultiples = function() { var obj = this; return (new (go$ptrType(ErrorList))(function() { return obj; }, null)).RemoveMultiples(); };
 0	ErrorList04go/scanner:ErrorListgo/token:Position	sort:Sort0Ç& ÇÏ	ErrorList.prototype.Error = function() {
		var p, _ref, _slice, _index, _slice$1, _index$1;
		p = this;
		_ref = p.length;
		if (_ref === 0) {
			return "no errors";
		} else if (_ref === 1) {
			return (_slice = p, _index = 0, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Error();
		}
		return fmt.Sprintf("%s (and %d more errors)", new (go$sliceType(go$emptyInterface))([(_slice$1 = p, _index$1 = 0, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")), new Go$Int((p.length - 1 >> 0))]));
	};
	go$ptrType(ErrorList).prototype.Error = function() { return this.go$get().Error(); };
 0	ErrorList0#fmt:Sprintfgo/scanner:ErrorList0Å¯ ÅÃ	ErrorList.prototype.Err = function() {
		var p;
		p = this;
		if (p.length === 0) {
			return null;
		}
		return p;
	};
	go$ptrType(ErrorList).prototype.Err = function() { return this.go$get().Err(); };
 0	ErrorList0go/scanner:ErrorList0Ç˝
PrintErrorÇ∏	PrintError = go$pkg.PrintError = function(w, err) {
		var _tuple, list, ok, _ref, _i, _slice, _index, e;
		_tuple = (err !== null && err.constructor === ErrorList ? [err.go$val, true] : [ErrorList.nil, false]), list = _tuple[0], ok = _tuple[1];
		if (ok) {
			_ref = list;
			_i = 0;
			while (_i < _ref.length) {
				e = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				fmt.Fprintf(w, "%s\n", new (go$sliceType(go$emptyInterface))([e]));
				_i++;
			}
		} else if (!(go$interfaceIsEqual(err, null))) {
			fmt.Fprintf(w, "%s\n", new (go$sliceType(go$emptyInterface))([err]));
		}
	};
 0
PrintError0#fmt:Fprintfgo/scanner:ErrorList0Çø Çe	Scanner.Ptr.prototype.next = function() {
		var s, _slice, _index, _tuple, r, w, _tuple$1;
		s = this;
		if (s.rdOffset < s.src.length) {
			s.offset = s.rdOffset;
			if (s.ch === 10) {
				s.lineOffset = s.offset;
				s.file.AddLine(s.offset);
			}
			_tuple = [((_slice = s.src, _index = s.rdOffset, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")) >> 0), 1], r = _tuple[0], w = _tuple[1];
			if (r === 0) {
				s.error(s.offset, "illegal character NUL");
			} else if (r >= 128) {
				_tuple$1 = utf8.DecodeRune(go$subslice(s.src, s.rdOffset)), r = _tuple$1[0], w = _tuple$1[1];
				if ((r === 65533) && (w === 1)) {
					s.error(s.offset, "illegal UTF-8 encoding");
				} else if ((r === 65279) && s.offset > 0) {
					s.error(s.offset, "illegal byte order mark");
				}
			}
			s.rdOffset = s.rdOffset + (w) >> 0;
			s.ch = r;
		} else {
			s.offset = s.src.length;
			if (s.ch === 10) {
				s.lineOffset = s.offset;
				s.file.AddLine(s.offset);
			}
			s.ch = -1;
		}
	};
	Scanner.prototype.next = function() { return this.go$val.next(); };
 0Scannernext0?go/scanner:Scannergo/scanner:errorunicode/utf8:DecodeRune0Ç, Ç–	Scanner.Ptr.prototype.Init = function(file, src, err, mode) {
		var s, _tuple;
		s = this;
		if (!((file.Size() === src.length))) {
			throw go$panic(new Go$String(fmt.Sprintf("file size (%d) does not match src len (%d)", new (go$sliceType(go$emptyInterface))([new Go$Int(file.Size()), new Go$Int(src.length)]))));
		}
		s.file = file;
		_tuple = filepath.Split(file.Name()), s.dir = _tuple[0];
		s.src = src;
		s.err = err;
		s.mode = mode;
		s.ch = 32;
		s.offset = 0;
		s.rdOffset = 0;
		s.lineOffset = 0;
		s.insertSemi = false;
		s.ErrorCount = 0;
		s.next();
		if (s.ch === 65279) {
			s.next();
		}
	};
	Scanner.prototype.Init = function(file, src, err, mode) { return this.go$val.Init(file, src, err, mode); };
 0	Scanner0Gfmt:Sprintfgo/scanner:Scannergo/scanner:nextpath/filepath:Split0Ç„ Ç†	Scanner.Ptr.prototype.error = function(offs, msg) {
		var s, _struct;
		s = this;
		if (!(s.err === go$throwNilPointerError)) {
			s.err((_struct = s.file.Position(s.file.Pos(offs)), new token.Position.Ptr(_struct.Filename, _struct.Offset, _struct.Line, _struct.Column)), msg);
		}
		s.ErrorCount = s.ErrorCount + 1 >> 0;
	};
	Scanner.prototype.error = function(offs, msg) { return this.go$val.error(offs, msg); };
 0Scannererror0'go/scanner:Scannergo/token:Position0Ç  Ç?	Scanner.Ptr.prototype.interpretLineComment = function(text) {
		var s, i, _tuple, line, err, filename;
		s = this;
		if (bytes.HasPrefix(text, prefix)) {
			i = bytes.LastIndex(text, new (go$sliceType(Go$Uint8))([58]));
			if (i > 0) {
				_tuple = strconv.Atoi(go$bytesToString(go$subslice(text, (i + 1 >> 0)))), line = _tuple[0], err = _tuple[1];
				if (go$interfaceIsEqual(err, null) && line > 0) {
					filename = filepath.Clean(go$bytesToString(go$subslice(text, prefix.length, i)));
					if (!filepath.IsAbs(filename)) {
						filename = filepath.Join(new (go$sliceType(Go$String))([s.dir, filename]));
					}
					s.file.AddLineInfo((s.lineOffset + text.length >> 0) + 1 >> 0, filename, line);
				}
			}
		}
	};
	Scanner.prototype.interpretLineComment = function(text) { return this.go$val.interpretLineComment(text); };
 0ScannerinterpretLineComment0Åïbytes:HasPrefixbytes:LastIndexgo/scanner:Scannergo/scanner:prefixpath/filepath:Cleanpath/filepath:IsAbspath/filepath:Joinstrconv:Atoi0Çë Ç	Scanner.Ptr.prototype.scanComment = function() {
		var go$this = this, s, offs, hasCR, ch, lit;
		/* */ var go$s = 0, go$f = function() { while (true) { switch (go$s) { case 0:
		s = go$this;
		offs = s.offset - 1 >> 0;
		hasCR = false;
		/* if (s.ch === 47) { */ if (s.ch === 47) {} else { go$s = 2; continue; }
			s.next();
			while (!((s.ch === 10)) && s.ch >= 0) {
				if (s.ch === 13) {
					hasCR = true;
				}
				s.next();
			}
			if (offs === s.lineOffset) {
				s.interpretLineComment(go$subslice(s.src, offs, s.offset));
			}
			/* goto exit */ go$s = 1; continue;
		/* } */ case 2:
		s.next();
		/* while (s.ch >= 0) { */ case 3: if(!(s.ch >= 0)) { go$s = 4; continue; }
			ch = s.ch;
			if (ch === 13) {
				hasCR = true;
			}
			s.next();
			/* if ((ch === 42) && (s.ch === 47)) { */ if ((ch === 42) && (s.ch === 47)) {} else { go$s = 5; continue; }
				s.next();
				/* goto exit */ go$s = 1; continue;
			/* } */ case 5:
		/* } */ go$s = 3; continue; case 4:
		s.error(offs, "comment not terminated");
		/* exit: */ case 1:
		lit = go$subslice(s.src, offs, s.offset);
		if (hasCR) {
			lit = stripCR(lit);
		}
		return go$bytesToString(lit);
		/* */ } break; } }; return go$f();
	};
	Scanner.prototype.scanComment = function() { return this.go$val.scanComment(); };
 0ScannerscanComment0lgo/scanner:Scannergo/scanner:errorgo/scanner:interpretLineCommentgo/scanner:nextgo/scanner:stripCR0Ç	 Çß	Scanner.Ptr.prototype.findLineEnd = function() {
		var s, ch;
		var go$deferred = [];
		try {
			s = this;
			go$deferred.push({ fun: (function(offs) {
				s.ch = 47;
				s.offset = offs;
				s.rdOffset = offs + 1 >> 0;
				s.next();
			}), args: [s.offset - 1 >> 0] });
			while ((s.ch === 47) || (s.ch === 42)) {
				if (s.ch === 47) {
					return true;
				}
				s.next();
				while (s.ch >= 0) {
					ch = s.ch;
					if (ch === 10) {
						return true;
					}
					s.next();
					if ((ch === 42) && (s.ch === 47)) {
						s.next();
						break;
					}
				}
				s.skipWhitespace();
				if (s.ch < 0 || (s.ch === 10)) {
					return true;
				}
				if (!((s.ch === 47))) {
					return false;
				}
				s.next();
			}
			return false;
		} catch(go$err) {
			go$pushErr(go$err);
			return false;
		} finally {
			go$callDeferred(go$deferred);
		}
	};
	Scanner.prototype.findLineEnd = function() { return this.go$val.findLineEnd(); };
 0ScannerfindLineEnd0@go/scanner:Scannergo/scanner:nextgo/scanner:skipWhitespace0Å∫isLetterÅã	isLetter = function(ch) {
		return 97 <= ch && ch <= 122 || 65 <= ch && ch <= 90 || (ch === 95) || ch >= 128 && unicode.IsLetter(ch);
	};
 0
isLetter0unicode:IsLetter0ÅåisDigita	isDigit = function(ch) {
		return 48 <= ch && ch <= 57 || ch >= 128 && unicode.IsDigit(ch);
	};
 0	isDigit0unicode:IsDigit0ÇØ Ç<	Scanner.Ptr.prototype.scanIdentifier = function() {
		var s, offs;
		s = this;
		offs = s.offset;
		while (isLetter(s.ch) || isDigit(s.ch)) {
			s.next();
		}
		return go$bytesToString(go$subslice(s.src, offs, s.offset));
	};
	Scanner.prototype.scanIdentifier = function() { return this.go$val.scanIdentifier(); };
 0ScannerscanIdentifier0Ngo/scanner:Scannergo/scanner:isDigitgo/scanner:isLettergo/scanner:next0Ç2digitValÇ	digitVal = function(ch) {
		if (48 <= ch && ch <= 57) {
			return ((ch - 48 >> 0) >> 0);
		} else if (97 <= ch && ch <= 102) {
			return (((ch - 97 >> 0) + 10 >> 0) >> 0);
		} else if (65 <= ch && ch <= 70) {
			return (((ch - 65 >> 0) + 10 >> 0) >> 0);
		}
		return 16;
	};
 0
digitVal0 0Ç< Å‡	Scanner.Ptr.prototype.scanMantissa = function(base) {
		var s;
		s = this;
		while (digitVal(s.ch) < base) {
			s.next();
		}
	};
	Scanner.prototype.scanMantissa = function(base) { return this.go$val.scanMantissa(base); };
 0ScannerscanMantissa0:go/scanner:Scannergo/scanner:digitValgo/scanner:next0Çc ÇÚ	Scanner.Ptr.prototype.scanNumber = function(seenDecimalPoint) {
		var go$this = this, s, offs, tok, offs$1, seenDecimalDigit;
		/* */ var go$s = 0, go$f = function() { while (true) { switch (go$s) { case 0:
		s = go$this;
		offs = s.offset;
		tok = 5;
		/* if (seenDecimalPoint) { */ if (seenDecimalPoint) {} else { go$s = 4; continue; }
			offs = offs - 1 >> 0;
			tok = 6;
			s.scanMantissa(10);
			/* goto exponent */ go$s = 1; continue;
		/* } */ case 4:
		/* if (s.ch === 48) { */ if (s.ch === 48) {} else { go$s = 5; continue; }
			offs$1 = s.offset;
			s.next();
			/* if ((s.ch === 120) || (s.ch === 88)) { */ if ((s.ch === 120) || (s.ch === 88)) {} else { go$s = 6; continue; }
				s.next();
				s.scanMantissa(16);
				if ((s.offset - offs$1 >> 0) <= 2) {
					s.error(offs$1, "illegal hexadecimal number");
				}
			/* } else { */ go$s = 7; continue; case 6: 
				seenDecimalDigit = false;
				s.scanMantissa(8);
				if ((s.ch === 56) || (s.ch === 57)) {
					seenDecimalDigit = true;
					s.scanMantissa(10);
				}
				/* if ((s.ch === 46) || (s.ch === 101) || (s.ch === 69) || (s.ch === 105)) { */ if ((s.ch === 46) || (s.ch === 101) || (s.ch === 69) || (s.ch === 105)) {} else { go$s = 8; continue; }
					/* goto fraction */ go$s = 2; continue;
				/* } */ case 8:
				if (seenDecimalDigit) {
					s.error(offs$1, "illegal octal number");
				}
			/* } */ case 7:
			/* goto exit */ go$s = 3; continue;
		/* } */ case 5:
		s.scanMantissa(10);
		/* fraction: */ case 2:
		if (s.ch === 46) {
			tok = 6;
			s.next();
			s.scanMantissa(10);
		}
		/* exponent: */ case 1:
		if ((s.ch === 101) || (s.ch === 69)) {
			tok = 6;
			s.next();
			if ((s.ch === 45) || (s.ch === 43)) {
				s.next();
			}
			s.scanMantissa(10);
		}
		if (s.ch === 105) {
			tok = 7;
			s.next();
		}
		/* exit: */ case 3:
		return [tok, go$bytesToString(go$subslice(s.src, offs, s.offset))];
		/* */ } break; } }; return go$f();
	};
	Scanner.prototype.scanNumber = function(seenDecimalPoint) { return this.go$val.scanNumber(seenDecimalPoint); };
 0Scanner
scanNumber0Pgo/scanner:Scannergo/scanner:errorgo/scanner:nextgo/scanner:scanMantissa0Ç5 Ç»	Scanner.Ptr.prototype.scanEscape = function(quote) {
		var s, offs, _tuple, i, base, max, _ref, _tuple$1, _tuple$2, _tuple$3, _tuple$4, x, d;
		s = this;
		offs = s.offset;
		_tuple = [0, 0, 0], i = _tuple[0], base = _tuple[1], max = _tuple[2];
		_ref = s.ch;
		if (_ref === 97 || _ref === 98 || _ref === 102 || _ref === 110 || _ref === 114 || _ref === 116 || _ref === 118 || _ref === 92 || _ref === quote) {
			s.next();
			return;
		} else if (_ref === 48 || _ref === 49 || _ref === 50 || _ref === 51 || _ref === 52 || _ref === 53 || _ref === 54 || _ref === 55) {
			_tuple$1 = [3, 8, 255], i = _tuple$1[0], base = _tuple$1[1], max = _tuple$1[2];
		} else if (_ref === 120) {
			s.next();
			_tuple$2 = [2, 16, 255], i = _tuple$2[0], base = _tuple$2[1], max = _tuple$2[2];
		} else if (_ref === 117) {
			s.next();
			_tuple$3 = [4, 16, 1114111], i = _tuple$3[0], base = _tuple$3[1], max = _tuple$3[2];
		} else if (_ref === 85) {
			s.next();
			_tuple$4 = [8, 16, 1114111], i = _tuple$4[0], base = _tuple$4[1], max = _tuple$4[2];
		} else {
			s.next();
			s.error(offs, "unknown escape sequence");
			return;
		}
		x = 0;
		while (i > 0 && !((s.ch === quote)) && s.ch >= 0) {
			d = (digitVal(s.ch) >>> 0);
			if (d >= base) {
				s.error(s.offset, "illegal character in escape sequence");
				break;
			}
			x = ((((x >>> 16 << 16) * base >>> 0) + (x << 16 >>> 16) * base) >>> 0) + d >>> 0;
			s.next();
			i = i - 1 >>> 0;
		}
		while (i > 0 && !((s.ch === quote)) && s.ch >= 0) {
			s.next();
			i = i - 1 >>> 0;
		}
		if (x > max || 55296 <= x && x < 57344) {
			s.error(offs, "escape sequence is invalid Unicode code point");
		}
	};
	Scanner.prototype.scanEscape = function(quote) { return this.go$val.scanEscape(quote); };
 0Scanner
scanEscape0Lgo/scanner:Scannergo/scanner:digitValgo/scanner:errorgo/scanner:next0Ç∏ ÇK	Scanner.Ptr.prototype.scanChar = function() {
		var s, offs, n, ch;
		s = this;
		offs = s.offset - 1 >> 0;
		n = 0;
		while (!((s.ch === 39))) {
			ch = s.ch;
			n = n + 1 >> 0;
			s.next();
			if ((ch === 10) || ch < 0) {
				s.error(offs, "character literal not terminated");
				n = 1;
				break;
			}
			if (ch === 92) {
				s.scanEscape(39);
			}
		}
		s.next();
		if (!((n === 1))) {
			s.error(offs, "illegal character literal");
		}
		return go$bytesToString(go$subslice(s.src, offs, s.offset));
	};
	Scanner.prototype.scanChar = function() { return this.go$val.scanChar(); };
 0ScannerscanChar0Ngo/scanner:Scannergo/scanner:errorgo/scanner:nextgo/scanner:scanEscape0ÇB Ç”	Scanner.Ptr.prototype.scanString = function() {
		var s, offs, ch;
		s = this;
		offs = s.offset - 1 >> 0;
		while (!((s.ch === 34))) {
			ch = s.ch;
			s.next();
			if ((ch === 10) || ch < 0) {
				s.error(offs, "string not terminated");
				break;
			}
			if (ch === 92) {
				s.scanEscape(34);
			}
		}
		s.next();
		return go$bytesToString(go$subslice(s.src, offs, s.offset));
	};
	Scanner.prototype.scanString = function() { return this.go$val.scanString(); };
 0Scanner
scanString0Ngo/scanner:Scannergo/scanner:errorgo/scanner:nextgo/scanner:scanEscape0Ç∞stripCRÇî	stripCR = function(b) {
		var c, i, _ref, _i, _slice, _index, ch, _slice$1, _index$1;
		c = (go$sliceType(Go$Uint8)).make(b.length, 0, function() { return 0; });
		i = 0;
		_ref = b;
		_i = 0;
		while (_i < _ref.length) {
			ch = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			if (!((ch === 13))) {
				_slice$1 = c, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = ch) : go$throwRuntimeError("index out of range");
				i = i + 1 >> 0;
			}
			_i++;
		}
		return go$subslice(c, 0, i);
	};
 0	stripCR0 0Çå Ç	Scanner.Ptr.prototype.scanRawString = function() {
		var s, offs, hasCR, ch, lit;
		s = this;
		offs = s.offset - 1 >> 0;
		hasCR = false;
		while (!((s.ch === 96))) {
			ch = s.ch;
			s.next();
			if (ch === 13) {
				hasCR = true;
			}
			if (ch < 0) {
				s.error(offs, "string not terminated");
				break;
			}
		}
		s.next();
		lit = go$subslice(s.src, offs, s.offset);
		if (hasCR) {
			lit = stripCR(lit);
		}
		return go$bytesToString(lit);
	};
	Scanner.prototype.scanRawString = function() { return this.go$val.scanRawString(); };
 0ScannerscanRawString0Kgo/scanner:Scannergo/scanner:errorgo/scanner:nextgo/scanner:stripCR0Ç_ Ç	Scanner.Ptr.prototype.skipWhitespace = function() {
		var s;
		s = this;
		while ((s.ch === 32) || (s.ch === 9) || (s.ch === 10) && !s.insertSemi || (s.ch === 13)) {
			s.next();
		}
	};
	Scanner.prototype.skipWhitespace = function() { return this.go$val.skipWhitespace(); };
 0ScannerskipWhitespace0%go/scanner:Scannergo/scanner:next0Ç7 Åı	Scanner.Ptr.prototype.switch2 = function(tok0, tok1) {
		var s;
		s = this;
		if (s.ch === 61) {
			s.next();
			return tok1;
		}
		return tok0;
	};
	Scanner.prototype.switch2 = function(tok0, tok1) { return this.go$val.switch2(tok0, tok1); };
 0Scannerswitch20%go/scanner:Scannergo/scanner:next0Çê ÇM	Scanner.Ptr.prototype.switch3 = function(tok0, tok1, ch2, tok2) {
		var s;
		s = this;
		if (s.ch === 61) {
			s.next();
			return tok1;
		}
		if (s.ch === ch2) {
			s.next();
			return tok2;
		}
		return tok0;
	};
	Scanner.prototype.switch3 = function(tok0, tok1, ch2, tok2) { return this.go$val.switch3(tok0, tok1, ch2, tok2); };
 0Scannerswitch30%go/scanner:Scannergo/scanner:next0Ç‹ Çô	Scanner.Ptr.prototype.switch4 = function(tok0, tok1, ch2, tok2, tok3) {
		var s;
		s = this;
		if (s.ch === 61) {
			s.next();
			return tok1;
		}
		if (s.ch === ch2) {
			s.next();
			if (s.ch === 61) {
				s.next();
				return tok3;
			}
			return tok2;
		}
		return tok0;
	};
	Scanner.prototype.switch4 = function(tok0, tok1, ch2, tok2, tok3) { return this.go$val.switch4(tok0, tok1, ch2, tok2, tok3); };
 0Scannerswitch40%go/scanner:Scannergo/scanner:next0ÇF Ç∆	Scanner.Ptr.prototype.Scan = function() {
		var go$this = this, pos, tok, lit, s, insertSemi, ch, _ref, _tuple, _ref$1, _tuple$1, _tuple$2, _tuple$3, _tuple$4;
		pos = 0;
		tok = 0;
		lit = "";
		/* */ var go$s = 0, go$f = function() { while (true) { switch (go$s) { case 0:
		s = go$this;
		/* scanAgain: */ case 1:
		s.skipWhitespace();
		pos = s.file.Pos(s.offset);
		insertSemi = false;
		ch = s.ch;
		/* if (isLetter(ch)) { */ if (isLetter(ch)) {} else if (48 <= ch && ch <= 57) { go$s = 2; continue; } else { go$s = 3; continue; }
			lit = s.scanIdentifier();
			if (lit.length > 1) {
				tok = token.Lookup(lit);
				_ref = tok;
				if (_ref === 4 || _ref === 61 || _ref === 65 || _ref === 69 || _ref === 80) {
					insertSemi = true;
				}
			} else {
				insertSemi = true;
				tok = 4;
			}
		/* } else if (48 <= ch && ch <= 57) { */ go$s = 4; continue; case 2: 
			insertSemi = true;
			_tuple = s.scanNumber(false), tok = _tuple[0], lit = _tuple[1];
		/* } else { */ go$s = 4; continue; case 3: 
			s.next();
			_ref$1 = ch;
			/* if (_ref$1 === -1) { */ if (_ref$1 === -1) {} else if (_ref$1 === 10) { go$s = 5; continue; } else if (_ref$1 === 34) { go$s = 6; continue; } else if (_ref$1 === 39) { go$s = 7; continue; } else if (_ref$1 === 96) { go$s = 8; continue; } else if (_ref$1 === 58) { go$s = 9; continue; } else if (_ref$1 === 46) { go$s = 10; continue; } else if (_ref$1 === 44) { go$s = 11; continue; } else if (_ref$1 === 59) { go$s = 12; continue; } else if (_ref$1 === 40) { go$s = 13; continue; } else if (_ref$1 === 41) { go$s = 14; continue; } else if (_ref$1 === 91) { go$s = 15; continue; } else if (_ref$1 === 93) { go$s = 16; continue; } else if (_ref$1 === 123) { go$s = 17; continue; } else if (_ref$1 === 125) { go$s = 18; continue; } else if (_ref$1 === 43) { go$s = 19; continue; } else if (_ref$1 === 45) { go$s = 20; continue; } else if (_ref$1 === 42) { go$s = 21; continue; } else if (_ref$1 === 47) { go$s = 22; continue; } else if (_ref$1 === 37) { go$s = 23; continue; } else if (_ref$1 === 94) { go$s = 24; continue; } else if (_ref$1 === 60) { go$s = 25; continue; } else if (_ref$1 === 62) { go$s = 26; continue; } else if (_ref$1 === 61) { go$s = 27; continue; } else if (_ref$1 === 33) { go$s = 28; continue; } else if (_ref$1 === 38) { go$s = 29; continue; } else if (_ref$1 === 124) { go$s = 30; continue; } else { go$s = 31; continue; }
				if (s.insertSemi) {
					s.insertSemi = false;
					_tuple$1 = [pos, 57, "\n"], pos = _tuple$1[0], tok = _tuple$1[1], lit = _tuple$1[2];
					return [pos, tok, lit];
				}
				tok = 1;
			/* } else if (_ref$1 === 10) { */ go$s = 32; continue; case 5: 
				s.insertSemi = false;
				_tuple$2 = [pos, 57, "\n"], pos = _tuple$2[0], tok = _tuple$2[1], lit = _tuple$2[2];
				return [pos, tok, lit];
			/* } else if (_ref$1 === 34) { */ go$s = 32; continue; case 6: 
				insertSemi = true;
				tok = 9;
				lit = s.scanString();
			/* } else if (_ref$1 === 39) { */ go$s = 32; continue; case 7: 
				insertSemi = true;
				tok = 8;
				lit = s.scanChar();
			/* } else if (_ref$1 === 96) { */ go$s = 32; continue; case 8: 
				insertSemi = true;
				tok = 9;
				lit = s.scanRawString();
			/* } else if (_ref$1 === 58) { */ go$s = 32; continue; case 9: 
				tok = s.switch2(58, 47);
			/* } else if (_ref$1 === 46) { */ go$s = 32; continue; case 10: 
				if (48 <= s.ch && s.ch <= 57) {
					insertSemi = true;
					_tuple$3 = s.scanNumber(true), tok = _tuple$3[0], lit = _tuple$3[1];
				} else if (s.ch === 46) {
					s.next();
					if (s.ch === 46) {
						s.next();
						tok = 48;
					}
				} else {
					tok = 53;
				}
			/* } else if (_ref$1 === 44) { */ go$s = 32; continue; case 11: 
				tok = 52;
			/* } else if (_ref$1 === 59) { */ go$s = 32; continue; case 12: 
				tok = 57;
				lit = ";";
			/* } else if (_ref$1 === 40) { */ go$s = 32; continue; case 13: 
				tok = 49;
			/* } else if (_ref$1 === 41) { */ go$s = 32; continue; case 14: 
				insertSemi = true;
				tok = 54;
			/* } else if (_ref$1 === 91) { */ go$s = 32; continue; case 15: 
				tok = 50;
			/* } else if (_ref$1 === 93) { */ go$s = 32; continue; case 16: 
				insertSemi = true;
				tok = 55;
			/* } else if (_ref$1 === 123) { */ go$s = 32; continue; case 17: 
				tok = 51;
			/* } else if (_ref$1 === 125) { */ go$s = 32; continue; case 18: 
				insertSemi = true;
				tok = 56;
			/* } else if (_ref$1 === 43) { */ go$s = 32; continue; case 19: 
				tok = s.switch3(12, 23, 43, 37);
				if (tok === 37) {
					insertSemi = true;
				}
			/* } else if (_ref$1 === 45) { */ go$s = 32; continue; case 20: 
				tok = s.switch3(13, 24, 45, 38);
				if (tok === 38) {
					insertSemi = true;
				}
			/* } else if (_ref$1 === 42) { */ go$s = 32; continue; case 21: 
				tok = s.switch2(14, 25);
			/* } else if (_ref$1 === 47) { */ go$s = 32; continue; case 22: 
				/* if ((s.ch === 47) || (s.ch === 42)) { */ if ((s.ch === 47) || (s.ch === 42)) {} else { go$s = 33; continue; }
					if (s.insertSemi && s.findLineEnd()) {
						s.ch = 47;
						s.offset = s.file.Offset(pos);
						s.rdOffset = s.offset + 1 >> 0;
						s.insertSemi = false;
						_tuple$4 = [pos, 57, "\n"], pos = _tuple$4[0], tok = _tuple$4[1], lit = _tuple$4[2];
						return [pos, tok, lit];
					}
					lit = s.scanComment();
					/* if (((s.mode & 1) >>> 0) === 0) { */ if (((s.mode & 1) >>> 0) === 0) {} else { go$s = 35; continue; }
						s.insertSemi = false;
						/* goto scanAgain */ go$s = 1; continue;
					/* } */ case 35:
					tok = 2;
				/* } else { */ go$s = 34; continue; case 33: 
					tok = s.switch2(15, 26);
				/* } */ case 34:
			/* } else if (_ref$1 === 37) { */ go$s = 32; continue; case 23: 
				tok = s.switch2(16, 27);
			/* } else if (_ref$1 === 94) { */ go$s = 32; continue; case 24: 
				tok = s.switch2(19, 30);
			/* } else if (_ref$1 === 60) { */ go$s = 32; continue; case 25: 
				if (s.ch === 45) {
					s.next();
					tok = 36;
				} else {
					tok = s.switch4(40, 45, 60, 20, 31);
				}
			/* } else if (_ref$1 === 62) { */ go$s = 32; continue; case 26: 
				tok = s.switch4(41, 46, 62, 21, 32);
			/* } else if (_ref$1 === 61) { */ go$s = 32; continue; case 27: 
				tok = s.switch2(42, 39);
			/* } else if (_ref$1 === 33) { */ go$s = 32; continue; case 28: 
				tok = s.switch2(43, 44);
			/* } else if (_ref$1 === 38) { */ go$s = 32; continue; case 29: 
				if (s.ch === 94) {
					s.next();
					tok = s.switch2(22, 33);
				} else {
					tok = s.switch3(17, 28, 38, 34);
				}
			/* } else if (_ref$1 === 124) { */ go$s = 32; continue; case 30: 
				tok = s.switch3(18, 29, 124, 35);
			/* } else { */ go$s = 32; continue; case 31: 
				if (!((ch === 65279))) {
					s.error(s.file.Offset(pos), fmt.Sprintf("illegal character %#U", new (go$sliceType(go$emptyInterface))([new Go$Int32(ch)])));
				}
				insertSemi = s.insertSemi;
				tok = 0;
				lit = go$encodeRune(ch);
			/* } */ case 32:
		/* } */ case 4:
		if (((s.mode & 2) >>> 0) === 0) {
			s.insertSemi = insertSemi;
		}
		return [pos, tok, lit];
		/* */ } break; } }; return go$f();
	};
	Scanner.prototype.Scan = function() { return this.go$val.Scan(); };
 0	Scanner0Çifmt:Sprintfgo/scanner:Scannergo/scanner:errorgo/scanner:findLineEndgo/scanner:isLettergo/scanner:nextgo/scanner:scanChargo/scanner:scanCommentgo/scanner:scanIdentifiergo/scanner:scanNumbergo/scanner:scanRawStringgo/scanner:scanStringgo/scanner:skipWhitespacego/scanner:switch2go/scanner:switch3go/scanner:switch4go/token:Lookup0prefix  0prefix0 0k  F		prefix = new (go$sliceType(Go$Uint8))(go$stringToBytes("//line "));
0prefix0go/scanner:prefix0
   0 0 0
   0 0 0 