0‚†\path/filepath‚&package filepath
import errors "errors"
import os "os"
import runtime "runtime"
import sort "sort"
import strings "strings"
import utf8 "unicode/utf8"
import bytes "bytes"
func @"".Abs(@"".path string) (? string, ? error)
func @"".Base(@"".path string) (? string)
func @"".Clean(@"".path string) (? string)
func @"".Dir(@"".path string) (? string)
var @"".ErrBadPattern error
func @"".EvalSymlinks(@"".path string) (? string, ? error)
func @"".Ext(@"".path string) (? string)
func @"".FromSlash(@"".path string) (? string)
func @"".Glob(@"".pattern string) (@"".matches []string, @"".err error)
func @"".HasPrefix(@"".p string, @"".prefix string) (? bool)
func @"".IsAbs(@"".path string) (? bool)
func @"".Join(@"".elem ...string) (? string)
const @"".ListSeparator = '\u003a'
func @"".Match(@"".pattern string, @"".name string) (@"".matched bool, @"".err error)
func @"".Rel(@"".basepath string, @"".targpath string) (? string, ? error)
const @"".Separator = '\u002f'
var @"".SkipDir error
func @"".Split(@"".path string) (@"".dir string, @"".file string)
func @"".SplitList(@"".path string) (? []string)
func @"".ToSlash(@"".path string) (? string)
func @"".VolumeName(@"".path string) (@"".v string)
func @"".Walk(@"".root string, @"".walkFn @"".WalkFunc) (? error)
type @"".WalkFunc func (@"".path string, @"".info @"os".FileInfo, @"".err error) (? error)
type @"".byName []@"os".FileInfo
func (? @"".byName) @"".Len() (? int)
func (? @"".byName) @"".Less(@"".i int, @"".j int) (? bool)
func (? @"".byName) @"".Swap(@"".i int, @"".j int) ()
func (? *@"".byName) @"".Len() (? int)
func (? *@"".byName) @"".Less(@"".i int, @"".j int) (? bool)
func (? *@"".byName) @"".Swap(@"".i int, @"".j int) ()
type @"".lazybuf struct { @"".path string; @"".buf []byte; @"".w int; @"".volAndPath string; @"".volLen int }
func (? *@"".lazybuf) @"".append(@"".c byte) ()
func (? *@"".lazybuf) @"".index(@"".i int) (? byte)
func (? *@"".lazybuf) @"".string() (? string)
import time "time"
type @"os".FileInfo interface { @"os".IsDir() (? bool); @"os".ModTime() (? @"time".Time); @"os".Mode() (? @"os".FileMode); @"os".Name() (? string); @"os".Size() (? int64); @"os".Sys() (? interface {  }) }
type @"time".Time struct { @"time".sec int64; @"time".nsec uintptr; @"time".loc *@"time".Location }
func (? @"time".Time) @"time".Add(@"time".d @"time".Duration) (? @"time".Time)
func (? @"time".Time) @"time".AddDate(@"time".years int, @"time".months int, @"time".days int) (? @"time".Time)
func (? @"time".Time) @"time".After(@"time".u @"time".Time) (? bool)
func (? @"time".Time) @"time".Before(@"time".u @"time".Time) (? bool)
func (? @"time".Time) @"time".Clock() (@"time".hour int, @"time".min int, @"time".sec int)
func (? @"time".Time) @"time".Date() (@"time".year int, @"time".month @"time".Month, @"time".day int)
func (? @"time".Time) @"time".Day() (? int)
func (? @"time".Time) @"time".Equal(@"time".u @"time".Time) (? bool)
func (? @"time".Time) @"time".Format(@"time".layout string) (? string)
func (? @"time".Time) @"time".GobEncode() (? []byte, ? error)
func (? @"time".Time) @"time".Hour() (? int)
func (? @"time".Time) @"time".ISOWeek() (@"time".year int, @"time".week int)
func (? @"time".Time) @"time".In(@"time".loc *@"time".Location) (? @"time".Time)
func (? @"time".Time) @"time".IsZero() (? bool)
func (? @"time".Time) @"time".Local() (? @"time".Time)
func (? @"time".Time) @"time".Location() (? *@"time".Location)
func (? @"time".Time) @"time".MarshalBinary() (? []byte, ? error)
func (? @"time".Time) @"time".MarshalJSON() (? []byte, ? error)
func (? @"time".Time) @"time".MarshalText() (? []byte, ? error)
func (? @"time".Time) @"time".Minute() (? int)
func (? @"time".Time) @"time".Month() (? @"time".Month)
func (? @"time".Time) @"time".Nanosecond() (? int)
func (? @"time".Time) @"time".Round(@"time".d @"time".Duration) (? @"time".Time)
func (? @"time".Time) @"time".Second() (? int)
func (? @"time".Time) @"time".String() (? string)
func (? @"time".Time) @"time".Sub(@"time".u @"time".Time) (? @"time".Duration)
func (? @"time".Time) @"time".Truncate(@"time".d @"time".Duration) (? @"time".Time)
func (? @"time".Time) @"time".UTC() (? @"time".Time)
func (? @"time".Time) @"time".Unix() (? int64)
func (? @"time".Time) @"time".UnixNano() (? int64)
func (? @"time".Time) @"time".Weekday() (? @"time".Weekday)
func (? @"time".Time) @"time".Year() (? int)
func (? @"time".Time) @"time".YearDay() (? int)
func (? @"time".Time) @"time".Zone() (@"time".name string, @"time".offset int)
func (? @"time".Time) @"time".abs() (? uint64)
func (? @"time".Time) @"time".date(@"time".full bool) (@"time".year int, @"time".month @"time".Month, @"time".day int, @"time".yday int)
func (? @"time".Time) @"time".locabs() (@"time".name string, @"time".offset int, @"time".abs uint64)
func (? *@"time".Time) @"time".Add(@"time".d @"time".Duration) (? @"time".Time)
func (? *@"time".Time) @"time".AddDate(@"time".years int, @"time".months int, @"time".days int) (? @"time".Time)
func (? *@"time".Time) @"time".After(@"time".u @"time".Time) (? bool)
func (? *@"time".Time) @"time".Before(@"time".u @"time".Time) (? bool)
func (? *@"time".Time) @"time".Clock() (@"time".hour int, @"time".min int, @"time".sec int)
func (? *@"time".Time) @"time".Date() (@"time".year int, @"time".month @"time".Month, @"time".day int)
func (? *@"time".Time) @"time".Day() (? int)
func (? *@"time".Time) @"time".Equal(@"time".u @"time".Time) (? bool)
func (? *@"time".Time) @"time".Format(@"time".layout string) (? string)
func (? *@"time".Time) @"time".GobDecode(@"time".data []byte) (? error)
func (? *@"time".Time) @"time".GobEncode() (? []byte, ? error)
func (? *@"time".Time) @"time".Hour() (? int)
func (? *@"time".Time) @"time".ISOWeek() (@"time".year int, @"time".week int)
func (? *@"time".Time) @"time".In(@"time".loc *@"time".Location) (? @"time".Time)
func (? *@"time".Time) @"time".IsZero() (? bool)
func (? *@"time".Time) @"time".Local() (? @"time".Time)
func (? *@"time".Time) @"time".Location() (? *@"time".Location)
func (? *@"time".Time) @"time".MarshalBinary() (? []byte, ? error)
func (? *@"time".Time) @"time".MarshalJSON() (? []byte, ? error)
func (? *@"time".Time) @"time".MarshalText() (? []byte, ? error)
func (? *@"time".Time) @"time".Minute() (? int)
func (? *@"time".Time) @"time".Month() (? @"time".Month)
func (? *@"time".Time) @"time".Nanosecond() (? int)
func (? *@"time".Time) @"time".Round(@"time".d @"time".Duration) (? @"time".Time)
func (? *@"time".Time) @"time".Second() (? int)
func (? *@"time".Time) @"time".String() (? string)
func (? *@"time".Time) @"time".Sub(@"time".u @"time".Time) (? @"time".Duration)
func (? *@"time".Time) @"time".Truncate(@"time".d @"time".Duration) (? @"time".Time)
func (? *@"time".Time) @"time".UTC() (? @"time".Time)
func (? *@"time".Time) @"time".Unix() (? int64)
func (? *@"time".Time) @"time".UnixNano() (? int64)
func (? *@"time".Time) @"time".UnmarshalBinary(@"time".data []byte) (? error)
func (? *@"time".Time) @"time".UnmarshalJSON(@"time".data []byte) (@"time".err error)
func (? *@"time".Time) @"time".UnmarshalText(@"time".data []byte) (@"time".err error)
func (? *@"time".Time) @"time".Weekday() (? @"time".Weekday)
func (? *@"time".Time) @"time".Year() (? int)
func (? *@"time".Time) @"time".YearDay() (? int)
func (? *@"time".Time) @"time".Zone() (@"time".name string, @"time".offset int)
func (? *@"time".Time) @"time".abs() (? uint64)
func (? *@"time".Time) @"time".date(@"time".full bool) (@"time".year int, @"time".month @"time".Month, @"time".day int, @"time".yday int)
func (? *@"time".Time) @"time".locabs() (@"time".name string, @"time".offset int, @"time".abs uint64)
type @"os".FileMode uint32
func (? @"os".FileMode) @"os".IsDir() (? bool)
func (? @"os".FileMode) @"os".IsRegular() (? bool)
func (? @"os".FileMode) @"os".Perm() (? @"os".FileMode)
func (? @"os".FileMode) @"os".String() (? string)
func (? *@"os".FileMode) @"os".IsDir() (? bool)
func (? *@"os".FileMode) @"os".IsRegular() (? bool)
func (? *@"os".FileMode) @"os".Perm() (? @"os".FileMode)
func (? *@"os".FileMode) @"os".String() (? string)
type @"time".Location struct { @"time".name string; @"time".zone []@"time".zone; @"time".tx []@"time".zoneTrans; @"time".cacheStart int64; @"time".cacheEnd int64; @"time".cacheZone *@"time".zone }
func (? *@"time".Location) @"time".String() (? string)
func (? *@"time".Location) @"time".get() (? *@"time".Location)
func (? *@"time".Location) @"time".lookup(@"time".sec int64) (@"time".name string, @"time".offset int, @"time".isDST bool, @"time".start int64, @"time".end int64)
func (? *@"time".Location) @"time".lookupName(@"time".name string, @"time".unix int64) (@"time".offset int, @"time".isDST bool, @"time".ok bool)
type @"time".Duration int64
func (? @"time".Duration) @"time".Hours() (? float64)
func (? @"time".Duration) @"time".Minutes() (? float64)
func (? @"time".Duration) @"time".Nanoseconds() (? int64)
func (? @"time".Duration) @"time".Seconds() (? float64)
func (? @"time".Duration) @"time".String() (? string)
func (? *@"time".Duration) @"time".Hours() (? float64)
func (? *@"time".Duration) @"time".Minutes() (? float64)
func (? *@"time".Duration) @"time".Nanoseconds() (? int64)
func (? *@"time".Duration) @"time".Seconds() (? float64)
func (? *@"time".Duration) @"time".String() (? string)
type @"time".Month int
func (? @"time".Month) @"time".String() (? string)
func (? *@"time".Month) @"time".String() (? string)
type @"time".Weekday int
func (? @"time".Weekday) @"time".String() (? string)
func (? *@"time".Weekday) @"time".String() (? string)
type @"time".zone struct { @"time".name string; @"time".offset int; @"time".isDST bool }
type @"time".zoneTrans struct { @"time".when int64; @"time".index uint8; @"time".isstd bool; @"time".isutc bool }
$$
0wruntimeerrorssync/atomicsynciounicodeunicode/utf8bytessyscalltimeossortstringspath/filepath0x0errorserrors0osos0runtimeruntime0sortsort0stringsstrings0unicode/utf8utf80bytesbytes0‚_@0‚ lazybuf‚Å	lazybuf = go$pkg.lazybuf = go$newType(0, "Struct", "filepath.lazybuf", "lazybuf", "path/filepath", function(path_, buf_, w_, volAndPath_, volLen_) {
		this.go$val = this;
		this.path = path_ !== undefined ? path_ : "";
		this.buf = buf_ !== undefined ? buf_ : (go$sliceType(Go$Uint8)).nil;
		this.w = w_ !== undefined ? w_ : 0;
		this.volAndPath = volAndPath_ !== undefined ? volAndPath_ : "";
		this.volLen = volLen_ !== undefined ? volLen_ : 0;
	});
‚·		lazybuf.init([["path", "path/filepath", Go$String, ""], ["buf", "path/filepath", (go$sliceType(Go$Uint8)), ""], ["w", "path/filepath", Go$Int, ""], ["volAndPath", "path/filepath", Go$String, ""], ["volLen", "path/filepath", Go$Int, ""]]);
		(go$ptrType(lazybuf)).methods = [["append", "path/filepath", [Go$Uint8], [], false], ["index", "path/filepath", [Go$Int], [Go$Uint8], false], ["string", "path/filepath", [], [Go$String], false]];
0Å WalkFuncm	WalkFunc = go$pkg.WalkFunc = go$newType(0, "Func", "filepath.WalkFunc", "WalkFunc", "path/filepath", null);
H		WalkFunc.init([Go$String, os.FileInfo, go$error], [go$error], false);
0‚È byNamef	byName = go$pkg.byName = go$newType(0, "Slice", "filepath.byName", "byName", "path/filepath", null);
‚R		byName.init(os.FileInfo);
		byName.methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
		(go$ptrType(byName)).methods = [["Len", "", [], [Go$Int], false], ["Less", "", [Go$Int, Go$Int], [Go$Bool], false], ["Swap", "", [Go$Int, Go$Int], [], false]];
0    0    0H   @		go$pkg.ErrBadPattern = errors.New("syntax error in pattern");
0>   6		go$pkg.SkipDir = errors.New("skip this directory");
0‚˜ Match‚‰	Match = go$pkg.Match = function(pattern, name) {
		var matched, err, star, chunk, _tuple, _tuple$1, _tuple$2, t, ok, err$1, _tuple$3, i, _tuple$4, t$1, ok$1, err$2, _tuple$5, _tuple$6, _tuple$7;
		matched = false;
		err = null;
		Pattern:
		while (pattern.length > 0) {
			star = false;
			chunk = "";
			_tuple = scanChunk(pattern), star = _tuple[0], chunk = _tuple[1], pattern = _tuple[2];
			if (star && chunk === "") {
				_tuple$1 = [strings.Index(name, "/") < 0, null], matched = _tuple$1[0], err = _tuple$1[1];
				return [matched, err];
			}
			_tuple$2 = matchChunk(chunk, name), t = _tuple$2[0], ok = _tuple$2[1], err$1 = _tuple$2[2];
			if (ok && ((t.length === 0) || pattern.length > 0)) {
				name = t;
				continue;
			}
			if (!(go$interfaceIsEqual(err$1, null))) {
				_tuple$3 = [false, err$1], matched = _tuple$3[0], err = _tuple$3[1];
				return [matched, err];
			}
			if (star) {
				i = 0;
				while (i < name.length && !((name.charCodeAt(i) === 47))) {
					_tuple$4 = matchChunk(chunk, name.substring((i + 1 >> 0))), t$1 = _tuple$4[0], ok$1 = _tuple$4[1], err$2 = _tuple$4[2];
					if (ok$1) {
						if ((pattern.length === 0) && t$1.length > 0) {
							i = i + 1 >> 0;
							continue;
						}
						name = t$1;
						continue Pattern;
					}
					if (!(go$interfaceIsEqual(err$2, null))) {
						_tuple$5 = [false, err$2], matched = _tuple$5[0], err = _tuple$5[1];
						return [matched, err];
					}
					i = i + 1 >> 0;
				}
			}
			_tuple$6 = [false, null], matched = _tuple$6[0], err = _tuple$6[1];
			return [matched, err];
		}
		_tuple$7 = [name.length === 0, null], matched = _tuple$7[0], err = _tuple$7[1];
		return [matched, err];
	};
 0‚3 	scanChunk‚ 	scanChunk = function(pattern) {
		var star, chunk, rest, inrange, i, _ref, _tuple;
		star = false;
		chunk = "";
		rest = "";
		while (pattern.length > 0 && (pattern.charCodeAt(0) === 42)) {
			pattern = pattern.substring(1);
			star = true;
		}
		inrange = false;
		i = 0;
		i = 0;
		Scan:
		while (i < pattern.length) {
			_ref = pattern.charCodeAt(i);
			if (_ref === 92) {
				if ((i + 1 >> 0) < pattern.length) {
					i = i + 1 >> 0;
				}
			} else if (_ref === 91) {
				inrange = true;
			} else if (_ref === 93) {
				inrange = false;
			} else if (_ref === 42) {
				if (!inrange) {
					break Scan;
				}
			}
			i = i + 1 >> 0;
		}
		_tuple = [star, pattern.substring(0, i), pattern.substring(i)], star = _tuple[0], chunk = _tuple[1], rest = _tuple[2];
		return [star, chunk, rest];
	};
 0‚	 
matchChunk‚ò	matchChunk = function(chunk, s) {
		var rest, ok, err, _ref, _tuple, r, n, negated, match, nrange, _tuple$1, lo, hi, _tuple$2, _tuple$3, _tuple$4, n$1, _tuple$5;
		rest = "";
		ok = false;
		err = null;
		while (chunk.length > 0) {
			if (s.length === 0) {
				return [rest, ok, err];
			}
			_ref = chunk.charCodeAt(0);
			if (_ref === 91) {
				_tuple = utf8.DecodeRuneInString(s), r = _tuple[0], n = _tuple[1];
				s = s.substring(n);
				chunk = chunk.substring(1);
				if (chunk.length === 0) {
					err = go$pkg.ErrBadPattern;
					return [rest, ok, err];
				}
				negated = chunk.charCodeAt(0) === 94;
				if (negated) {
					chunk = chunk.substring(1);
				}
				match = false;
				nrange = 0;
				while (true) {
					if (chunk.length > 0 && (chunk.charCodeAt(0) === 93) && nrange > 0) {
						chunk = chunk.substring(1);
						break;
					}
					_tuple$1 = [0, 0], lo = _tuple$1[0], hi = _tuple$1[1];
					if (_tuple$2 = getEsc(chunk), lo = _tuple$2[0], chunk = _tuple$2[1], err = _tuple$2[2], !(go$interfaceIsEqual(err, null))) {
						return [rest, ok, err];
					}
					hi = lo;
					if (chunk.charCodeAt(0) === 45) {
						if (_tuple$3 = getEsc(chunk.substring(1)), hi = _tuple$3[0], chunk = _tuple$3[1], err = _tuple$3[2], !(go$interfaceIsEqual(err, null))) {
							return [rest, ok, err];
						}
					}
					if (lo <= r && r <= hi) {
						match = true;
					}
					nrange = nrange + 1 >> 0;
				}
				if (match === negated) {
					return [rest, ok, err];
				}
			} else if (_ref === 63) {
				if (s.charCodeAt(0) === 47) {
					return [rest, ok, err];
				}
				_tuple$4 = utf8.DecodeRuneInString(s), n$1 = _tuple$4[1];
				s = s.substring(n$1);
				chunk = chunk.substring(1);
			} else if (_ref === 92) {
				chunk = chunk.substring(1);
				if (chunk.length === 0) {
					err = go$pkg.ErrBadPattern;
					return [rest, ok, err];
				}
				if (!((chunk.charCodeAt(0) === s.charCodeAt(0)))) {
					return [rest, ok, err];
				}
				s = s.substring(1);
				chunk = chunk.substring(1);
			} else {
				if (!((chunk.charCodeAt(0) === s.charCodeAt(0)))) {
					return [rest, ok, err];
				}
				s = s.substring(1);
				chunk = chunk.substring(1);
			}
		}
		_tuple$5 = [s, true, null], rest = _tuple$5[0], ok = _tuple$5[1], err = _tuple$5[2];
		return [rest, ok, err];
	};
 0‚Î getEsc‚¾	getEsc = function(chunk) {
		var r, nchunk, err, _tuple, n;
		r = 0;
		nchunk = "";
		err = null;
		if ((chunk.length === 0) || (chunk.charCodeAt(0) === 45) || (chunk.charCodeAt(0) === 93)) {
			err = go$pkg.ErrBadPattern;
			return [r, nchunk, err];
		}
		if ((chunk.charCodeAt(0) === 92) && true) {
			chunk = chunk.substring(1);
			if (chunk.length === 0) {
				err = go$pkg.ErrBadPattern;
				return [r, nchunk, err];
			}
		}
		_tuple = utf8.DecodeRuneInString(chunk), r = _tuple[0], n = _tuple[1];
		if ((r === 65533) && (n === 1)) {
			err = go$pkg.ErrBadPattern;
		}
		nchunk = chunk.substring(n);
		if (nchunk.length === 0) {
			err = go$pkg.ErrBadPattern;
		}
		return [r, nchunk, err];
	};
 0‚2 Glob‚$	Glob = go$pkg.Glob = function(pattern) {
		var matches, err, _tuple, _tuple$1, _tuple$2, _tuple$3, dir, file, _ref, _tuple$4, m, _tuple$5, _ref$1, _i, _slice, _index, d, _tuple$6;
		matches = (go$sliceType(Go$String)).nil;
		err = null;
		if (!hasMeta(pattern)) {
			if (_tuple = os.Stat(pattern), err = _tuple[1], !(go$interfaceIsEqual(err, null))) {
				_tuple$1 = [(go$sliceType(Go$String)).nil, null], matches = _tuple$1[0], err = _tuple$1[1];
				return [matches, err];
			}
			_tuple$2 = [new (go$sliceType(Go$String))([pattern]), null], matches = _tuple$2[0], err = _tuple$2[1];
			return [matches, err];
		}
		_tuple$3 = Split(pattern), dir = _tuple$3[0], file = _tuple$3[1];
		_ref = dir;
		if (_ref === "") {
			dir = ".";
		} else if (_ref === "/") {
		} else {
			dir = dir.substring(0, (dir.length - 1 >> 0));
		}
		if (!hasMeta(dir)) {
			_tuple$4 = glob(dir, file, (go$sliceType(Go$String)).nil), matches = _tuple$4[0], err = _tuple$4[1];
			return [matches, err];
		}
		m = (go$sliceType(Go$String)).nil;
		_tuple$5 = Glob(dir), m = _tuple$5[0], err = _tuple$5[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [matches, err];
		}
		_ref$1 = m;
		_i = 0;
		while (_i < _ref$1.length) {
			d = (_slice = _ref$1, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			_tuple$6 = glob(d, file, matches), matches = _tuple$6[0], err = _tuple$6[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [matches, err];
			}
			_i++;
		}
		return [matches, err];
	};
 0‚Ï glob‚Á	glob = function(dir, pattern, matches) {
		var m, e, _tuple, fi, err, _tuple$1, d, _tuple$2, names, _ref, _i, _slice, _index, n, _tuple$3, matched, err$1, _tuple$4;
		m = (go$sliceType(Go$String)).nil;
		e = null;
		var go$deferred = [];
		try {
			m = matches;
			_tuple = os.Stat(dir), fi = _tuple[0], err = _tuple[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [m, e];
			}
			if (!fi.IsDir()) {
				return [m, e];
			}
			_tuple$1 = os.Open(dir), d = _tuple$1[0], err = _tuple$1[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [m, e];
			}
			go$deferred.push({ recv: d, method: "Close", args: [] });
			_tuple$2 = d.Readdirnames(-1), names = _tuple$2[0], err = _tuple$2[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return [m, e];
			}
			sort.Strings(names);
			_ref = names;
			_i = 0;
			while (_i < _ref.length) {
				n = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
				_tuple$3 = Match(pattern, n), matched = _tuple$3[0], err$1 = _tuple$3[1];
				if (!(go$interfaceIsEqual(err$1, null))) {
					_tuple$4 = [m, err$1], m = _tuple$4[0], e = _tuple$4[1];
					return [m, e];
				}
				if (matched) {
					m = go$append(m, Join(new (go$sliceType(Go$String))([dir, n])));
				}
				_i++;
			}
			return [m, e];
		} catch(go$err) {
			go$pushErr(go$err);
		} finally {
			go$callDeferred(go$deferred);
			return [m, e];
		}
	};
 0\ hasMetaM	hasMeta = function(path) {
		return strings.IndexAny(path, "*?[") >= 0;
	};
 0‚¤  ‚š	lazybuf.Ptr.prototype.index = function(i) {
		var b, _slice, _index;
		b = this;
		if (!(b.buf === (go$sliceType(Go$Uint8)).nil)) {
			return (_slice = b.buf, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
		}
		return b.path.charCodeAt(i);
	};
	lazybuf.prototype.index = function(i) { return this.go$val.index(i); };
 0‚‹  ‚	lazybuf.Ptr.prototype.append = function(c) {
		var b, _slice, _index;
		b = this;
		if (b.buf === (go$sliceType(Go$Uint8)).nil) {
			if (b.w < b.path.length && (b.path.charCodeAt(b.w) === c)) {
				b.w = b.w + 1 >> 0;
				return;
			}
			b.buf = (go$sliceType(Go$Uint8)).make(b.path.length, 0, function() { return 0; });
			go$copyString(b.buf, b.path.substring(0, b.w));
		}
		_slice = b.buf, _index = b.w, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = c) : go$throwRuntimeError("index out of range");
		b.w = b.w + 1 >> 0;
	};
	lazybuf.prototype.append = function(c) { return this.go$val.append(c); };
 0‚f  ‚\	lazybuf.Ptr.prototype.string = function() {
		var b;
		b = this;
		if (b.buf === (go$sliceType(Go$Uint8)).nil) {
			return b.volAndPath.substring(0, (b.volLen + b.w >> 0));
		}
		return b.volAndPath.substring(0, b.volLen) + go$bytesToString(go$subslice(b.buf, 0, b.w));
	};
	lazybuf.prototype.string = function() { return this.go$val.string(); };
 0‚Ê Clean‚»	Clean = go$pkg.Clean = function(path) {
		var originalPath, volLen, rooted, n, out, _tuple, r, dotdot, _tuple$1;
		originalPath = path;
		volLen = volumeNameLen(path);
		path = path.substring(volLen);
		if (path === "") {
			if (volLen > 1 && !((originalPath.charCodeAt(1) === 58))) {
				return FromSlash(originalPath);
			}
			return originalPath + ".";
		}
		rooted = os.IsPathSeparator(path.charCodeAt(0));
		n = path.length;
		out = new lazybuf.Ptr(path, (go$sliceType(Go$Uint8)).nil, 0, originalPath, volLen);
		_tuple = [0, 0], r = _tuple[0], dotdot = _tuple[1];
		if (rooted) {
			out.append(47);
			_tuple$1 = [1, 1], r = _tuple$1[0], dotdot = _tuple$1[1];
		}
		while (r < n) {
			if (os.IsPathSeparator(path.charCodeAt(r))) {
				r = r + 1 >> 0;
			} else if ((path.charCodeAt(r) === 46) && (((r + 1 >> 0) === n) || os.IsPathSeparator(path.charCodeAt((r + 1 >> 0))))) {
				r = r + 1 >> 0;
			} else if ((path.charCodeAt(r) === 46) && (path.charCodeAt((r + 1 >> 0)) === 46) && (((r + 2 >> 0) === n) || os.IsPathSeparator(path.charCodeAt((r + 2 >> 0))))) {
				r = r + 2 >> 0;
				if (out.w > dotdot) {
					out.w = out.w - 1 >> 0;
					while (out.w > dotdot && !os.IsPathSeparator(out.index(out.w))) {
						out.w = out.w - 1 >> 0;
					}
				} else if (!rooted) {
					if (out.w > 0) {
						out.append(47);
					}
					out.append(46);
					out.append(46);
					dotdot = out.w;
				}
			} else {
				if (rooted && !((out.w === 1)) || !rooted && !((out.w === 0))) {
					out.append(47);
				}
				while (r < n && !os.IsPathSeparator(path.charCodeAt(r))) {
					out.append(path.charCodeAt(r));
					r = r + 1 >> 0;
				}
			}
		}
		if (out.w === 0) {
			out.append(46);
		}
		return FromSlash(out.string());
	};
 0} ToSlashn	ToSlash = go$pkg.ToSlash = function(path) {
		return path;
		return strings.Replace(path, "/", "/", -1);
	};
 0ƒ 	FromSlashr	FromSlash = go$pkg.FromSlash = function(path) {
		return path;
		return strings.Replace(path, "/", "/", -1);
	};
 0` 	SplitListO	SplitList = go$pkg.SplitList = function(path) {
		return splitList(path);
	};
 0‚ Split‚€	Split = go$pkg.Split = function(path) {
		var dir, file, vol, i, _tuple;
		dir = "";
		file = "";
		vol = VolumeName(path);
		i = path.length - 1 >> 0;
		while (i >= vol.length && !os.IsPathSeparator(path.charCodeAt(i))) {
			i = i - 1 >> 0;
		}
		_tuple = [path.substring(0, (i + 1 >> 0)), path.substring((i + 1 >> 0))], dir = _tuple[0], file = _tuple[1];
		return [dir, file];
	};
 0‚² Join‚¤	Join = go$pkg.Join = function(elem) {
		var _ref, _i, _slice, _index, e, i;
		_ref = elem;
		_i = 0;
		while (_i < _ref.length) {
			e = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			i = _i;
			if (!(e === "")) {
				return Clean(strings.Join(go$subslice(elem, i), "/"));
			}
			_i++;
		}
		return "";
	};
 0‚ Ext÷	Ext = go$pkg.Ext = function(path) {
		var i;
		i = path.length - 1 >> 0;
		while (i >= 0 && !os.IsPathSeparator(path.charCodeAt(i))) {
			if (path.charCodeAt(i) === 46) {
				return path.substring(i);
			}
			i = i - 1 >> 0;
		}
		return "";
	};
 0l EvalSymlinksX	EvalSymlinks = go$pkg.EvalSymlinks = function(path) {
		return evalSymlinks(path);
	};
 0‚C Abs‚6	Abs = go$pkg.Abs = function(path) {
		var _tuple, wd, err;
		if (IsAbs(path)) {
			return [Clean(path), null];
		}
		_tuple = os.Getwd(), wd = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return ["", err];
		}
		return [Join(new (go$sliceType(Go$String))([wd, path])), null];
	};
 0‚	Ž Rel‚		Rel = go$pkg.Rel = function(basepath, targpath) {
		var baseVol, targVol, base, targ, baseSlashed, targSlashed, bl, tl, _tuple, b0, bi, t0, ti, seps, x, size, buf, n, i, _slice, _index, _slice$1, _index$1;
		baseVol = VolumeName(basepath);
		targVol = VolumeName(targpath);
		base = Clean(basepath);
		targ = Clean(targpath);
		if (targ === base) {
			return [".", null];
		}
		base = base.substring(baseVol.length);
		targ = targ.substring(targVol.length);
		if (base === ".") {
			base = "";
		}
		baseSlashed = base.length > 0 && (base.charCodeAt(0) === 47);
		targSlashed = targ.length > 0 && (targ.charCodeAt(0) === 47);
		if (!(baseSlashed === targSlashed) || !(baseVol === targVol)) {
			return ["", errors.New("Rel: can't make " + targ + " relative to " + base)];
		}
		bl = base.length;
		tl = targ.length;
		_tuple = [0, 0, 0, 0], b0 = _tuple[0], bi = _tuple[1], t0 = _tuple[2], ti = _tuple[3];
		while (true) {
			while (bi < bl && !((base.charCodeAt(bi) === 47))) {
				bi = bi + 1 >> 0;
			}
			while (ti < tl && !((targ.charCodeAt(ti) === 47))) {
				ti = ti + 1 >> 0;
			}
			if (!(targ.substring(t0, ti) === base.substring(b0, bi))) {
				break;
			}
			if (bi < bl) {
				bi = bi + 1 >> 0;
			}
			if (ti < tl) {
				ti = ti + 1 >> 0;
			}
			b0 = bi;
			t0 = ti;
		}
		if (base.substring(b0, bi) === "..") {
			return ["", errors.New("Rel: can't make " + targ + " relative to " + base)];
		}
		if (!((b0 === bl))) {
			seps = strings.Count(base.substring(b0, bl), "/");
			size = 2 + (x = 3, (((seps >>> 16 << 16) * x >> 0) + (seps << 16 >>> 16) * x) >> 0) >> 0;
			if (!((tl === t0))) {
				size = size + (((1 + tl >> 0) - t0 >> 0)) >> 0;
			}
			buf = (go$sliceType(Go$Uint8)).make(size, 0, function() { return 0; });
			n = go$copyString(buf, "..");
			i = 0;
			while (i < seps) {
				_slice = buf, _index = n, (_index >= 0 && _index < _slice.length) ? (_slice.array[_slice.offset + _index] = 47) : go$throwRuntimeError("index out of range");
				go$copyString(go$subslice(buf, (n + 1 >> 0)), "..");
				n = n + 3 >> 0;
				i = i + 1 >> 0;
			}
			if (!((t0 === tl))) {
				_slice$1 = buf, _index$1 = n, (_index$1 >= 0 && _index$1 < _slice$1.length) ? (_slice$1.array[_slice$1.offset + _index$1] = 47) : go$throwRuntimeError("index out of range");
				go$copyString(go$subslice(buf, (n + 1 >> 0)), targ.substring(t0));
			}
			return [go$bytesToString(buf), null];
		}
		return [targ.substring(t0), null];
	};
 0‚× walk‚É	walk = function(path, info, walkFn) {
		var err, _tuple, list, _ref, _i, _slice, _index, fileInfo;
		err = walkFn(path, info, null);
		if (!(go$interfaceIsEqual(err, null))) {
			if (info.IsDir() && go$interfaceIsEqual(err, go$pkg.SkipDir)) {
				return null;
			}
			return err;
		}
		if (!info.IsDir()) {
			return null;
		}
		_tuple = readDir(path), list = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return walkFn(path, info, err);
		}
		_ref = list;
		_i = 0;
		while (_i < _ref.length) {
			fileInfo = (_slice = _ref, _index = _i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range"));
			err = walk(Join(new (go$sliceType(Go$String))([path, fileInfo.Name()])), fileInfo, walkFn);
			if (!(go$interfaceIsEqual(err, null))) {
				if (!fileInfo.IsDir() || !(go$interfaceIsEqual(err, go$pkg.SkipDir))) {
					return err;
				}
			}
			_i++;
		}
		return null;
	};
 0‚ Walkÿ	Walk = go$pkg.Walk = function(root, walkFn) {
		var _tuple, info, err;
		_tuple = os.Lstat(root), info = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return walkFn(root, null, err);
		}
		return walk(root, info, walkFn);
	};
 0‚ readDir‚		readDir = function(dirname) {
		var _tuple, f, err, _tuple$1, list;
		_tuple = os.Open(dirname), f = _tuple[0], err = _tuple[1];
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(os.FileInfo)).nil, err];
		}
		_tuple$1 = f.Readdir(-1), list = _tuple$1[0], err = _tuple$1[1];
		f.Close();
		if (!(go$interfaceIsEqual(err, null))) {
			return [(go$sliceType(os.FileInfo)).nil, err];
		}
		sort.Sort(go$subslice(new byName(list.array), list.offset, list.offset + list.length));
		return [list, null];
	};
 0ª  ¡	byName.prototype.Len = function() {
		var f;
		f = this;
		return f.length;
	};
	go$ptrType(byName).prototype.Len = function() { return this.go$get().Len(); };
 0‚!  ‚	byName.prototype.Less = function(i, j) {
		var f, _slice, _index, _slice$1, _index$1;
		f = this;
		return (_slice = f, _index = i, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")).Name() < (_slice$1 = f, _index$1 = j, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range")).Name();
	};
	go$ptrType(byName).prototype.Less = function(i, j) { return this.go$get().Less(i, j); };
 0‚¬  ‚¢	byName.prototype.Swap = function(i, j) {
		var f, _slice, _index, _slice$1, _index$1, _tuple, _slice$2, _index$2, _slice$3, _index$3;
		f = this;
		_tuple = [(_slice = f, _index = j, (_index >= 0 && _index < _slice.length) ? _slice.array[_slice.offset + _index] : go$throwRuntimeError("index out of range")), (_slice$1 = f, _index$1 = i, (_index$1 >= 0 && _index$1 < _slice$1.length) ? _slice$1.array[_slice$1.offset + _index$1] : go$throwRuntimeError("index out of range"))], _slice$2 = f, _index$2 = i, (_index$2 >= 0 && _index$2 < _slice$2.length) ? (_slice$2.array[_slice$2.offset + _index$2] = _tuple[0]) : go$throwRuntimeError("index out of range"), _slice$3 = f, _index$3 = j, (_index$3 >= 0 && _index$3 < _slice$3.length) ? (_slice$3.array[_slice$3.offset + _index$3] = _tuple[1]) : go$throwRuntimeError("index out of range");
	};
	go$ptrType(byName).prototype.Swap = function(i, j) { return this.go$get().Swap(i, j); };
 0‚ Base‚	Base = go$pkg.Base = function(path) {
		var i;
		if (path === "") {
			return ".";
		}
		while (path.length > 0 && os.IsPathSeparator(path.charCodeAt((path.length - 1 >> 0)))) {
			path = path.substring(0, (path.length - 1 >> 0));
		}
		path = path.substring(VolumeName(path).length);
		i = path.length - 1 >> 0;
		while (i >= 0 && !os.IsPathSeparator(path.charCodeAt(i))) {
			i = i - 1 >> 0;
		}
		if (i >= 0) {
			path = path.substring((i + 1 >> 0));
		}
		if (path === "") {
			return "/";
		}
		return path;
	};
 0‚× Dir‚Ê	Dir = go$pkg.Dir = function(path) {
		var vol, i, dir, last;
		vol = VolumeName(path);
		i = path.length - 1 >> 0;
		while (i >= vol.length && !os.IsPathSeparator(path.charCodeAt(i))) {
			i = i - 1 >> 0;
		}
		dir = Clean(path.substring(vol.length, (i + 1 >> 0)));
		last = dir.length - 1 >> 0;
		if (last > 0 && os.IsPathSeparator(dir.charCodeAt(last))) {
			dir = dir.substring(0, last);
		}
		if (dir === "") {
			dir = ".";
		}
		return vol + dir;
	};
 0— 
VolumeName„	VolumeName = go$pkg.VolumeName = function(path) {
		var v;
		v = "";
		v = path.substring(0, volumeNameLen(path));
		return v;
	};
 0a IsAbsT	IsAbs = go$pkg.IsAbs = function(path) {
		return strings.HasPrefix(path, "/");
	};
 0G volumeNameLen2	volumeNameLen = function(path) {
		return 0;
	};
 0r 	HasPrefixa	HasPrefix = go$pkg.HasPrefix = function(p, prefix) {
		return strings.HasPrefix(p, prefix);
	};
 0 	splitList‹	splitList = function(path) {
		if (path === "") {
			return new (go$sliceType(Go$String))([]);
		}
		return strings.Split(path, ":");
	};
 0‚ evalSymlinks‚ò	evalSymlinks = function(path) {
		var originalPath, b, n, i, p, _tuple, _tuple$1, _tuple$2, fi, err, _tuple$3, dest;
		originalPath = path;
		b = new bytes.Buffer.Ptr();
		n = 0;
		while (!(path === "")) {
			if (n > 255) {
				return ["", errors.New("EvalSymlinks: too many links in " + originalPath)];
			}
			i = strings.IndexRune(path, 47);
			p = "";
			if (i === -1) {
				_tuple = [path, ""], p = _tuple[0], path = _tuple[1];
			} else {
				_tuple$1 = [path.substring(0, i), path.substring((i + 1 >> 0))], p = _tuple$1[0], path = _tuple$1[1];
			}
			if (p === "") {
				if (b.Len() === 0) {
					b.WriteRune(47);
				}
				n = n + 1 >> 0;
				continue;
			}
			_tuple$2 = os.Lstat(b.String() + p), fi = _tuple$2[0], err = _tuple$2[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return ["", err];
			}
			if (((fi.Mode() & 134217728) >>> 0) === 0) {
				b.WriteString(p);
				if (!(path === "")) {
					b.WriteRune(47);
				}
				n = n + 1 >> 0;
				continue;
			}
			_tuple$3 = os.Readlink(b.String() + p), dest = _tuple$3[0], err = _tuple$3[1];
			if (!(go$interfaceIsEqual(err, null))) {
				return ["", err];
			}
			if (IsAbs(dest)) {
				b.Reset();
			}
			path = dest + "/" + path;
			n = n + 1 >> 0;
		}
		return [Clean(b.String()), null];
	};
 0    0    0 