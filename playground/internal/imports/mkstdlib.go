//go:build generate
// +build generate

// mkstdlib generates the zstdlib.go file, containing the Go standard
// library API symbols. It's baked into the binary to avoid scanning
// GOPATH in the common case.
package main

import (
	"bufio"
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io"
	"io/ioutil"
	"log"
	"os"
	"path"
	"path/filepath"
	"regexp"
	"runtime"
	"sort"
	"strings"
)

var outputFlag = flag.String("output", "", "output file name without extension; if empty, then print to stdout")

func mustOpenAll(names ...string) []io.Reader {
	ff := []io.Reader{}
	for _, name := range names {
		f, err := os.Open(name)
		if err != nil {
			log.Fatal(err)
		}
		ff = append(ff, f)
	}
	return ff
}

func api(base string) string {
	return filepath.Join(runtime.GOROOT(), "api", base)
}

func goAPIs() []string {
	paths, err := filepath.Glob(filepath.Join(runtime.GOROOT(), "api", "go1.*.txt"))
	if err != nil {
		log.Fatalf("Failed to match Go API files: %s", err)
	}
	return paths
}

var sym = regexp.MustCompile(`^pkg (\S+).*?, (?:var|func|type|const) ([A-Z]\w*)`)

var skips = map[string]struct{}{
	// Skip syscall because it's really big and causes Maximum call stack size exceeded panic.
	// See https://github.com/gopherjs/gopherjs/issues/305.
	"syscall": {},
}

func main() {
	flag.Parse()

	var buf bytes.Buffer
	outf := func(format string, args ...interface{}) {
		fmt.Fprintf(&buf, format, args...)
	}
	outf("// AUTO-GENERATED BY mkstdlib.go\n\n")
	outf("package imports\n")
	outf("var stdlib = map[string]string{\n")
	f := io.MultiReader(
		mustOpenAll(append(
			// Standard library packages.
			goAPIs(),
			// The API of the syscall/js package needs to be computed explicitly,
			// because it's not included in the GOROOT/api/go1.*.txt files at this time.
			"syscalljs.txt",
			"gopherjs.txt")...)...)
	sc := bufio.NewScanner(f)
	fullImport := map[string]string{} // "zip.NewReader" => "archive/zip"
	ambiguous := map[string]bool{}
	var keys []string
	for sc.Scan() {
		l := sc.Text()
		has := func(v string) bool { return strings.Contains(l, v) }
		if has("struct, ") || has("interface, ") || has(", method (") {
			continue
		}
		if m := sym.FindStringSubmatch(l); m != nil {
			full := m[1]
			key := path.Base(full) + "." + m[2]
			if exist, ok := fullImport[key]; ok {
				if exist != full {
					ambiguous[key] = true
				}
			} else {
				fullImport[key] = full
				keys = append(keys, key)
			}
		}
	}
	if err := sc.Err(); err != nil {
		log.Fatal(err)
	}
	sort.Strings(keys)
	for _, key := range keys {
		if _, skip := skips[fullImport[key]]; skip {
			continue
		}
		if ambiguous[key] {
			outf("\t// %q is ambiguous\n", key)
		} else {
			outf("\t%q: %q,\n", key, fullImport[key])
		}
	}
	outf("}\n")
	fmtbuf, err := format.Source(buf.Bytes())
	if err != nil {
		log.Fatal(err)
	}
	switch *outputFlag {
	case "":
		os.Stdout.Write(fmtbuf)
	default:
		err := ioutil.WriteFile(*outputFlag+".go", fmtbuf, 0644)
		if err != nil {
			log.Fatalf("writing output: %s", err)
		}
	}
}
